{"version":2,"baseVals":{"rating":5,"decay":0.942,"echo_zoom":1.0065,"echo_alpha":0.5,"echo_orient":1,"wave_mode":7,"wave_thick":1,"modwavealphabyvolume":1,"wrap":0,"wave_a":0.302958,"wave_scale":1.718927,"wave_smoothing":0.522,"modwavealphastart":0.95,"modwavealphaend":1.47,"zoomexp":0.94032,"dx":0.00001,"dy":0.00001,"warp":0.01,"wave_r":0.6,"wave_g":0.7,"ob_size":0.005,"ob_a":1,"ib_size":0,"ib_r":0.8,"ib_a":1,"mv_a":0},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.turn=0;a.dx_r=0;a.dy_r=0;","frame_eqs_str":"a.wave_r+=div(1.56*Math.sin(12*a.treb)*a.time,5);a.wave_b+=div(1.585*Math.sin(12*a.bass)*a.time,5);a.wave_g+=div(1.61*Math.sin(12*a.mid)*a.time,5);a.wave_x+=0*Math.sin(.8*a.time);a.wave_y+=0*Math.sin(.5*a.time);a.turn=2*above(a.bass_att,a.turn)+(1-above(a.bass_att,a.turn))*(.96*(a.turn-1.3)+1.3);a.dx_r=.016*equal(a.turn,2)*Math.sin(7*a.time)+(1-equal(a.turn,2))*a.dx_r;a.dy_r=.013*equal(a.turn,2)*Math.sin(8*a.time)+(1-equal(a.turn,2))*a.dy_r;a.dx+=.25*a.dx_r;a.dy+=.25*a.dy_r;\n","pixel_eqs_str":"a.zoom-=.00001<Math.abs(below(a.rad,.61))?.05:.01;","init_eqs_eel":"","frame_eqs_eel":"wave_r = wave_r + (0.5*sin(12*treb)*3.12*time)/5;\nwave_b = wave_b + (0.5*sin(12*bass)*3.17*time)/5;\nwave_g =wave_g + (0.5*sin(12*mid)*3.22*time)/5;\nwave_x = wave_x + 0.00*sin(0.8*time);\nwave_y = wave_y + 0.00*sin(0.5*time);\nturn = above(bass_att,turn)*2 + (1-above(bass_att,turn))*((turn-1.3)*0.96+1.3);\ndx_r = equal(turn,2)*0.016*sin(7*time) + (1-equal(turn,2))*dx_r;\ndy_r = equal(turn,2)*0.013*sin(8*time) + (1-equal(turn,2))*dy_r;\ndx = dx + 0.25*dx_r;\ndy = dy + 0.25*dy_r;","pixel_eqs_eel":"zoom = zoom - if (below (rad,0.61), +0.05, +0.01);","warp":" shader_body { \n  vec2 v_1;\n  vec3 ret_2;\n  v_1 = ((normalize(\n    (uv - 0.5)\n  ) * aspect.xy) * (texsize.zw * 3.0));\n  ret_2 = (0.25 * ((\n    (texture (sampler_main, uv).xyz + texture (sampler_main, (uv + (v_1 * 2.5))).xyz)\n   + texture (sampler_main, \n    (uv + (v_1 * 5.5))\n  ).xyz) + texture (sampler_main, (uv + \n    (v_1 * -4.0)\n  )).xyz));\n  ret_2 = (ret_2 - 0.01);\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xyz = ret_2;\n  ret = tmpvar_3.xyz;\n }","comp":" shader_body { \n  float ang2_1;\n  ang2_1 = ((ang * 0.1591549) + (time * 0.025));\n  float tmpvar_2;\n  tmpvar_2 = (3.0 + floor((rand_preset.z * 5.95)));\n  ang2_1 = (fract((ang2_1 * tmpvar_2)) / tmpvar_2);\n  ang2_1 = (abs((ang2_1 - \n    (0.5 / tmpvar_2)\n  )) * 6.283185);\n  vec2 tmpvar_3;\n  tmpvar_3.x = cos(ang2_1);\n  tmpvar_3.y = sin(ang2_1);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (texture (sampler_main, (0.5 + (\n    ((0.4 * (rad * sqrt(\n      dot (texsize.xy, texsize.xy)\n    ))) * tmpvar_3)\n   * texsize.zw))).xyz * 1.333);\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{\n    // sample previous frame 3 times, creating radial blur\n    float2 v = normalize(uv - 0.5)*aspect.xy;\n    //v = v.yx * float2(1,-1);\n    v *= texsize.zw*3;\n    ret = 0.25*(   tex2D( sampler_main, uv ).xyz\n                   +  tex2D(sampler_main, uv + v*2.5 ).xyz\n                   +  tex2D(sampler_main, uv + v*5.5 ).xyz\n                   +  tex2D(sampler_main, uv + v*-4  ).xyz\n    );\n    \n    // darken over time\n    ret -= 0.01;\n}","comp_hlsl":"shader_body\n{\n    float rad_lq = rad * length(texsize.xy)*0.5;\n    float ang_lq = ang;\n    float2 uv_temp1 = (uv - 0.5) * texsize.xy;\n    float rad_hq = length(uv_temp1);\n    float ang_hq = atan2(-uv_temp1.y, uv_temp1.x);\n\n    float2 uv2 = (uv - 0.5);\n    float rad2 = rad_lq*0.8;\n    float ang2 = ang_lq * M_INV_PI_2;\n\n        // ROTATION OVER TIME\n        #if 1\n          ang2 += time*0.025;   //rotate over time\n        #endif\n\n        // FIN TYPE\n        float fins = 3 + floor(rand_preset.z*5.95);\n        #if 1     // SHARP FINS\n          ang2 = frac(ang2*fins)/fins;\n              // ENABLE THIS TO MAKE THE FINS ALTERNATE: (seamless!)\n              ang2 = abs(ang2 - 0.5/fins);\n        #else     // COSINE FINS - a bit slow\n          ang2 = cos(ang2*M_PI_2*fins) * 0.023;\n        #endif\n\n        // RADIAL KALEIDOSCOPING?\n        #if 0\n          rad2 *= g_fTexSize.z;\n            // choose one:\n            //rad2 = lerp(rad2, frac(rad2*3)/3.0, 0.5);\n            rad2 = cos(rad2*5);\n            //rad2 = sqrt(rad2)*0.5;\n            //rad2 += abs(frac(rad2*7)-0.5)/7.0 * 1.15;  // stepifier\n            //rad2 += cos(rad2*61)*0.02;\n          rad2 *= g_fTexSize.x;\n        #endif\n\n    ang2 *= M_PI_2;\n    uv2 = 0.5 + rad2*float2(cos(ang2),sin(ang2))*texsize.zw;\n\n    ret = tex2D(sampler_main, uv2).xyz;\n    ret *= 1.333; // a little bit of overbright\n}"}