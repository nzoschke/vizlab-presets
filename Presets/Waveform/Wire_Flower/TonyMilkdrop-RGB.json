{"version":2,"baseVals":{"rating":5,"gammaadj":1,"decay":1,"echo_zoom":1,"echo_alpha":0.5,"echo_orient":3,"wave_dots":1,"wave_brighten":0,"brighten":1,"darken":1,"wave_a":1,"wave_scale":4.998,"wave_smoothing":0.9,"wave_mystery":-0.5,"modwavealphastart":0.5,"modwavealphaend":1,"zoomexp":0.99983,"fshader":1,"dx":0.00001,"dy":0.00001,"warp":0.01,"wave_g":0.5,"ob_size":0.005,"ob_a":1,"ib_size":0.005,"ib_r":0,"ib_g":0,"ib_b":0,"ib_a":1,"mv_x":0,"mv_y":0,"mv_l":1,"mv_a":0},"shapes":[{"baseVals":{"textured":1,"y":1.8,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"textured":1,"y":1.8,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"textured":1,"y":1.8,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":100,"rad":0.75003,"r":0,"g2":0,"a2":1,"border_a":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"x = x + 0.5*sin(time);\ny = y + 0.5*cos(time);","init_eqs_eel":"","frame_eqs_eel":"x = x + 0.5*sin(time);\ny = y + 0.5*cos(time);"}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.q1=0;","frame_eqs_str":"a.warp=0;a.q1=.0003*pow(1+1.2*a.bass+.4*a.bass_att+.1*a.treb+.1*a.treb_att+.1*a.mid+.1*a.mid_att,6);a.decay=.125;","pixel_eqs_str":"a.zoom-=1*a.q1;a.rot+=1;","init_eqs_eel":"","frame_eqs_eel":"warp = 0;\nq1 = 0.0003*(pow(1+1.2*bass+0.4*bass_att+0.1*treb+0.1*treb_att+0.1*mid+0.1*mid_att,6));\ndecay = 0.125;","pixel_eqs_eel":"zoom = zoom - 1*q1;\nrot = rot + 1;","warp":" shader_body { \n  vec2 my_uv_1;\n  vec3 ret_2;\n  vec2 tmpvar_3;\n  tmpvar_3 = ((uv - 0.5) * vec2(3.0, 3.0));\n  vec2 tmpvar_4;\n  tmpvar_4.x = ((tmpvar_3.x * tmpvar_3.x) - (tmpvar_3.y * tmpvar_3.y));\n  tmpvar_4.y = ((2.0 * tmpvar_3.x) * tmpvar_3.y);\n  vec2 tmpvar_5;\n  tmpvar_5.x = -((tmpvar_4.y * 2.0));\n  tmpvar_5.y = (tmpvar_4.x * 2.0);\n  vec2 tmpvar_6;\n  tmpvar_6.x = ((tmpvar_4.x * (tmpvar_5.x + 1.0)) + (tmpvar_4.y * tmpvar_5.y));\n  tmpvar_6.y = ((tmpvar_4.y * (tmpvar_5.x + 1.0)) - (tmpvar_4.x * tmpvar_5.y));\n  my_uv_1 = (tmpvar_6 * (1.0/((\n    ((tmpvar_5.x + 1.0) * (tmpvar_5.x + 1.0))\n   + \n    (tmpvar_5.y * tmpvar_5.y)\n  ))));\n  ret_2.z = (texture (sampler_fc_main, (my_uv_1 - floor(my_uv_1))).z - 0.004);\n  vec2 tmpvar_7;\n  tmpvar_7 = (uv_orig - 0.5);\n  ret_2.y = ((texture (sampler_main, (0.5 + \n    (tmpvar_7 * 0.992)\n  )).y * 0.98) - 0.004);\n  ret_2.x = ((texture (sampler_main, (0.5 + \n    (tmpvar_7 * 1.004)\n  )).x * 0.9) - 0.008);\n  vec4 tmpvar_8;\n  tmpvar_8.w = 1.0;\n  tmpvar_8.xyz = ret_2;\n  ret = tmpvar_8.xyz;\n }","comp":" shader_body { \n  float ang2_1;\n  ang2_1 = ((ang * 0.1591549) + q9);\n  float tmpvar_2;\n  tmpvar_2 = (3.0 + floor((rand_preset.z * 2.95)));\n  ang2_1 = (fract((ang2_1 * tmpvar_2)) / tmpvar_2);\n  ang2_1 = (abs((ang2_1 - \n    (0.5 / tmpvar_2)\n  )) * 6.283185);\n  vec2 tmpvar_3;\n  tmpvar_3.x = cos(ang2_1);\n  tmpvar_3.y = sin(ang2_1);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (texture (sampler_main, (0.5 + (\n    ((0.4 * (rad * sqrt(\n      dot (texsize.xy, texsize.xy)\n    ))) * tmpvar_3)\n   * texsize.zw))).xyz * 1.2);\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{\nfloat2 zoom = 3;\nfloat2 cntr = float2(-0,-0);\nfloat2 c = float2(0,2);\nfloat2 my_uv = (uv-0.5-cntr)*zoom;\nfloat2 u2 = float2(my_uv.x*my_uv.x - my_uv.y*my_uv.y, 2*my_uv.x*my_uv.y);\nfloat2 cu2 = float2(u2.x*c.x - u2.y*c.y, u2.x*c.y + c.x*u2.y);\nfloat denom = 1/((cu2.x+1)*(cu2.x+1)+cu2.y*cu2.y);\nmy_uv = float2(u2.x*(cu2.x+1)+u2.y*cu2.y,u2.y*(cu2.x+1)-u2.x*cu2.y)*denom;\n\n\nret.z = tex2D( sampler_fc_main, my_uv - floor(my_uv) ).z - 0.004;\nret.y = GetPixel(0.5 + (uv_orig-0.5)*0.992).y*0.98 - 0.004;\nret.x = GetPixel(0.5 + (uv_orig-0.5)*1.004).x*0.9 - 0.008;\n\n}","comp_hlsl":"shader_body\n{\n    float rad_lq = rad * length(texsize.xy)*0.5;\n    float ang_lq = ang;\n    float2 uv_temp1 = (uv - 0.5) * texsize.xy;\n    float rad_hq = length(uv_temp1);\n    float ang_hq = atan2(-uv_temp1.y, uv_temp1.x);\n\n    float2 uv2 = (uv - 0.5);\n    float rad2 = rad_lq*0.8;\n    float ang2 = ang_lq * M_INV_PI_2;\n\n        // ROTATION OVER TIME\n        #if 1\n          ang2 += q9;   //rotate over time\n        #endif\n\n        // FIN TYPE\n        //float fins = 1 + floor(rand_preset.z*5.95);\n        float fins = 3 + floor(rand_preset.z*2.95);\n              \n        #if 1     // SHARP FINS\n          ang2 = frac(ang2*fins)/fins;\n              // ENABLE THIS TO MAKE THE FINS ALTERNATE: (seamless!)\n              ang2 = abs(ang2 - 0.5/fins);\n        #else     // COSINE FINS - a bit slow\n          ang2 = cos(ang2*M_PI_2*fins) * 0.023;\n        #endif\n\n        // RADIAL KALEIDOSCOPING?\n        #if 0\n          rad2 *= g_fTexSize.z;\n            // choose one:\n            //rad2 = lerp(rad2, frac(rad2*3)/3.0, 0.5);\n            rad2 = cos(rad2*5);\n            //rad2 = sqrt(rad2)*0.5;\n            //rad2 += abs(frac(rad2*7)-0.5)/7.0 * 1.15;  // stepifier\n            //rad2 += cos(rad2*61)*0.02;\n          rad2 *= g_fTexSize.x;\n        #endif\n\n    ang2 *= M_PI_2;\n    uv2 = 0.5 + rad2*float2(cos(ang2),sin(ang2))*texsize.zw;\n\n    ret = tex2D(sampler_main, uv2).xyz;\n    ret *= 1.2; // a little bit of overbright\n}"}