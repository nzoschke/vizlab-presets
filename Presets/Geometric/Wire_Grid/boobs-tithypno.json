{"version":2,"baseVals":{"rating":5,"wave_mode":7,"wave_thick":1,"wave_brighten":0,"wave_a":100,"wave_scale":0.198,"wave_mystery":1,"warpanimspeed":0.01,"warpscale":0.01,"rot":-0.02,"warp":0.01,"wave_r":0.5,"wave_g":0.5,"wave_b":0.5,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":12.8,"mv_y":11.4,"mv_l":5},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.c=0;","frame_eqs_str":"a.rot=.00001<Math.abs(above(a.bass,1.3))?-a.rot:a.rot;a.wave_x=.5+.3*Math.cos(2.8*a.time);a.wave_r=div(Math.floor(rand(101)),100);a.wave_g=div(Math.floor(rand(101)),100);a.wave_b=div(Math.floor(rand(101)),100);a.cx=.5+.9*Math.sin(3*a.time);a.cy=.5+.9*Math.cos(3*a.time);","pixel_eqs_str":"a.c=8;a.rot=a.rot*(sigmoid(a.rad-.5,a.c)-.5)*2;","init_eqs_eel":"","frame_eqs_eel":"rot=if(above(bass,1.3),-rot,rot);\nwave_x=0.5+(cos(time*2.8)*0.3);\nwave_r=int(rand(101))/100;\nwave_g=int(rand(101))/100;\nwave_b=int(rand(101))/100;\ncx=0.5+sin(time*3)*0.9;\ncy=0.5+cos(time*3)*0.9;","pixel_eqs_eel":"//rot=if(above(rad,0.5),-rot,rot);\n\n// i don't like the block effects very much, the sigmoid function does a very good job to avoid them\n// http://en.wikipedia.org/wiki/Sigmoid_function\n// welcome to our crazy microcosmos ;)\n\nc = 8; // try values from 1 to 100\nrot = rot*(sigmoid(rad-0.5,c)-0.5)*2;","warp":" shader_body { \n  float final_noise_1;\n  mat2 tmpvar_2;\n  tmpvar_2[uint(0)].x = q5;\n  tmpvar_2[uint(0)].y = -(q4);\n  tmpvar_2[1u].x = q4;\n  tmpvar_2[1u].y = q5;\n  vec3 tmpvar_3;\n  tmpvar_3.xy = uv;\n  tmpvar_3.z = q2;\n  final_noise_1 = ((texture (sampler_noisevol_hq, (tmpvar_3 * \n    pow (q3, 0.0)\n  )) * 2.0) - 1.0).x;\n  final_noise_1 = (final_noise_1 + (0.5 * (\n    (texture (sampler_noisevol_hq, (tmpvar_3 * q3)) * 2.0)\n   - 1.0)).x);\n  final_noise_1 = (final_noise_1 + (0.25 * (\n    (texture (sampler_noisevol_hq, (tmpvar_3 * (q3 * q3))) * 2.0)\n   - 1.0)).x);\n  final_noise_1 = (final_noise_1 + (0.125 * (\n    (texture (sampler_noisevol_hq, (tmpvar_3 * pow (q3, 3.0))) * 2.0)\n   - 1.0)).x);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (texture (sampler_main, ((\n    (((uv - 0.5) * tmpvar_2) * (1.0 - ((rad * 3.7) * (1.0 - \n      (bass_att * 0.3)\n    ))))\n   * final_noise_1) + 0.5)).xyz - 0.08);\n  ret = tmpvar_4.xyz;\n }","comp":"vec2 xlat_mutablerss;\nvec2 xlat_mutablerss0;\nfloat xlat_mutabletime;\n shader_body { \n  vec2 uv_1;\n  vec2 uv1_2;\n  vec3 ret_3;\n  uv_1 = (0.5 + ((uv - 0.5) * aspect.wz));\n  xlat_mutabletime = (time * 0.4);\n  float tmpvar_4;\n  vec3 dots_5;\n  vec2 tmpvar_6;\n  tmpvar_6 = (uv_1 - vec2(0.1, 0.5));\n  float tmpvar_7;\n  float tmpvar_8;\n  tmpvar_8 = (min (abs(\n    (tmpvar_6.x / tmpvar_6.y)\n  ), 1.0) / max (abs(\n    (tmpvar_6.x / tmpvar_6.y)\n  ), 1.0));\n  float tmpvar_9;\n  tmpvar_9 = (tmpvar_8 * tmpvar_8);\n  tmpvar_9 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_9) + 0.05368138) * tmpvar_9) - 0.1173503)\n     * tmpvar_9) + 0.1938925) * tmpvar_9) - 0.3326756)\n   * tmpvar_9) + 0.9999793) * tmpvar_8);\n  tmpvar_9 = (tmpvar_9 + (float(\n    (abs((tmpvar_6.x / tmpvar_6.y)) > 1.0)\n  ) * (\n    (tmpvar_9 * -2.0)\n   + 1.570796)));\n  tmpvar_7 = (tmpvar_9 * sign((tmpvar_6.x / tmpvar_6.y)));\n  if ((abs(tmpvar_6.y) > (1e-08 * abs(tmpvar_6.x)))) {\n    if ((tmpvar_6.y < 0.0)) {\n      if ((tmpvar_6.x >= 0.0)) {\n        tmpvar_7 += 3.141593;\n      } else {\n        tmpvar_7 = (tmpvar_7 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_7 = (sign(tmpvar_6.x) * 1.570796);\n  };\n  xlat_mutablerss0.x = (tmpvar_7 / 3.1416);\n  xlat_mutablerss0.y = (0.003 / sqrt(dot (tmpvar_6, tmpvar_6)));\n  vec2 tmpvar_10;\n  tmpvar_10.x = (xlat_mutablerss0.x + (q1 / 3.0));\n  tmpvar_10.y = (xlat_mutablerss0.y + xlat_mutabletime);\n  xlat_mutablerss = (tmpvar_10 * mat2(0.7, -0.7, 0.7, 0.7));\n  vec4 tmpvar_11;\n  tmpvar_11 = vec4(greaterThanEqual ((texture (sampler_pw_noise_lq, \n    (xlat_mutablerss / 32.0)\n  ) - 0.5), vec4(0.0, 0.0, 0.0, 0.0)));\n  vec2 tmpvar_12;\n  tmpvar_12 = abs((fract(\n    (xlat_mutablerss * 8.0)\n  ) - 0.5));\n  vec2 tmpvar_13;\n  tmpvar_13.x = xlat_mutablerss0.x;\n  tmpvar_13.y = (xlat_mutablerss0.y + (xlat_mutabletime / 4.0));\n  xlat_mutablerss = (tmpvar_13 * mat2(0.7, -0.7, 0.7, 0.7));\n  vec2 tmpvar_14;\n  tmpvar_14 = abs((fract(\n    (xlat_mutablerss * 8.0)\n  ) - 0.5));\n  dots_5 = (vec3((clamp (\n    (0.04 / sqrt(dot (tmpvar_12, tmpvar_12)))\n  , 0.0, 1.0) * tmpvar_11.x)) + (clamp (\n    (0.02 / sqrt(dot (tmpvar_14, tmpvar_14)))\n  , 0.0, 1.0) * vec4(\n    greaterThanEqual ((texture (sampler_pw_noise_lq, (xlat_mutablerss / 32.0)) - 0.5), vec4(0.0, 0.0, 0.0, 0.0))\n  ).x));\n  dots_5 = (dots_5 * clamp ((0.2 / \n    abs(xlat_mutablerss0.y)\n  ), 0.0, 1.0));\n  tmpvar_4 = (dots_5 * dots_5).x;\n  vec3 dots_15;\n  vec2 tmpvar_16;\n  tmpvar_16 = (uv_1 - vec2(0.9, 0.5));\n  float tmpvar_17;\n  float tmpvar_18;\n  tmpvar_18 = (min (abs(\n    (tmpvar_16.x / tmpvar_16.y)\n  ), 1.0) / max (abs(\n    (tmpvar_16.x / tmpvar_16.y)\n  ), 1.0));\n  float tmpvar_19;\n  tmpvar_19 = (tmpvar_18 * tmpvar_18);\n  tmpvar_19 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_19) + 0.05368138) * tmpvar_19) - 0.1173503)\n     * tmpvar_19) + 0.1938925) * tmpvar_19) - 0.3326756)\n   * tmpvar_19) + 0.9999793) * tmpvar_18);\n  tmpvar_19 = (tmpvar_19 + (float(\n    (abs((tmpvar_16.x / tmpvar_16.y)) > 1.0)\n  ) * (\n    (tmpvar_19 * -2.0)\n   + 1.570796)));\n  tmpvar_17 = (tmpvar_19 * sign((tmpvar_16.x / tmpvar_16.y)));\n  if ((abs(tmpvar_16.y) > (1e-08 * abs(tmpvar_16.x)))) {\n    if ((tmpvar_16.y < 0.0)) {\n      if ((tmpvar_16.x >= 0.0)) {\n        tmpvar_17 += 3.141593;\n      } else {\n        tmpvar_17 = (tmpvar_17 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_17 = (sign(tmpvar_16.x) * 1.570796);\n  };\n  xlat_mutablerss0.x = (tmpvar_17 / 3.1416);\n  xlat_mutablerss0.y = (0.003 / sqrt(dot (tmpvar_16, tmpvar_16)));\n  vec2 tmpvar_20;\n  tmpvar_20.x = (xlat_mutablerss0.x + (q1 / 3.0));\n  tmpvar_20.y = ((xlat_mutablerss0.y + xlat_mutabletime) + 2.0);\n  xlat_mutablerss = (tmpvar_20 * mat2(0.7, -0.7, 0.7, 0.7));\n  vec4 tmpvar_21;\n  tmpvar_21 = vec4(greaterThanEqual ((texture (sampler_pw_noise_lq, \n    (xlat_mutablerss / 32.0)\n  ) - 0.5), vec4(0.0, 0.0, 0.0, 0.0)));\n  vec2 tmpvar_22;\n  tmpvar_22 = abs((fract(\n    (xlat_mutablerss * 8.0)\n  ) - 0.5));\n  vec2 tmpvar_23;\n  tmpvar_23.x = xlat_mutablerss0.x;\n  tmpvar_23.y = (xlat_mutablerss0.y + ((xlat_mutabletime + 2.0) / 4.0));\n  xlat_mutablerss = (tmpvar_23 * mat2(0.7, -0.7, 0.7, 0.7));\n  vec2 tmpvar_24;\n  tmpvar_24 = abs((fract(\n    (xlat_mutablerss * 8.0)\n  ) - 0.5));\n  dots_15 = (vec3((clamp (\n    (0.04 / sqrt(dot (tmpvar_22, tmpvar_22)))\n  , 0.0, 1.0) * tmpvar_21.x)) + (clamp (\n    (0.02 / sqrt(dot (tmpvar_24, tmpvar_24)))\n  , 0.0, 1.0) * vec4(\n    greaterThanEqual ((texture (sampler_pw_noise_lq, (xlat_mutablerss / 32.0)) - 0.5), vec4(0.0, 0.0, 0.0, 0.0))\n  ).x));\n  dots_15 = (dots_15 * clamp ((0.2 / \n    abs(xlat_mutablerss0.y)\n  ), 0.0, 1.0));\n  float tmpvar_25;\n  tmpvar_25 = (tmpvar_4 + (dots_15 * dots_15).x);\n  vec2 tmpvar_26;\n  tmpvar_26.x = q26;\n  tmpvar_26.y = q27;\n  vec2 coord_27;\n  coord_27 = (tmpvar_26 * vec2(8.0, 1.0));\n  vec2 numerator_28;\n  numerator_28 = (uv_1 - vec2(0.1, 0.5));\n  vec2 denominator_29;\n  denominator_29 = (uv_1 - vec2(0.9, 0.5));\n  vec2 tmpvar_30;\n  tmpvar_30.x = ((numerator_28.x * denominator_29.x) + (numerator_28.y * denominator_29.y));\n  tmpvar_30.y = ((numerator_28.y * denominator_29.x) - (numerator_28.x * denominator_29.y));\n  vec2 tmpvar_31;\n  tmpvar_31 = (((tmpvar_30 / \n    ((denominator_29.x * denominator_29.x) + (denominator_29.y * denominator_29.y))\n  ) + 0.5) - vec2(0.5, 0.5));\n  float tmpvar_32;\n  tmpvar_32 = sqrt(dot (tmpvar_31, tmpvar_31));\n  float tmpvar_33;\n  float tmpvar_34;\n  tmpvar_34 = (min (abs(\n    (tmpvar_31.x / tmpvar_31.y)\n  ), 1.0) / max (abs(\n    (tmpvar_31.x / tmpvar_31.y)\n  ), 1.0));\n  float tmpvar_35;\n  tmpvar_35 = (tmpvar_34 * tmpvar_34);\n  tmpvar_35 = (((\n    ((((\n      ((((-0.01213232 * tmpvar_35) + 0.05368138) * tmpvar_35) - 0.1173503)\n     * tmpvar_35) + 0.1938925) * tmpvar_35) - 0.3326756)\n   * tmpvar_35) + 0.9999793) * tmpvar_34);\n  tmpvar_35 = (tmpvar_35 + (float(\n    (abs((tmpvar_31.x / tmpvar_31.y)) > 1.0)\n  ) * (\n    (tmpvar_35 * -2.0)\n   + 1.570796)));\n  tmpvar_33 = (tmpvar_35 * sign((tmpvar_31.x / tmpvar_31.y)));\n  if ((abs(tmpvar_31.y) > (1e-08 * abs(tmpvar_31.x)))) {\n    if ((tmpvar_31.y < 0.0)) {\n      if ((tmpvar_31.x >= 0.0)) {\n        tmpvar_33 += 3.141593;\n      } else {\n        tmpvar_33 = (tmpvar_33 - 3.141593);\n      };\n    };\n  } else {\n    tmpvar_33 = (sign(tmpvar_31.x) * 1.570796);\n  };\n  vec2 tmpvar_36;\n  tmpvar_36.x = ((tmpvar_33 * 2.0) + coord_27.x);\n  tmpvar_36.y = ((0.3 * log(tmpvar_32)) + coord_27.y);\n  uv_1 = (0.5 + ((\n    (1.0 - abs(((\n      fract((vec2(0.07957745, 0.5) * tmpvar_36))\n     * 2.0) - 1.0)))\n   - 0.5) * 0.98));\n  uv_1 = uv_1.yx;\n  vec2 tmpvar_37;\n  tmpvar_37 = (texsize.zw * 3.0);\n  vec3 tmpvar_38;\n  tmpvar_38 = (((texture (sampler_blur1, \n    (uv_1 + (vec2(1.0, 0.0) * tmpvar_37))\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (uv_1 - (vec2(1.0, 0.0) * tmpvar_37))\n  ).xyz * scale1) + bias1));\n  vec3 tmpvar_39;\n  tmpvar_39 = (((texture (sampler_blur1, \n    (uv_1 + (vec2(0.0, 1.0) * tmpvar_37))\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (uv_1 - (vec2(0.0, 1.0) * tmpvar_37))\n  ).xyz * scale1) + bias1));\n  vec2 tmpvar_40;\n  tmpvar_40.x = tmpvar_38.x;\n  tmpvar_40.y = tmpvar_39.x;\n  uv1_2 = (uv_1 + ((tmpvar_40 * texsize.zw) * 32.0));\n  ret_3 = (vec3(0.5, 0.0, 0.0) * texture (sampler_main, uv1_2).x);\n  ret_3.x = (ret_3.x + ((tmpvar_38.x - tmpvar_39.x) * 0.4));\n  ret_3.x = (pow (ret_3.x, 0.8) * 1.2);\n  vec3 tmpvar_41;\n  tmpvar_41 = mix (mix (ret_3, vec3(1.0, 1.0, 1.0), texture (sampler_main, uv1_2).zzz), (1.0 - (texture (sampler_main, uv_1).xyz * 1.5)), vec3(tmpvar_25));\n  ret_3 = tmpvar_41;\n  vec4 tmpvar_42;\n  tmpvar_42.w = 1.0;\n  tmpvar_42.xyz = tmpvar_41;\n  ret = tmpvar_42.xyz;\n }","warp_hlsl":"shader_body\n{\n    \n    float2x2 rot =  {  q5, q4,\n                       -q4, q5 };\n\n    float3 txr = float3(uv,q2);\n\n    float final_noise = 0;\n    final_noise += (1.0/pow(2,0))*(tex3D(sampler_noisevol_hq, txr*pow(q3,0))*2-1);\n    final_noise += (1.0/pow(2,1))*(tex3D(sampler_noisevol_hq, txr*pow(q3,1))*2-1);\n    final_noise += (1.0/pow(2,2))*(tex3D(sampler_noisevol_hq, txr*pow(q3,2))*2-1);\n    final_noise += (1.0/pow(2,3))*(tex3D(sampler_noisevol_hq, txr*pow(q3,3))*2-1);\n\n    final_noise =  pow(final_noise,1);\n    \n    ret = tex2D(sampler_main, mul(uv-0.5,rot)*(1-rad*3.7*(1 - bass_att*0.3))*final_noise + 0.5).xyz; \n   \n    // darken (decay) over time\n    ret = ret - 0.08; //or try: ret -= 0.004;\n}","comp_hlsl":"sampler sampler_pw_noise_lq;\n\nfloat2 rs, rss, rss0, tmp, uvo;\nfloat3 noise;\n\nfloat2 complex_div(float2 numerator, float2 denominator){\n   return float2( numerator.x*denominator.x + numerator.y*denominator.y,\n                  numerator.y*denominator.x - numerator.x*denominator.y)/\n          (denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat2 uv_polar(float2 domain, float2 center){\n   float2 c = domain - center;\n   float rad_hq = length(c);\n   float ang_hq = atan2(c.x,c.y);\n   return float2(ang_hq, rad_hq);\n}\n\nfloat2 uv_polar_logarithmic(float2 domain, float2 center, int fins, float log_factor, float2 coord){\n   float2 polar = uv_polar(domain, center);\n   return float2(polar.x*fins+coord.x, log_factor*log(polar.y) + coord.y);\n}\n\nfloat2 uv_moebius_transformation(float2 domain, float2 zeroPoint, float2 infinityPoint,float zoom){\n   return complex_div((domain - zeroPoint)*zoom, domain - infinityPoint)+0.5;\n}\n\nfloat2 uv_bipolar_logarithmic(float2 domain, float2 northPole, float2 southPole, int fins, float log_factor, float2 coord){\n   float2 help_uv = uv_moebius_transformation(domain, northPole, southPole, 1);\n   return uv_polar_logarithmic(help_uv,0.5,fins,log_factor,coord)*float2(M_INV_PI_2,1);\n}\n\nfloat2 uv_scale(float2 domain, float2 center, float2 scale){\n   return center + (domain-center)*scale;\n}\nfloat2 uv_lens_half_sphere(float2 domain, float2 position, float radius, float refractivity){\n   float2 polar = uv_polar(domain, position);\n   float cone = saturate(1-polar.y/radius);\n   float halfsphere = sqrt(1-pow(cone-1,2));\n   float w = atan2(1-cone,halfsphere);\n   float refrac_w = w-asin(sin(w)/refractivity);\n   float refrac_d = 1-cone - sin(refrac_w)*halfsphere/cos(refrac_w);\n   float2 refrac_uv =position+float2(sin(polar.x),cos(polar.x))*refrac_d*radius;\n   bool mask =(length(domain-position)<radius);\n   return !mask*domain + \n           mask*refrac_uv;\n}\n\n/* code from Martins hardcore mix - Danke ;) */\nfloat hardcore_stars(float2 domain, float2 center, float o){\n\n   float2 uv1 = domain-center;\n   rss0.x = atan2(uv1.x, uv1.y)/3.1416;\n   rss0.y = .003/(length (uv1));\n   rss = float2 (rss0.x+q1/3,rss0.y+time+o);\n   rss = mul(rss,float2x2(.7,.7,-.7,.7));\n   float noise = (tex2D(sampler_pw_noise_lq,rss/32)-.5 >= 0);\n   tmp = abs(frac(rss*8)-.5);\n   float3 dots = saturate(.04/length(tmp)) *noise;\n   rss = float2 (rss0.x,rss0.y+(time+o)/4);\n   rss = mul(rss,float2x2(.7,.7,-.7,.7));\n   noise = (tex2D(sampler_pw_noise_lq,rss/32)-.5 >= 0);\n   tmp = abs(frac(rss*8)-.5);\n   dots += saturate(.02/length(tmp)) * noise;\n   dots *= saturate(.2/abs(rss0.y));\n   return dots*dots;\nreturn 0;\n}\n\n\n\n\n\n\nshader_body\n{\nuv = 0.5 + (uv-0.5)*aspect.wz;\ntime *= 0.4;\n\nfloat2 pole1 =float2(0.1,0.5);\nfloat2 pole2 =float2(0.9,0.5);\n\nfloat stars = hardcore_stars(uv,pole1,0) + hardcore_stars(uv,pole2,2);\n\nuv = uv_bipolar_logarithmic(uv, pole1, pole2, 2, 0.3, float2(q26,q27)*float2(8,1));\nuv = 0.5 + (1.0 - abs( frac( uv * 0.5 ) * 2 - 1.0 )-0.5)*0.98; // Eo.S. mirror code with cutted borders\nuv = uv.yx;\n\nfloat2 uv1 = uv;\nfloat2 d = texsize.zw*3;\nfloat3 dx = GetBlur1(uv1 + float2(1,0)*d) - GetBlur1(uv1 - float2(1,0)*d);\nfloat3 dy = GetBlur1(uv1 + float2(0,1)*d) - GetBlur1(uv1 - float2(0,1)*d);\nuv1 = uv+float2(dx.x,dy.x)*texsize.zw*32;\n     ret = GetPixel(uv1).x*float3(1,0,0)*0.5;\n\nret.x += (+dx.x - dy.x)*0.4;\nret.x = pow(ret.x,0.8)*1.2;\n\nret = lerp(ret,float3(1,1,1),GetPixel(uv1).z);\n\nret = lerp(ret,1-GetPixel(uv)*1.5,stars);\n}\n\n"}