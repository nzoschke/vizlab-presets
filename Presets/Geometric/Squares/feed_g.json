{"version":2,"baseVals":{"rating":5,"gammaadj":1.56,"decay":1,"echo_zoom":0.362,"echo_orient":1,"wave_mode":1,"wrap":0,"darken":1,"wave_a":0.001,"warpscale":1.331,"fshader":1,"zoom":0.99951,"warp":0.01,"wave_r":0,"wave_g":0,"wave_b":0,"ob_size":0,"ob_r":0.01,"ib_size":0,"mv_x":64,"mv_y":48,"mv_l":4.95,"mv_g":0.3,"mv_b":0.2,"mv_a":0},"shapes":[{"baseVals":{"enabled":1,"textured":1,"rad":2.66718,"tex_zoom":0.45112,"g":1,"a":0.15,"g2":0,"a2":0.05},"init_eqs_str":"a.q1=0;","frame_eqs_str":"a.r=.1+.5*Math.sin(a.q1);a.g=.1+.5*Math.sin(.9878*a.q1);a.b=.1+.5*Math.sin(.897*a.q1);","init_eqs_eel":"","frame_eqs_eel":"r = 0.1 + 0.5*sin(q1);\ng = 0.1 + 0.5*sin(q1*0.9878);\nb = 0.1 + 0.5*sin(q1*0.897);"},{"baseVals":{"sides":100,"x":0.35,"y":0,"rad":0.09959,"tex_zoom":0.42497,"r":0,"b":1,"g2":0,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"r = 0.1 + 0.5*sin(q1*0.01);\ng = 0.1 + 0.5*sin(q1*0.09878);\nb = 0.1 + 0.5*sin(q1*0.0897);\n\nr2 = 0.1 + 0.5*sin(q1*0.035);\ng2 = 0.1 + 0.5*sin(q1*0.09878);\nb2 = 0.1 + 0.5*sin(q1*0.0897);","init_eqs_eel":"","frame_eqs_eel":"r = 0.1 + 0.5*sin(q1*0.01);\ng = 0.1 + 0.5*sin(q1*0.09878);\nb = 0.1 + 0.5*sin(q1*0.0897);\n\nr2 = 0.1 + 0.5*sin(q1*0.035);\ng2 = 0.1 + 0.5*sin(q1*0.09878);\nb2 = 0.1 + 0.5*sin(q1*0.0897);"},{"baseVals":{"sides":100,"y":0,"rad":0.10201,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"r = 0.1 + 0.5*sin(q1*0.01);\ng = 0.1 + 0.5*sin(q1*0.03878);\nb = 0.1 + 0.5*sin(q1*0.0497);\n\nr2 = 0.1 + 0.5*sin(q1*0.065);\ng2 = 0.1 + 0.5*sin(q1*0.07878);\nb2 = 0.1 + 0.5*sin(q1*0.0597);","init_eqs_eel":"","frame_eqs_eel":"r = 0.1 + 0.5*sin(q1*0.01);\ng = 0.1 + 0.5*sin(q1*0.03878);\nb = 0.1 + 0.5*sin(q1*0.0497);\n\nr2 = 0.1 + 0.5*sin(q1*0.065);\ng2 = 0.1 + 0.5*sin(q1*0.07878);\nb2 = 0.1 + 0.5*sin(q1*0.0597);"},{"baseVals":{"sides":100,"x":0.65,"y":0,"g":1,"b":1,"r2":1,"g2":0,"b2":1,"a2":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"//x = 0.5 + 0.02*sin(time*0.5 + 1.68);\n//y = 0.5 + 0.02*cos(time*0.5 + 1.68);\n\n\nr = 0.1 + 0.5*sin(q1*0.0144);\ng = 0.1 + 0.5*sin(q1*0.05878);\nb = 0.1 + 0.5*sin(q1*0.0797);\n\nr2 = 0.1 + 0.5*sin(q1*0.065);\ng2 = 0.1 + 0.5*sin(q1*0.07878);\nb2 = 0.1 + 0.5*sin(q1*0.0897);","init_eqs_eel":"","frame_eqs_eel":"//x = 0.5 + 0.02*sin(time*0.5 + 1.68);\n//y = 0.5 + 0.02*cos(time*0.5 + 1.68);\n\n\nr = 0.1 + 0.5*sin(q1*0.0144);\ng = 0.1 + 0.5*sin(q1*0.05878);\nb = 0.1 + 0.5*sin(q1*0.0797);\n\nr2 = 0.1 + 0.5*sin(q1*0.065);\ng2 = 0.1 + 0.5*sin(q1*0.07878);\nb2 = 0.1 + 0.5*sin(q1*0.0897);"}],"waves":[{"baseVals":{"spectrum":1,"thick":1,"additive":1,"r":0,"g":0,"b":0,"a":0.1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"//q1 = state;\n//q2 = basstime;\n\nq1 = 0;\nspeed = bass_att*0.3;\nv = sample*10000 + value2*bass*0.1;\n\n//state 0 elipse\nxs = xs + sin(v*0.1 + sin(v)*0.1)*speed*atan(v*1.51);\nys = ys + sin(v*0.1 + cos(v)*0.1)*speed*atan(v);\n\nx = 0.5 + 0.5*sin(xs*0.1)*cos(time*1 + ys);\ny = 0.5 + 0.5*sin(ys*0.1)*cos(time*1.1 + xs);\n\n\nr = 0.5 + 0.5*sin(time*0.22) + 0.1;\ng = 0.1 + 0.4*sin(time*0.307) + x;\n//b = 0.4 + 0.4*sin(time*0.959);\n\n\nxs = if(above(xs,1000),0 ,xs);\nys = if(above(ys,1000),0 ,ys);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"//q1 = state;\n//q2 = basstime;\n\nq1 = 0;\nspeed = bass_att*0.3;\nv = sample*10000 + value2*bass*0.1;\n\n//state 0 elipse\nxs = xs + sin(v*0.1 + sin(v)*0.1)*speed*atan(v*1.51);\nys = ys + sin(v*0.1 + cos(v)*0.1)*speed*atan(v);\n\nx = 0.5 + 0.5*sin(xs*0.1)*cos(time*1 + ys);\ny = 0.5 + 0.5*sin(ys*0.1)*cos(time*1.1 + xs);\n\n\nr = 0.5 + 0.5*sin(time*0.22) + 0.1;\ng = 0.1 + 0.4*sin(time*0.307) + x;\n//b = 0.4 + 0.4*sin(time*0.959);\n\n\nxs = if(above(xs,1000),0 ,xs);\nys = if(above(ys,1000),0 ,ys);"},{"baseVals":{"enabled":1,"thick":1,"additive":1,"g":0.2,"b":0.2,"a":0.2},"init_eqs_str":"a.xx=0;a.xs=0;a.xd=0;a.zd=0;a.v=0;a.yx=0;a.angle2=0;a.zs=0;a.angle=0;a.ys=0;a.xn=0;a.yd=0;a.angle3=0;a.yn=0;a.u=0;a.q2=0;a.zx=0;","frame_eqs_str":"","point_eqs_str":"a.u=6.28*a.sample;a.v=6.28*a.sample*20;a.xs=Math.cos(a.u)*Math.sin(a.v);a.ys=Math.sin(a.u)*Math.sin(a.v);a.zs=pow(Math.sin(a.v),3);a.angle=.3*a.q2;a.yx=a.ys*Math.cos(a.angle)-a.zs*Math.sin(a.angle);a.zx=a.ys*Math.sin(a.angle)+a.zs*Math.cos(a.angle);a.xx=a.xs;a.angle2=.5*a.q2;a.xd=a.xx*Math.cos(a.angle2)-a.zx*Math.sin(a.angle2);a.zd=a.xx*Math.sin(a.angle2)+a.zx*Math.cos(a.angle2);a.yd=a.yx;a.angle3=.41*a.q2;a.xn=a.xd*Math.cos(a.angle3)-a.yd*Math.sin(a.angle3);a.yn=a.xd*Math.sin(a.angle3)+\na.yd*Math.cos(a.angle3);a.zd+=2;a.x=.5*div(a.xn,a.zd)+.5;a.y=.5*div(a.yn,a.zd)+.5;a.r=Math.sin(a.q2);a.g=Math.sin(2*a.q2);a.b=Math.sin(3*a.q2);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"u = sample*3.14*2;\nv = sample*6.28*20;\n\nxs = cos(u)*sin(v);\nys = sin(u)*sin(v);\nzs = pow(sin(v),3);\n\n\n//rotate x axis\nangle = q2*0.3;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = q2*0.5;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = q2*0.41;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\n\nzd = zd +2;\n\nx = xn/zd*0.5+ 0.5;\ny = yn/zd*0.5+ 0.5;\n\n\nr = sin(q2);\ng = sin(q2*2);\nb = sin(q2*3);"},{"baseVals":{"thick":1,"additive":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"u = sample*3.14*2;\nv = sample*6.28*20;\n\nxs = cos(u)*sin(v);\nys = sin(u)*sin(v);\nzs = pow(sin(v),3);\n\n\n//rotate x axis\nangle = q2*0.3;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = q2*0.5;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = q2*0.41 + 0.05;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\n\nzd = zd +2;\n\nx = xn/zd*0.5+ 0.5;\ny = yn/zd*0.5+ 0.5;\n\n\nr = 0;\ng = 0;\nb = 0;","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"u = sample*3.14*2;\nv = sample*6.28*20;\n\nxs = cos(u)*sin(v);\nys = sin(u)*sin(v);\nzs = pow(sin(v),3);\n\n\n//rotate x axis\nangle = q2*0.3;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = q2*0.5;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = q2*0.41 + 0.05;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\n\nzd = zd +2;\n\nx = xn/zd*0.5+ 0.5;\ny = yn/zd*0.5+ 0.5;\n\n\nr = 0;\ng = 0;\nb = 0;"},{"baseVals":{"spectrum":1,"usedots":1,"thick":1,"additive":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"//apply zoom burst on beat\nflag = above(q3,2);\n//state zero is ready state\nstate = state + flag*equal(state,0);\n\n//upwards flight\nyval = if(equal(state,0),0, yval);\nyval = yval + 0.00004*equal(state,1);\nymax = if(equal(state,0),int(rand(100))*0.004,ymax);\n\n//hit apogee\nstate = if(above(yval,0.5+ymax),2,state);\n\n//reset variable\nyval = if(equal(state,0),0, yval);\nburst = if(equal(state,0),0.001,burst);\nalphax = if(equal(state,0),1,alphax);\nxdriftinc = if(equal(state,0),0,xdriftinc);\n\nburstspeed = if(equal(state,0),int(rand(10)),burstspeed);\nxdrift = if(equal(state,0),int(rand(20)),xdrift);\n//to get the numbers small enough have to use constants\nxdriftinc = xdriftinc\n+ equal(xdrift,0)*equal(state,1)*0.00002\n+ equal(xdrift,1)*equal(state,1)*0.000018\n+ equal(xdrift,2)*equal(state,1)*0.000016\n+ equal(xdrift,3)*equal(state,1)*0.000014\n+ equal(xdrift,4)*equal(state,1)*0.000012\n+ equal(xdrift,5)*equal(state,1)*0.00001\n+ equal(xdrift,6)*equal(state,1)*0.000008\n+ equal(xdrift,7)*equal(state,1)*0.000006\n+ equal(xdrift,8)*equal(state,1)*0.000004\n+ equal(xdrift,9)*equal(state,1)*0.000002\n+ equal(xdrift,11)*equal(state,1)*-0.000002\n+ equal(xdrift,12)*equal(state,1)*-0.000004\n+ equal(xdrift,13)*equal(state,1)*-0.000006\n+ equal(xdrift,14)*equal(state,1)*-0.000008\n+ equal(xdrift,15)*equal(state,1)*-0.00001\n+ equal(xdrift,16)*equal(state,1)*-0.000012\n+ equal(xdrift,17)*equal(state,1)*-0.000014\n+ equal(xdrift,18)*equal(state,1)*-0.000016\n+ equal(xdrift,19)*equal(state,1)*-0.000018;\n\nburst = burst\n+ equal(burstspeed,0)*equal(state,2)*0.000024\n+ equal(burstspeed,1)*equal(state,2)*0.000022\n+ equal(burstspeed,2)*equal(state,2)*0.00002\n+ equal(burstspeed,3)*equal(state,2)*0.000018\n+ equal(burstspeed,4)*equal(state,2)*0.000016\n+ equal(burstspeed,5)*equal(state,2)*0.000014\n+ equal(burstspeed,6)*equal(state,2)*0.000012\n+ equal(burstspeed,7)*equal(state,2)*0.00001\n+ equal(burstspeed,8)*equal(state,2)*0.000008\n+ equal(burstspeed,9)*equal(state,2)*0.000008;\n\nalphax = alphax - 0.00004*equal(state,2);\nstate = if(below(alphax,0),0,state);\n\n\ns = sample*3.14*100;\nss = sample*6.28*1000;\n\n//draw torus\nxs = (burst + 0.0001*cos(s))*cos(ss);\nys = (burst + 0.0001*cos(s))*sin(ss);\nzs = 0.1*burst*sin(s);\n\n\n//rotate x axis\nangle = sin(-q1*0.035)*6.28;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = sin(-q1*0.03)*6.28;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = sin(-q1*0.022)*6.28;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\nzd = zd + 2;\n\nx = xn*zd*0.3 + 0.5;\ny = yn*zd*0.3*1.2;\n\n\nx = x + xdriftinc;\ny = y + sin(yval*1.5) - 0.18;\n\n\nr = 0.5 + 0.5*sin(q1*1.3 + x + x);\ng = 0.5 + 0.5*sin(q1*1.1 + x + y);\nb = 0.5 + 0.5*sin(q1*1.66 + y + y);","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"//apply zoom burst on beat\nflag = above(q3,2);\n//state zero is ready state\nstate = state + flag*equal(state,0);\n\n//upwards flight\nyval = if(equal(state,0),0, yval);\nyval = yval + 0.00004*equal(state,1);\nymax = if(equal(state,0),int(rand(100))*0.004,ymax);\n\n//hit apogee\nstate = if(above(yval,0.5+ymax),2,state);\n\n//reset variable\nyval = if(equal(state,0),0, yval);\nburst = if(equal(state,0),0.001,burst);\nalphax = if(equal(state,0),1,alphax);\nxdriftinc = if(equal(state,0),0,xdriftinc);\n\nburstspeed = if(equal(state,0),int(rand(10)),burstspeed);\nxdrift = if(equal(state,0),int(rand(20)),xdrift);\n//to get the numbers small enough have to use constants\nxdriftinc = xdriftinc\n+ equal(xdrift,0)*equal(state,1)*0.00002\n+ equal(xdrift,1)*equal(state,1)*0.000018\n+ equal(xdrift,2)*equal(state,1)*0.000016\n+ equal(xdrift,3)*equal(state,1)*0.000014\n+ equal(xdrift,4)*equal(state,1)*0.000012\n+ equal(xdrift,5)*equal(state,1)*0.00001\n+ equal(xdrift,6)*equal(state,1)*0.000008\n+ equal(xdrift,7)*equal(state,1)*0.000006\n+ equal(xdrift,8)*equal(state,1)*0.000004\n+ equal(xdrift,9)*equal(state,1)*0.000002\n+ equal(xdrift,11)*equal(state,1)*-0.000002\n+ equal(xdrift,12)*equal(state,1)*-0.000004\n+ equal(xdrift,13)*equal(state,1)*-0.000006\n+ equal(xdrift,14)*equal(state,1)*-0.000008\n+ equal(xdrift,15)*equal(state,1)*-0.00001\n+ equal(xdrift,16)*equal(state,1)*-0.000012\n+ equal(xdrift,17)*equal(state,1)*-0.000014\n+ equal(xdrift,18)*equal(state,1)*-0.000016\n+ equal(xdrift,19)*equal(state,1)*-0.000018;\n\nburst = burst\n+ equal(burstspeed,0)*equal(state,2)*0.000024\n+ equal(burstspeed,1)*equal(state,2)*0.000022\n+ equal(burstspeed,2)*equal(state,2)*0.00002\n+ equal(burstspeed,3)*equal(state,2)*0.000018\n+ equal(burstspeed,4)*equal(state,2)*0.000016\n+ equal(burstspeed,5)*equal(state,2)*0.000014\n+ equal(burstspeed,6)*equal(state,2)*0.000012\n+ equal(burstspeed,7)*equal(state,2)*0.00001\n+ equal(burstspeed,8)*equal(state,2)*0.000008\n+ equal(burstspeed,9)*equal(state,2)*0.000008;\n\nalphax = alphax - 0.00004*equal(state,2);\nstate = if(below(alphax,0),0,state);\n\n\ns = sample*3.14*100;\nss = sample*6.28*1000;\n\n//draw torus\nxs = (burst + 0.0001*cos(s))*cos(ss);\nys = (burst + 0.0001*cos(s))*sin(ss);\nzs = 0.1*burst*sin(s);\n\n\n//rotate x axis\nangle = sin(-q1*0.035)*6.28;\nyx = ys*cos(angle) - zs*sin(angle);\nzx = ys*sin(angle) + zs*cos(angle);\nxx = xs;\n\n//rotate y axis\nangle2 = sin(-q1*0.03)*6.28;\nxd = xx*cos(angle2) - zx*sin(angle2);\nzd = xx*sin(angle2) + zx*cos(angle2);\nyd = yx;\n\n//rotaye z axis\nangle3 = sin(-q1*0.022)*6.28;\nxn = xd*cos(angle3) - yd*sin(angle3);\nyn = xd*sin(angle3) + yd*cos(angle3);\n\nzd = zd + 2;\n\nx = xn*zd*0.3 + 0.5;\ny = yn*zd*0.3*1.2;\n\n\nx = x + xdriftinc;\ny = y + sin(yval*1.5) - 0.18;\n\n\nr = 0.5 + 0.5*sin(q1*1.3 + x + x);\ng = 0.5 + 0.5*sin(q1*1.1 + x + y);\nb = 0.5 + 0.5*sin(q1*1.66 + y + y);"}],"init_eqs_str":"a.dxm=0;a.q25=0;a.q12=0;a.ocog=0;a.batr=0;a.q18=0;a.q22=0;a.q21=0;a.vt=0;a.q13=0;a.q15=0;a.q29=0;a.q6=0;a.thresh=0;a.q1=0;a.q5=0;a.vb=0;a.cog=0;a.q9=0;a.dy_r=0;a.v=0;a.mm=0;a.tt=0;a.q31=0;a.q23=0;a.q24=0;a.addict=0;a.q11=0;a.natr=0;a.q10=0;a.q4=0;a.spik=0;a.dym=0;a.dx_r=0;a.q16=0;a.q26=0;a.cha=0;a.q19=0;a.q17=0;a.bb=0;a.q2=0;a.q27=0;a.q14=0;a.q3=0;a.vvm=0;a.q32=0;a.vvb=0;a.q7=0;a.q28=0;a.vm=0;a.q30=0;a.q20=0;a.vvt=0;a.q8=0;a.batr=a.bass_att+a.treb_att;a.natr=a.batr;","frame_eqs_str":"a.vb=.95*a.vb+(1-a.vb)*pow(a.bass_att*a.treb_att*a.mid_att,2)*.02;a.vvb=.95*a.vvb+(1-a.vvb)*a.vb*.01;a.vm=.95*a.vm+(1-a.vm)*pow(a.mid_att,2)*.02;a.vvm=.95*a.vvm+(1-a.vvm)*a.vm*.01;a.vt=.95*a.vt+(1-a.vt)*pow(a.treb_att,2)*.02;a.vvt=.95*a.vvt+(1-a.vvt)*a.vt*.01;a.vvb=Math.min(1,Math.max(0,a.vvb));a.vvm=Math.min(1,Math.max(0,a.vvm));a.vvt=Math.min(1,Math.max(0,a.vvt));a.q1=2*a.vvb;a.q2=2*a.vvm;a.q3=2*a.vvt;a.v=2;a.bb-=a.vvb*a.v;a.mm-=a.vvm*a.v;a.tt-=a.vvt*a.v;a.q4=-a.bb;a.q5=-a.mm;\na.q6=-a.tt;a.q4=5*(a.q1+a.q2+a.q3);a.q5=5*(a.q1+a.q2+a.q3);a.q6=5*(a.q1+a.q2+a.q3);a.q7=5*(a.q1+a.q2+a.q3);a.q8=5*(a.q1+a.q2+a.q3);a.q9=5*(a.q1+a.q2+a.q3);a.q10=5*(a.q1+a.q2+a.q3);a.q11=5*(a.q1+a.q2+a.q3);a.q12=5*(a.q1+a.q2+a.q3);a.q13=5*(a.q1+a.q2+a.q3);a.q14=5*(a.q1+a.q2+a.q3);a.q15=5*(a.q1+a.q2+a.q3);a.q16=5*(a.q1+a.q2+a.q3);a.q17=5*(a.q1+a.q2+a.q3);a.q18=5*(a.q1+a.q2+a.q3);a.q19=5*(a.q1+a.q2+a.q3);a.q20=5*(a.q1+a.q2+a.q3);a.q21=5*(a.q1+a.q2+a.q3);a.q22=5*(a.q1+a.q2+a.q3);a.q23=5*(a.q1+a.q2+a.q3);\na.q24=5*(a.q1+a.q2+a.q3);a.q25=5*(a.q1+a.q2+a.q3);a.q26=5*(a.q1+a.q2+a.q3);a.q27=5*(a.q1+a.q2+a.q3);a.q28=5*(a.q1+a.q2+a.q3);a.q29=5*(a.q1+a.q2+a.q3);a.q30=5*(a.q1+a.q2+a.q3);a.q31=5*(a.q1+a.q2+a.q3);a.q32=5*(a.q1+a.q2+a.q3);a.thresh=2*above(a.bass_att,a.thresh)+(1-above(a.bass_att,a.thresh))*(.96*(a.thresh-1.3)+1.3);a.dx_r=.015*equal(a.thresh,2)*Math.sin(5*a.time)+(1-equal(a.thresh,2))*a.dx_r;a.dy_r=.015*equal(a.thresh,2)*Math.sin(6*a.time)+(1-equal(a.thresh,2))*a.dy_r;a.natr=a.bass_att+a.thresh*\na.treb_att;a.cha=Math.abs(a.batr-a.natr);a.spik=above(Math.abs(a.cha-a.addict),a.addict);a.addict=div(a.addict+a.cha,2);a.zoom+=(.00001<Math.abs(above(2*a.bass,a.treb)-1)?-1:1)*above(a.cha*a.thresh,2)*.1;a.mv_r=Math.log(a.thresh)*a.spik;a.mv_b=Math.abs(a.spik*a.cha-1);a.mv_g=Math.sin(a.time+a.thresh);a.mv_a=.75*a.spik;a.batr=a.natr;a.monitor=Math.log(a.thresh);a.wave_r=a.wave_r+.35*Math.sin(3*a.time)+.15*Math.sin(2.5*a.time);a.wave_g=a.wave_g+.35*Math.sin(2.7*a.time)+.15*Math.sin(2.11*a.time);a.wave_b=\na.wave_b+.35*Math.sin(2.84*a.time)+.15*Math.sin(2.3*a.time);a.wave_mystery*=a.addict;a.cog=a.ocog+.005*(a.bass+a.bass_att+a.bass*a.bass_att-2);a.ocog=below(a.cog,3E4)*a.cog;a.q1=a.batr;a.q2=a.spik;","pixel_eqs_str":"a.dxm=.01*Math.sin(.41*a.time);a.dym=.01*Math.sin(.36*a.time);a.dx=a.dxm+.01*Math.sin(80*a.x+Math.sin(a.time))+.005*Math.sin(a.q1*a.y*Math.sin(.94*a.time));a.dy=a.dym+.01*Math.sin(80*a.y+Math.sin(a.time))+.005*Math.sin(a.q1*a.x*Math.sin(.97*a.time));","init_eqs_eel":"batr=bass_att+treb_att;\nnatr=batr;","frame_eqs_eel":"//per frame less reactive volume for all unused q vars, put before other q vars are set for cop out mashing\nvb = vb*0.95 + (1-vb)*pow(bass_att*treb_att*mid_att,2)*0.02;\nvvb = vvb*0.95 + (1-vvb)*vb*0.01;\nvm = vm*0.95 + (1-vm)*pow(mid_att,2)*0.02;\nvvm = vvm*0.95 + (1-vvm)*vm*0.01;\nvt = vt*0.95 + (1-vt)*pow(treb_att,2)*0.02;\nvvt = vvt*0.95 + (1-vvt)*vt*0.01;\nvvb = min(1,max(0,vvb));\nvvm = min(1,max(0,vvm));\nvvt = min(1,max(0,vvt));\nq1 = vvb*2;//0.5 + vb - vvb;\nq2 = vvm*2;//0.5 + vm - vvm;\nq3 = vvt*2;//0.5 + vt - vvt;\nv=2;\nbb = bb - vvb*v;\nmm = mm - vvm*v;\ntt = tt - vvt*v;\nq4 = -bb;\nq5 = -mm;\nq6 = -tt;\nq4=(q1+q2+q3)*5;\nq5=(q1+q2+q3)*5;\nq6=(q1+q2+q3)*5;\nq7=(q1+q2+q3)*5;\nq8=(q1+q2+q3)*5;\nq9=(q1+q2+q3)*5;\nq10=(q1+q2+q3)*5;\nq11=(q1+q2+q3)*5;\nq12=(q1+q2+q3)*5;\nq13=(q1+q2+q3)*5;\nq14=(q1+q2+q3)*5;\nq15=(q1+q2+q3)*5;\nq16=(q1+q2+q3)*5;\nq17=(q1+q2+q3)*5;\nq18=(q1+q2+q3)*5;\nq19=(q1+q2+q3)*5;\nq20=(q1+q2+q3)*5;\nq21=(q1+q2+q3)*5;\nq22=(q1+q2+q3)*5;\nq23=(q1+q2+q3)*5;\nq24=(q1+q2+q3)*5;\nq25=(q1+q2+q3)*5;\nq26=(q1+q2+q3)*5;\nq27=(q1+q2+q3)*5;\nq28=(q1+q2+q3)*5;\nq29=(q1+q2+q3)*5;\nq30=(q1+q2+q3)*5;\nq31=(q1+q2+q3)*5;\nq32=(q1+q2+q3)*5;\n\n\nthresh = above(bass_att,thresh)*2+(1-above(bass_att,thresh))*((thresh-1.3)*0.96+1.3);\ndx_r = equal(thresh,2)*0.015*sin(5*time)+(1-equal(thresh,2))*dx_r;\ndy_r = equal(thresh,2)*0.015*sin(6*time)+(1-equal(thresh,2))*dy_r;\nnatr=bass_att+thresh*treb_att;\ncha=abs(batr-natr);\nspik=above(abs(cha-addict),addict);\naddict=(addict+cha)/2;\n\n//effects here\nzoom=zoom+if((above(bass*2,treb)-1),-1,1)*above(cha*thresh,2)*0.1;\n\n\n//added the rotation effect with the same code just to offer some possibilities, activate it if you dare - goody\n//rot=rot+if((above(bass*2,treb)-1),-1,1)*above(cha*thresh,2)*0.1;\n\n//zoomexp=2/zoom;\nmv_r=log(thresh)*spik;\nmv_b=abs(spik*cha-1);\nmv_g=sin(time+thresh);\nmv_a=spik*.75;\n\n//end.\nbatr=natr;\nmonitor=log(thresh);\n\n\nwave_r = wave_r + 0.35*sin(3*time) + 0.15*sin(2.5*time);\nwave_g = wave_g + 0.35*sin(2.7*time) + 0.15*sin(2.11*time);\nwave_b = wave_b + 0.35*sin(2.84*time) + 0.15*sin(2.3*time);\n\nwave_mystery=wave_mystery*(addict);\n\n\ncog = ocog+0.005*(bass+bass_att+(bass*bass_att)-2);\nocog = below(cog,30000)*cog;\n\n\nq1=batr;\nq2=spik;\n\n\n\n\n\n\n//Hai guiz, you found the secret message. What are you gonna do now?","pixel_eqs_eel":"//Tiles- \n//movement first:\ndxm=.01*sin(time*.41);\ndym=.01*sin(time*.36);\n\n//Now the tiles themselves:\ndx=dxm+.01*sin(x*80+sin(time))+.005*sin(q1*(y*sin(time*.94)));\ndy=dym+.01*sin(y*80+sin(time))+.005*sin(q1*(x*sin(time*.97)));\n//end tiles","warp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = dot ((texture (sampler_main, (uv + vec2(0.005, 0.007))) - texture (sampler_main, (uv - vec2(0.005, 0.007)))), vec4(0.32, 0.49, 0.29, 0.0));\n  tmpvar_2.y = dot ((texture (sampler_main, (uv + vec2(-0.007, 0.005))) - texture (sampler_main, (uv - vec2(-0.007, 0.005)))), vec4(0.32, 0.49, 0.29, 0.0));\n  vec3 tmpvar_3;\n  tmpvar_3 = ((texture (sampler_blur1, uv).xyz * scale1) + bias1);\n  ret_1 = (((\n    -(tmpvar_3)\n   * 0.1) + (\n    (texture (sampler_main, (uv - ((tmpvar_2 * \n      (1.0 - tmpvar_3)\n    .xy) * 0.02))).xyz + ((vec3(dot (texture (sampler_noise_lq, \n      ((((texsize.xy * texsize_noise_lq.zw).x * uv) * 0.5) + (0.1 * rand_frame).xy)\n    ), vec4(0.32, 0.49, 0.29, 0.0))) * 0.12) - (0.01 * pow (\n      (1.0 - rad)\n    , 4.0))))\n   * 1.1)) * 0.97);\n  ret_1 = (ret_1 - 0.05);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = ret_1;\n  ret = tmpvar_4.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec4 tmpvar_2;\n  tmpvar_2 = texture (sampler_main, uv);\n  vec2 tmpvar_3;\n  tmpvar_3.x = (uv.x + 0.001);\n  tmpvar_3.y = uv.y;\n  vec4 tmpvar_4;\n  tmpvar_4 = texture (sampler_main, tmpvar_3);\n  float tmpvar_5;\n  tmpvar_5 = abs(((\n    (((tmpvar_2.x + tmpvar_2.y) + tmpvar_2.z) - tmpvar_4.x)\n   - tmpvar_4.y) - tmpvar_4.z));\n  if ((tmpvar_5 > 0.1)) {\n    ret_1 = ((texture (sampler_blur2, uv).xyz * scale2) + bias2);\n  } else {\n    ret_1 = ((texture (sampler_blur3, uv).xyz * scale3) + bias3);\n  };\n  ret_1 = (ret_1 + ((\n    (texture (sampler_blur2, uv).xyz * scale2)\n   + bias2) + normalize(\n    (ret_1 - 0.1)\n  )));\n  ret_1 = (1.0 - ret_1);\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }","warp_hlsl":"sampler sampler_pw_noise_lq;\nfloat3 ret1;\nshader_body {\nfloat corr = texsize.xy*texsize_noise_lq.zw;\nfloat2 uv1 = float2(uv.x-0.5,uv.y-0.5)*aspect.xy;\n\n\nfloat3 noiseVal = lum(tex2D(sampler_noise_lq, corr*uv*.5+ .1*rand_frame));\n\nfloat2 hor = float2 (.005,0.007);\nfloat2 ver = float2 (-0.007,.005);\n\nfloat f0 = 1;\nfloat dx = f0*lum(tex2D(sampler_main,uv+hor) \n         - tex2D(sampler_main,uv-hor));\nfloat dy = f0*lum(tex2D(sampler_main,uv+ver) \n         - tex2D(sampler_main,uv-ver));\n\nfloat2 zz= float2 (dx,dy);\nfloat3 blur = GetBlur1(uv) ;\n\nzz *= 1-blur;\n\nfloat3 crisp = tex2D(sampler_main,uv-zz*.02);\n\ncrisp += noiseVal*(.12) -0.01*pow(1-rad,4);\n\nret1 = -blur*.1+ crisp*1.1;\n\nret = ret1;\n ret *= 0.97;\n  ret -= 0.05;\n}","comp_hlsl":"shader_body\n{\nfloat3 orig,nex;\norig=tex2D(sampler_main,uv);\nnex=tex2D(sampler_main,float2(uv.x+0.001,uv.y));\nif(abs(orig.x+orig.y+orig.z-nex.x-nex.y-nex.z)>0.1)\n{ret=GetBlur2(uv);}else\n{ret=GetBlur3(uv);}; \nret+=GetBlur2(uv)+normalize(ret-0.1);\nret=1-ret;\n}"}