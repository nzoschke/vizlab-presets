{"version":2,"baseVals":{"rating":5,"gammaadj":1.98,"decay":0.5,"echo_zoom":1,"echo_alpha":0.5,"echo_orient":3,"additivewave":1,"darken":1,"wave_a":0.15,"wave_smoothing":0.9,"warpscale":1.772,"zoomexp":5.00873,"zoom":1.04163,"rot":0.003,"warp":0,"wave_r":0.85,"wave_g":0.45,"wave_b":0.3,"ob_size":0.005,"ob_a":1,"mv_x":64,"mv_y":19.2,"mv_l":5,"mv_r":0,"mv_g":0,"mv_b":0,"mv_a":0.1},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.t=0;","frame_eqs_str":"a.t=12.3*a.time;a.wave_r+=.79*(.6*Math.sin(.823*a.t)+.4*Math.sin(.916*a.t));a.wave_g+=.79*(.6*Math.sin(.9*a.t)+.4*Math.sin(1.023*a.t));a.wave_b+=.79*(.6*Math.sin(.808*a.t)+.4*Math.sin(.949*a.t));a.rot+=.05*(.6*Math.sin(.38*a.time)+.4*Math.sin(.54*a.time));a.dx+=.002*(.6*Math.sin(.434*a.time)+.4*Math.sin(.277*a.time));a.dy+=.002*(.6*Math.sin(.384*a.time)+.4*Math.sin(.477*a.time));","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"t = time*12.3;\n//wave_x = wave_x + 0.350*( 0.70*sin(2.221*time*5) + 0.30*sin(1.821*time*15) );\n//wave_y = wave_y + 0.350*( 0.30*sin(1.942*time*5) + 0.70*sin(2.522*time*15) );\nwave_r = wave_r + 0.790*( 0.60*sin(0.823*t) + 0.40*sin(0.916*t) );\nwave_g = wave_g + 0.790*( 0.60*sin(0.900*t) + 0.40*sin(1.023*t) );\nwave_b = wave_b + 0.790*( 0.60*sin(0.808*t) + 0.40*sin(0.949*t) );\nrot = rot + 0.050*( 0.60*sin(0.38*time) + 0.40*sin(0.54*time) );\ndx = dx + 0.002*( 0.60*sin(0.434*time) + 0.40*sin(0.277*time) );\ndy = dy + 0.002*( 0.60*sin(0.384*time) + 0.40*sin(0.477*time) );\n//rot = 0;\n//wave_a = 0;","pixel_eqs_eel":"","warp":"vec2 xlat_mutablec;\nvec2 xlat_mutabletmp;\nvec2 xlat_mutablezz;\n shader_body { \n  vec3 ret_1;\n  xlat_mutablec = (((uv_orig - 0.5) * 4.0) + vec2(-0.5, 0.0));\n  xlat_mutablezz.x = ((xlat_mutablec.x * xlat_mutablec.x) - (xlat_mutablec.y * xlat_mutablec.y));\n  xlat_mutablezz.y = ((2.0 * xlat_mutablec.x) * xlat_mutablec.y);\n  xlat_mutablezz = (xlat_mutablezz + xlat_mutablec);\n  xlat_mutabletmp = xlat_mutablezz;\n  xlat_mutablezz.x = ((xlat_mutablezz.x * xlat_mutablezz.x) - (xlat_mutablezz.y * xlat_mutablezz.y));\n  xlat_mutablezz.y = ((2.0 * xlat_mutabletmp.x) * xlat_mutabletmp.y);\n  xlat_mutablezz = (xlat_mutablezz + xlat_mutablec);\n  xlat_mutabletmp = xlat_mutablezz;\n  xlat_mutablezz.x = ((xlat_mutablezz.x * xlat_mutablezz.x) - (xlat_mutablezz.y * xlat_mutablezz.y));\n  xlat_mutablezz.y = ((2.0 * xlat_mutabletmp.x) * xlat_mutabletmp.y);\n  xlat_mutablezz = (xlat_mutablezz + xlat_mutablec);\n  xlat_mutabletmp = xlat_mutablezz;\n  xlat_mutablezz.x = ((xlat_mutablezz.x * xlat_mutablezz.x) - (xlat_mutablezz.y * xlat_mutablezz.y));\n  xlat_mutablezz.y = ((2.0 * xlat_mutabletmp.x) * xlat_mutabletmp.y);\n  xlat_mutablezz = (xlat_mutablezz + xlat_mutablec);\n  xlat_mutabletmp = xlat_mutablezz;\n  xlat_mutablezz.x = ((xlat_mutablezz.x * xlat_mutablezz.x) - (xlat_mutablezz.y * xlat_mutablezz.y));\n  xlat_mutablezz.y = ((2.0 * xlat_mutabletmp.x) * xlat_mutabletmp.y);\n  xlat_mutablezz = (xlat_mutablezz + xlat_mutablec);\n  xlat_mutabletmp = xlat_mutablezz;\n  xlat_mutablezz.x = ((xlat_mutablezz.x * xlat_mutablezz.x) - (xlat_mutablezz.y * xlat_mutablezz.y));\n  xlat_mutablezz.y = ((2.0 * xlat_mutabletmp.x) * xlat_mutabletmp.y);\n  xlat_mutablezz = (xlat_mutablezz + xlat_mutablec);\n  ret_1 = (((texture (sampler_noise_lq, \n    (abs(xlat_mutablezz) / 12.0)\n  ) * 0.15) / (\n    dot (xlat_mutablezz, xlat_mutablezz)\n   + 2.0)).xyz + texture (sampler_fc_main, (uv + (xlat_mutablezz * q18))).xyz);\n  ret_1 = ((ret_1 * 0.99) - 0.01);\n  vec4 tmpvar_2;\n  tmpvar_2.w = 1.0;\n  tmpvar_2.xyz = ret_1;\n  ret = tmpvar_2.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  float tmpvar_3;\n  tmpvar_3 = -(q8);\n  float tmpvar_4;\n  tmpvar_4 = (uv.x - 0.5);\n  float tmpvar_5;\n  tmpvar_5 = (uv.y - 0.5);\n  tmpvar_2.x = (((\n    (tmpvar_4 * cos((tmpvar_3 * 0.29)))\n   + \n    (tmpvar_5 * sin((tmpvar_3 * 0.29)))\n  ) * 0.8) + 0.5);\n  tmpvar_2.y = (((\n    (-(tmpvar_4) * sin((tmpvar_3 * 0.29)))\n   + \n    (tmpvar_5 * cos((tmpvar_3 * 0.29)))\n  ) * 0.8) + 0.5);\n  ret_1 = (mix (texture (sampler_main, uv).xyz, texture (sampler_main, (\n    (0.5 - uv)\n   + 0.5)).xyz, vec3(0.5, 0.5, 0.5)) * 0.8);\n  ret_1 = (ret_1 + (texture (sampler_main, (tmpvar_2 * q9)).xyz * 0.2));\n  ret_1 = (1.0 - ((ret_1 * \n    (1.0 - ret_1)\n  ) * 4.0));\n  vec4 tmpvar_6;\n  tmpvar_6.w = 1.0;\n  tmpvar_6.xyz = ret_1;\n  ret = tmpvar_6.xyz;\n }","warp_hlsl":"\nfloat3 color, mus;\nfloat dx,dy;\nfloat2 rs, rs0, uv1, c, tmp, zz, uvo;\nfloat3 noise, ret1;\nint n;\nshader_body {\nuvo = uv_orig;\nuv1 = (uv_orig-.5);//*aspect.xy;\n\nfloat z = 1/abs(uv1.y+.3);\nrs.x = uv1.x*10;\nrs.y = z*2;\nrs0 = rs;\nrs *=2;\n\n\nc = uv1*4+float2(-.5,0);\n//c = rs*.1;\nzz = c;\n\nfor (n=1; n<=6; n++)\n{\ntmp = zz;\nzz.x = tmp.x*tmp.x - tmp.y*tmp.y;\nzz.y = 2*tmp.x * tmp.y;\nzz = zz + c;\n}\n\nfloat len=dot(zz,zz);\n\nret = tex2D(sampler_noise_lq,abs(zz)/12) * .15/(len+2); \n//ret += (-0.001*(1/ (len+2)));\nret += tex2D (sampler_fc_main, uv+ zz*q18);\n\n//ret += GetBlur2 (frac(uvo))*.8 * saturate(len-6);\n\nret *= 1;\nret = ret *.99-.01;\n\n}","comp_hlsl":"shader_body\n{\n    \n    //rotate texture cords\n    float texRotU2 = (uv[0] - 0.5)*cos(-q8*0.29) + (uv[1] - 0.5)*sin(-q8*0.29);\n    float texRotv2 = -(uv[0] - 0.5)*sin(-q8*0.29) + (uv[1] - 0.5)*cos(-q8*0.29);\n\n\t\n\t    float2 uv2 = float2(texRotU2*0.8 +0.5, texRotv2*0.8 + 0.5);\n\n    float2 uv_echo = (uv - 0.5)*1.000*float2(-1,-1) + 0.5;\n    ret = lerp( tex2D(sampler_main, uv).xyz, \n                tex2D(sampler_main, uv_echo).xyz, \n                0.50 \n              )*0.8;\n    \n    ret += tex2D(sampler_main, uv2*q9).xyz*0.2;\n    ret *= 1.00; //gamma\n    ret = 1 - ret*(1 - ret)*4; //invert\n}"}