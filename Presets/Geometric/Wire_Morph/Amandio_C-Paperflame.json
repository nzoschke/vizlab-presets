{"version":2,"baseVals":{"rating":5,"wave_mode":1,"wave_thick":1,"wrap":0,"wave_a":0.267756,"wave_scale":0.01,"wave_smoothing":0.9,"wave_mystery":-0.56,"warp":0.01,"mv_a":0},"shapes":[{"baseVals":{"rad":0.49138,"ang":0.75398,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"thick":1,"additive":1},"init_eqs_str":"a.curves=0;a.wave=0;","frame_eqs_str":"","point_eqs_str":"a.curves=6+3*Math.cos(.2*a.time);a.wave=a.sample*a.curves;a.x=.5+.4*Math.sin(a.wave)*Math.cos(.2*a.time);a.y=.5+.15*(Math.cos(a.wave+a.time)+sqrt(a.sample));","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"curves=6+3* cos(.2*time);\nwave=sample*curves;\nx=.5+.4* sin(wave) * cos(.2*time);\ny=.5+.15*( cos(wave+time) +sqrt(sample));"},{"baseVals":{"usedots":1,"thick":1,"additive":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":1,"a":0.73},"init_eqs_str":"a.curves=0;a.wave=0;","frame_eqs_str":"a.r=.7+.2*Math.sin(.1*a.time);a.g=.4+.3*Math.sin(.2*a.time);a.b=.5+.4*Math.sin(.15*a.time);","point_eqs_str":"a.curves=6+3*Math.cos(.2*a.time);a.wave=a.sample*a.curves;a.x=.5+.4*Math.sin(a.wave)*Math.cos(.2*a.time);a.y=.5+.15*(Math.cos(a.wave+a.time)+sqrt(a.sample));a.x+=.03*a.bass_att;","init_eqs_eel":"","frame_eqs_eel":"r=.7+.2*sin(.1*time);\ng=.4+.3*sin(.2*time);\nb=.5+.4*sin(.15*time);","point_eqs_eel":"curves=6+3* cos(.2*time);\nwave=sample*curves;\nx=.5+.4* sin(wave) * cos(.2*time);\ny=.5+.15*( cos(wave+time) +sqrt(sample));\nx=x+.03*bass_att"},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.angle=0;a.q31=0;a.q32=0;a.q5=0;","frame_eqs_str":"a.angle=3.14+.2*Math.sin(.3*a.time);a.q31=Math.sin(a.angle);a.q32=Math.cos(a.angle);a.q5=0;a.sx=.998;a.sy=.998;","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"angle =3.14+.2*sin(.3*time);\nq31 = sin(angle);\nq32 = cos(angle);\nq5=0;\n\nsx=.998;\nsy=.998;","pixel_eqs_eel":"","warp":" shader_body { \n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xyz = (texture (sampler_fc_main, uv).xyz - 0.004);\n  ret = tmpvar_1.xyz;\n }","comp":" shader_body { \n  vec2 uv2_1;\n  vec2 shift_2;\n  vec3 ret_3;\n  ret_3 = texture (sampler_main, uv).xyz;\n  shift_2 = (vec2(q5) * texsize.zw);\n  uv2_1 = (uv - 0.5);\n  vec2 tmpvar_4;\n  tmpvar_4.x = ((uv2_1.x * q32) - (uv2_1.y * q31));\n  tmpvar_4.y = ((uv2_1.x * q31) + (uv2_1.y * q32));\n  uv2_1 = (tmpvar_4 + 0.5);\n  uv2_1 = (uv2_1 + shift_2);\n  ret_3 = max (ret_3, texture (sampler_main, uv2_1).xyz);\n  uv2_1 = (uv2_1 - shift_2);\n  uv2_1 = (uv2_1 - 0.5);\n  vec2 tmpvar_5;\n  tmpvar_5.x = ((uv2_1.x * q32) - (uv2_1.y * q31));\n  tmpvar_5.y = ((uv2_1.x * q31) + (uv2_1.y * q32));\n  uv2_1 = (tmpvar_5 + 0.5);\n  uv2_1 = (uv2_1 + (2.0 * shift_2));\n  ret_3 = max (ret_3, texture (sampler_main, uv2_1).xyz);\n  uv2_1 = (uv2_1 - (2.0 * shift_2));\n  uv2_1 = (uv2_1 - 0.5);\n  vec2 tmpvar_6;\n  tmpvar_6.x = ((uv2_1.x * q32) - (uv2_1.y * q31));\n  tmpvar_6.y = ((uv2_1.x * q31) + (uv2_1.y * q32));\n  uv2_1 = (tmpvar_6 + 0.5);\n  uv2_1 = (uv2_1 + (3.0 * shift_2));\n  ret_3 = max (ret_3, texture (sampler_main, uv2_1).xyz);\n  uv2_1 = (uv2_1 - (3.0 * shift_2));\n  vec4 tmpvar_7;\n  tmpvar_7.w = 1.0;\n  tmpvar_7.xyz = ret_3;\n  ret = tmpvar_7.xyz;\n }","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_fc_main, uv ).xyz;\n    \n    // darken (decay) over time\n    ret -=.004; //or try: ret -= 0.004;\n}","comp_hlsl":"\n/////////// \"Rototranslate\" code by Stahlregen/////////////\n\n\nshader_body\n{\n\n//As a base, sample the main sampler at normal uv coordinates and store as return value:\nret = tex2D(sampler_main, uv).xyz;\n\n//Define the translation in (x,y)-direction and multiply by texsize.zw to convert the length to pixels:\nfloat2 shift = float2(q5,q5)*texsize.zw; \n\n//Take the original uv coordinates as a starting point, store in second set of coordinates:\nfloat2 uv2 = uv;\n\n//Start iterations...\nint n = 1;\nwhile (n<=3) {\n\n//First step: put origin in center;\nuv2 = uv2-.5;\n\n//Next, rotate by a factor we set in the per-frame equations - q32 is cos(angle) and q31 is sin(angle): \nuv2 = float2((uv2.x)*q32 - (uv2.y) * q31,(uv2.x)* q31 + (uv2.y) * q32)+.5;\n\n//Then, shift uv coordinates n times - see the step after the next as to why:\nuv2 += n*shift;\n\n//Sample the main sampler at our new uv2 coordinates, \n//deduct the result from the current return value, \n//store in ret as absolute (difference) value:\nret = max(ret,GetPixel(uv2));\n\n//Remove the shift so we won't rotate it with our coordinates in the next iteration:\nuv2 -= n*shift;\n\n//Iteration +1\nn++;\n}\n\n}"}