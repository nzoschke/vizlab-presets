{"version":2,"baseVals":{"rating":5,"gammaadj":1.9,"decay":1,"echo_zoom":1,"echo_alpha":0.5,"additivewave":1,"modwavealphabyvolume":1,"wave_brighten":0,"invert":1,"wave_a":0.001,"wave_scale":1.286,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpanimspeed":0.451,"warpscale":3.04,"zoomexp":2.19476,"zoom":1.00971,"warp":0.25579,"wave_r":0.65,"wave_g":0.65,"wave_b":0.65,"mv_a":0},"shapes":[{"baseVals":{"sides":50,"rad":0.6623,"r":0,"a":0.1,"r2":1,"b2":1,"a2":0.1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"\n//r = .5 + .5*sin(time*1.123);\n//g = .5 + .5*sin(time*1.456);\n//b = .5 + .5*sin(time*1.789);\n\n\n//r = .5 - .5*sin(q2);\n//g = .5 - .5*sin(q2 + 2.0944);\n//b = .5 - .5*sin(q2 + 4.1888);","init_eqs_eel":"","frame_eqs_eel":"\n//r = .5 + .5*sin(time*1.123);\n//g = .5 + .5*sin(time*1.456);\n//b = .5 + .5*sin(time*1.789);\n\n\n//r = .5 - .5*sin(q2);\n//g = .5 - .5*sin(q2 + 2.0944);\n//b = .5 - .5*sin(q2 + 4.1888);"},{"baseVals":{"sides":50,"additive":1,"textured":1,"rad":0.6623,"r":0,"a":0,"r2":0.4,"b2":1,"a2":0.2,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"tex_zoom = 1/rad;","init_eqs_eel":"","frame_eqs_eel":"tex_zoom = 1/rad;"},{"baseVals":{"sides":50,"textured":1,"x":1,"y":1,"rad":0.98609,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":50,"textured":1,"x":1,"y":0,"rad":0.98609,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"spectrum":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"t3 = q7;\n\nt1 = .5;\nt2 = .5;\n\n//r = .5 + .5*sin(q2);\n//g = .5 + .5*sin(q2 + 2.0944);\n//b = .5 + .5*sin(q2 + 4.1888);","point_eqs_str":"sp = sample*6.2832;\nti = time*20;\nraa = sin(ti*12.87 - sp*15.87)*2.5 - cos(ti*7.98 + sp*9.5)*6 + sin(ti*8.9 + sp*48)*7.4;\nraa = abs(raa - int(raa));\nrab = sin(ti*6.74 - sp*18.52)*5.7 + cos(ti*3.94 + sp*27.55)*1.7 + sin(ti*14.8 + sp*3.5)*4;\nrab = abs(rab - int(rab));\n\ncou = 30;\n\nseg = seg*above(sample,0);\nit = (it + 1)*above(sample,0);\nseg = seg + equal(ita,0);\nita = (ita + 1)*above(sample,0)*below(ita,cou);\ncop = equal(ita,cou);\n\ntoll = toll*above(sample,0);\ntoll = toll + value1 + value2;\ntav = toll/cou*.1;\nmod = raa*bass*.5 - rab*(mid+treb)*.125;\nmod = if(q1,bass*.5*(.5 + .5*sin(sp)) - (mid+treb)*.25*(.5 + .5*cos(sp)),mod);\n\ntoll = toll*(1-cop);\n//toll = 15;\n\n\nla = if((1-t3)*cop*equal(seg,1),tav,la);\nlb = if((1-t3)*cop*equal(seg,2),tav,lb);\nlc = if((1-t3)*cop*equal(seg,3),tav,lc);\nld = if((1-t3)*cop*equal(seg,4),tav,ld);\nle = if((1-t3)*cop*equal(seg,5),tav,le);\nlf = if((1-t3)*cop*equal(seg,6),tav,lf);\nlg = if((1-t3)*cop*equal(seg,7),tav,lg);\nli = if((1-t3)*cop*equal(seg,8),tav,li);\nlj = if((1-t3)*cop*equal(seg,9),tav,lj);\nlk = if((1-t3)*cop*equal(seg,10),tav,lk);\n\naa = if((1-t3)*cop*equal(seg,1),mod,aa);\nab = if((1-t3)*cop*equal(seg,2),mod,ab);\nac = if((1-t3)*cop*equal(seg,3),mod,ac);\nad = if((1-t3)*cop*equal(seg,4),mod,ad);\nae = if((1-t3)*cop*equal(seg,5),mod,ae);\naf = if((1-t3)*cop*equal(seg,6),mod,af);\nag = if((1-t3)*cop*equal(seg,7),mod,ag);\nai = if((1-t3)*cop*equal(seg,8),mod,ai);\naj = if((1-t3)*cop*equal(seg,9),mod,aj);\nak = if((1-t3)*cop*equal(seg,10),mod,ak)*0;\n\n\nlev = lev*above(sample,0); ud = ud*above(sample,0); rep = rep*above(sample,0); lev = if(ud,lev-1,lev+1); rep = (rep + equal(lev,0)); ud = if(equal(lev,0),0,if(equal(lev,10),1,ud));\n\nmx = above(lev,0)*la*sin(aa) + above(lev,1)*lb*sin(ab) + above(lev,2)*lc*sin(ac) + above(lev,3)*ld*sin(ad);\nmy = above(lev,0)*la*cos(aa) + above(lev,1)*lb*cos(ab) + above(lev,2)*lc*cos(ac) + above(lev,3)*ld*cos(ad);\nmx = mx + above(lev,4)*le*sin(ae) + above(lev,5)*lf*sin(af) + above(lev,6)*lg*sin(ag);\nmy = my + above(lev,4)*le*cos(ae) + above(lev,5)*lf*cos(af) + above(lev,6)*lg*cos(ag);\nmx = mx + above(lev,7)*li*sin(ai) + above(lev,8)*lj*sin(aj);// + above(lev,9)*lk*sin(ak);\nmy = my + above(lev,7)*li*cos(ai) + above(lev,8)*lj*cos(aj) + above(lev,9)*lk*cos(ak);\nmx = (1-2*equal(ud,1))*mx*(1-equal(lev,10));\n\nmy = min(my,.25);\n\n// add branches via rotation\npoi = q3;\nmodx = if(equal(lev,poi)*ud,mx,modx);\nmody = if(equal(lev,poi)*ud,my,mody);\nmang = (above(rep,7)*below(rep,14) - above(rep,15)*below(rep,22))*above(lev,poi);\nmodx = 0;\nmx = mx - modx;\nmy = my - mody;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox + modx;\nmy = oy + mody;\n\n\nmang = above(rep,1)*rep*1.0472;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox;\nmy = oy;\n\n\nsz = .5;\nx = mx*.75*sz + t1;\ny = my*sz + t2;\n\n\n\na = t3; // drawn every 2nd frame, gets values in other one","init_eqs_eel":"","frame_eqs_eel":"t3 = q7;\n\nt1 = .5;\nt2 = .5;\n\n//r = .5 + .5*sin(q2);\n//g = .5 + .5*sin(q2 + 2.0944);\n//b = .5 + .5*sin(q2 + 4.1888);","point_eqs_eel":"sp = sample*6.2832;\nti = time*20;\nraa = sin(ti*12.87 - sp*15.87)*2.5 - cos(ti*7.98 + sp*9.5)*6 + sin(ti*8.9 + sp*48)*7.4;\nraa = abs(raa - int(raa));\nrab = sin(ti*6.74 - sp*18.52)*5.7 + cos(ti*3.94 + sp*27.55)*1.7 + sin(ti*14.8 + sp*3.5)*4;\nrab = abs(rab - int(rab));\n\ncou = 30;\n\nseg = seg*above(sample,0);\nit = (it + 1)*above(sample,0);\nseg = seg + equal(ita,0);\nita = (ita + 1)*above(sample,0)*below(ita,cou);\ncop = equal(ita,cou);\n\ntoll = toll*above(sample,0);\ntoll = toll + value1 + value2;\ntav = toll/cou*.1;\nmod = raa*bass*.5 - rab*(mid+treb)*.125;\nmod = if(q1,bass*.5*(.5 + .5*sin(sp)) - (mid+treb)*.25*(.5 + .5*cos(sp)),mod);\n\ntoll = toll*(1-cop);\n//toll = 15;\n\n\nla = if((1-t3)*cop*equal(seg,1),tav,la);\nlb = if((1-t3)*cop*equal(seg,2),tav,lb);\nlc = if((1-t3)*cop*equal(seg,3),tav,lc);\nld = if((1-t3)*cop*equal(seg,4),tav,ld);\nle = if((1-t3)*cop*equal(seg,5),tav,le);\nlf = if((1-t3)*cop*equal(seg,6),tav,lf);\nlg = if((1-t3)*cop*equal(seg,7),tav,lg);\nli = if((1-t3)*cop*equal(seg,8),tav,li);\nlj = if((1-t3)*cop*equal(seg,9),tav,lj);\nlk = if((1-t3)*cop*equal(seg,10),tav,lk);\n\naa = if((1-t3)*cop*equal(seg,1),mod,aa);\nab = if((1-t3)*cop*equal(seg,2),mod,ab);\nac = if((1-t3)*cop*equal(seg,3),mod,ac);\nad = if((1-t3)*cop*equal(seg,4),mod,ad);\nae = if((1-t3)*cop*equal(seg,5),mod,ae);\naf = if((1-t3)*cop*equal(seg,6),mod,af);\nag = if((1-t3)*cop*equal(seg,7),mod,ag);\nai = if((1-t3)*cop*equal(seg,8),mod,ai);\naj = if((1-t3)*cop*equal(seg,9),mod,aj);\nak = if((1-t3)*cop*equal(seg,10),mod,ak)*0;\n\n\nlev = lev*above(sample,0); ud = ud*above(sample,0); rep = rep*above(sample,0); lev = if(ud,lev-1,lev+1); rep = (rep + equal(lev,0)); ud = if(equal(lev,0),0,if(equal(lev,10),1,ud));\n\nmx = above(lev,0)*la*sin(aa) + above(lev,1)*lb*sin(ab) + above(lev,2)*lc*sin(ac) + above(lev,3)*ld*sin(ad);\nmy = above(lev,0)*la*cos(aa) + above(lev,1)*lb*cos(ab) + above(lev,2)*lc*cos(ac) + above(lev,3)*ld*cos(ad);\nmx = mx + above(lev,4)*le*sin(ae) + above(lev,5)*lf*sin(af) + above(lev,6)*lg*sin(ag);\nmy = my + above(lev,4)*le*cos(ae) + above(lev,5)*lf*cos(af) + above(lev,6)*lg*cos(ag);\nmx = mx + above(lev,7)*li*sin(ai) + above(lev,8)*lj*sin(aj);// + above(lev,9)*lk*sin(ak);\nmy = my + above(lev,7)*li*cos(ai) + above(lev,8)*lj*cos(aj) + above(lev,9)*lk*cos(ak);\nmx = (1-2*equal(ud,1))*mx*(1-equal(lev,10));\n\nmy = min(my,.25);\n\n// add branches via rotation\npoi = q3;\nmodx = if(equal(lev,poi)*ud,mx,modx);\nmody = if(equal(lev,poi)*ud,my,mody);\nmang = (above(rep,7)*below(rep,14) - above(rep,15)*below(rep,22))*above(lev,poi);\nmodx = 0;\nmx = mx - modx;\nmy = my - mody;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox + modx;\nmy = oy + mody;\n\n\nmang = above(rep,1)*rep*1.0472;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox;\nmy = oy;\n\n\nsz = .5;\nx = mx*.75*sz + t1;\ny = my*sz + t2;\n\n\n\na = t3; // drawn every 2nd frame, gets values in other one"},{"baseVals":{"spectrum":1,"usedots":1,"thick":1,"enabled":0},"init_eqs_str":"","frame_eqs_str":"t3 = q7;\n\nt1 = .5;\nt2 = .5;","point_eqs_str":"sp = sample*6.2832;\nti = time*20;\nraa = sin(ti*12.87 - sp*15.87)*2.5 - cos(ti*7.98 + sp*9.5)*6 + sin(ti*8.9 + sp*48)*7.4;\nraa = abs(raa - int(raa));\nrab = sin(ti*6.74 - sp*18.52)*5.7 + cos(ti*3.94 + sp*27.55)*1.7 + sin(ti*14.8 + sp*3.5)*4;\nrab = abs(rab - int(rab));\n\ncou = 30;\n\nseg = seg*above(sample,0);\nit = (it + 1)*above(sample,0);\nseg = seg + equal(ita,0);\nita = (ita + 1)*above(sample,0)*below(ita,cou);\ncop = equal(ita,cou);\n\ntoll = toll*above(sample,0);\ntoll = toll + value1 + value2;\ntav = toll/cou*.1;\nmod = raa*bass*.5 - rab*(mid+treb)*.125;\nmod = if(q1,bass*.5*(.5 + .5*sin(sp)) - (mid+treb)*.25*(.5 + .5*cos(sp)),mod);\n\ntoll = toll*(1-cop);\n//toll = 15;\n\n\nla = if((1-t3)*cop*equal(seg,1),tav,la);\nlb = if((1-t3)*cop*equal(seg,2),tav,lb);\nlc = if((1-t3)*cop*equal(seg,3),tav,lc);\nld = if((1-t3)*cop*equal(seg,4),tav,ld);\nle = if((1-t3)*cop*equal(seg,5),tav,le);\nlf = if((1-t3)*cop*equal(seg,6),tav,lf);\nlg = if((1-t3)*cop*equal(seg,7),tav,lg);\nli = if((1-t3)*cop*equal(seg,8),tav,li);\nlj = if((1-t3)*cop*equal(seg,9),tav,lj);\nlk = if((1-t3)*cop*equal(seg,10),tav,lk);\n\naa = if((1-t3)*cop*equal(seg,1),mod,aa);\nab = if((1-t3)*cop*equal(seg,2),mod,ab);\nac = if((1-t3)*cop*equal(seg,3),mod,ac);\nad = if((1-t3)*cop*equal(seg,4),mod,ad);\nae = if((1-t3)*cop*equal(seg,5),mod,ae);\naf = if((1-t3)*cop*equal(seg,6),mod,af);\nag = if((1-t3)*cop*equal(seg,7),mod,ag);\nai = if((1-t3)*cop*equal(seg,8),mod,ai);\naj = if((1-t3)*cop*equal(seg,9),mod,aj);\nak = if((1-t3)*cop*equal(seg,10),mod,ak)*0;\n\n\nlev = lev*above(sample,0); ud = ud*above(sample,0); rep = rep*above(sample,0); lev = if(ud,lev-1,lev+1); rep = (rep + equal(lev,0)); ud = if(equal(lev,0),0,if(equal(lev,10),1,ud));\n\nmx = above(lev,0)*la*sin(aa) + above(lev,1)*lb*sin(ab) + above(lev,2)*lc*sin(ac) + above(lev,3)*ld*sin(ad);\nmy = above(lev,0)*la*cos(aa) + above(lev,1)*lb*cos(ab) + above(lev,2)*lc*cos(ac) + above(lev,3)*ld*cos(ad);\nmx = mx + above(lev,4)*le*sin(ae) + above(lev,5)*lf*sin(af) + above(lev,6)*lg*sin(ag);\nmy = my + above(lev,4)*le*cos(ae) + above(lev,5)*lf*cos(af) + above(lev,6)*lg*cos(ag);\nmx = mx + above(lev,7)*li*sin(ai) + above(lev,8)*lj*sin(aj);// + above(lev,9)*lk*sin(ak);\nmy = my + above(lev,7)*li*cos(ai) + above(lev,8)*lj*cos(aj) + above(lev,9)*lk*cos(ak);\nmx = (1-2*equal(ud,1))*mx*(1-equal(lev,10));\n\nmy = min(my,.25);\n\n// add branches via rotation\npoi = q3;\nmodx = if(equal(lev,poi)*ud,mx,modx);\nmody = if(equal(lev,poi)*ud,my,mody);\nmang = (above(rep,7)*below(rep,14) - above(rep,15)*below(rep,22))*above(lev,poi);\nmodx = 0;\nmx = mx - modx;\nmy = my - mody;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox + modx;\nmy = oy + mody;\n\n\nmang = above(rep,1)*rep*1.0472;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox;\nmy = oy;\n\n\n\nsz = .5;\nx = mx*.75*sz + t1;\ny = my*sz + t2;\n\na = t3; // drawn every 2nd frame, gets values in other one\n\n//r = .5 - .5*sin(q2);\n//g = .5 - .5*sin(q2 + 2.0944);\n//b = .5 - .5*sin(q2 + 4.1888);","init_eqs_eel":"","frame_eqs_eel":"t3 = q7;\n\nt1 = .5;\nt2 = .5;","point_eqs_eel":"sp = sample*6.2832;\nti = time*20;\nraa = sin(ti*12.87 - sp*15.87)*2.5 - cos(ti*7.98 + sp*9.5)*6 + sin(ti*8.9 + sp*48)*7.4;\nraa = abs(raa - int(raa));\nrab = sin(ti*6.74 - sp*18.52)*5.7 + cos(ti*3.94 + sp*27.55)*1.7 + sin(ti*14.8 + sp*3.5)*4;\nrab = abs(rab - int(rab));\n\ncou = 30;\n\nseg = seg*above(sample,0);\nit = (it + 1)*above(sample,0);\nseg = seg + equal(ita,0);\nita = (ita + 1)*above(sample,0)*below(ita,cou);\ncop = equal(ita,cou);\n\ntoll = toll*above(sample,0);\ntoll = toll + value1 + value2;\ntav = toll/cou*.1;\nmod = raa*bass*.5 - rab*(mid+treb)*.125;\nmod = if(q1,bass*.5*(.5 + .5*sin(sp)) - (mid+treb)*.25*(.5 + .5*cos(sp)),mod);\n\ntoll = toll*(1-cop);\n//toll = 15;\n\n\nla = if((1-t3)*cop*equal(seg,1),tav,la);\nlb = if((1-t3)*cop*equal(seg,2),tav,lb);\nlc = if((1-t3)*cop*equal(seg,3),tav,lc);\nld = if((1-t3)*cop*equal(seg,4),tav,ld);\nle = if((1-t3)*cop*equal(seg,5),tav,le);\nlf = if((1-t3)*cop*equal(seg,6),tav,lf);\nlg = if((1-t3)*cop*equal(seg,7),tav,lg);\nli = if((1-t3)*cop*equal(seg,8),tav,li);\nlj = if((1-t3)*cop*equal(seg,9),tav,lj);\nlk = if((1-t3)*cop*equal(seg,10),tav,lk);\n\naa = if((1-t3)*cop*equal(seg,1),mod,aa);\nab = if((1-t3)*cop*equal(seg,2),mod,ab);\nac = if((1-t3)*cop*equal(seg,3),mod,ac);\nad = if((1-t3)*cop*equal(seg,4),mod,ad);\nae = if((1-t3)*cop*equal(seg,5),mod,ae);\naf = if((1-t3)*cop*equal(seg,6),mod,af);\nag = if((1-t3)*cop*equal(seg,7),mod,ag);\nai = if((1-t3)*cop*equal(seg,8),mod,ai);\naj = if((1-t3)*cop*equal(seg,9),mod,aj);\nak = if((1-t3)*cop*equal(seg,10),mod,ak)*0;\n\n\nlev = lev*above(sample,0); ud = ud*above(sample,0); rep = rep*above(sample,0); lev = if(ud,lev-1,lev+1); rep = (rep + equal(lev,0)); ud = if(equal(lev,0),0,if(equal(lev,10),1,ud));\n\nmx = above(lev,0)*la*sin(aa) + above(lev,1)*lb*sin(ab) + above(lev,2)*lc*sin(ac) + above(lev,3)*ld*sin(ad);\nmy = above(lev,0)*la*cos(aa) + above(lev,1)*lb*cos(ab) + above(lev,2)*lc*cos(ac) + above(lev,3)*ld*cos(ad);\nmx = mx + above(lev,4)*le*sin(ae) + above(lev,5)*lf*sin(af) + above(lev,6)*lg*sin(ag);\nmy = my + above(lev,4)*le*cos(ae) + above(lev,5)*lf*cos(af) + above(lev,6)*lg*cos(ag);\nmx = mx + above(lev,7)*li*sin(ai) + above(lev,8)*lj*sin(aj);// + above(lev,9)*lk*sin(ak);\nmy = my + above(lev,7)*li*cos(ai) + above(lev,8)*lj*cos(aj) + above(lev,9)*lk*cos(ak);\nmx = (1-2*equal(ud,1))*mx*(1-equal(lev,10));\n\nmy = min(my,.25);\n\n// add branches via rotation\npoi = q3;\nmodx = if(equal(lev,poi)*ud,mx,modx);\nmody = if(equal(lev,poi)*ud,my,mody);\nmang = (above(rep,7)*below(rep,14) - above(rep,15)*below(rep,22))*above(lev,poi);\nmodx = 0;\nmx = mx - modx;\nmy = my - mody;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox + modx;\nmy = oy + mody;\n\n\nmang = above(rep,1)*rep*1.0472;\nox = mx*cos(mang) - my*sin(mang);\noy = mx*sin(mang) + my*cos(mang);\nmx = ox;\nmy = oy;\n\n\n\nsz = .5;\nx = mx*.75*sz + t1;\ny = my*sz + t2;\n\na = t3; // drawn every 2nd frame, gets values in other one\n\n//r = .5 - .5*sin(q2);\n//g = .5 - .5*sin(q2 + 2.0944);\n//b = .5 - .5*sin(q2 + 4.1888);"},{"baseVals":{"enabled":1,"spectrum":1,"thick":1,"r":0,"b":0},"init_eqs_str":"a.sw=0;a.sp=0;a.sz=0;a.q1=0;a.cv=0;","frame_eqs_str":"","point_eqs_str":"a.sw=1-a.sw;a.sp=6.2832*a.sample-a.time;a.sz=a.sp-a.q1-.3927;a.sz=.5+.5*Math.sin(4*a.sz)+a.value1+a.value2;a.cv=6.2832*a.sz;a.sz=.05*pow(a.sz,.5)*a.sw;a.x=.5+a.sz*Math.sin(a.sp)*.75;a.y=.5+a.sz*Math.cos(a.sp);a.r=.5+.5*Math.sin(.5*(a.time-a.cv));a.g=.5+.5*Math.sin(.5*(a.time-a.cv+2.094));a.b=.5+.5*Math.sin(.5*(a.time-a.cv+4.188));","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"sw = 1-sw;\nsp = sample*6.2832 - time;\n\nsz = sp - q1 - .7854*.5;\nsz = .5 + .5*sin(sz*4) + value1 + value2;\n\ncv = sz*6.2832;\n\nsz = pow(sz,.5)*.05*sw;\n\nx = .5 + sz*sin(sp)*.75;\ny = .5 + sz*cos(sp);\n\nr = .5 + .5*sin(.5*(time - cv));\ng = .5 + .5*sin(.5*(time - cv + 2.094));\nb = .5 + .5*sin(.5*(time - cv + 4.188));"},{"baseVals":{"spectrum":1,"r":0,"b":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.q4=0;a.q5=0;","frame_eqs_str":"a.wave_r+=.35*(.6*Math.sin(.98*a.time)+.4*Math.sin(1.047*a.time));a.wave_g+=.35*(.6*Math.sin(.835*a.time)+.4*Math.sin(1.081*a.time));a.wave_b+=.35*(.6*Math.sin(.814*a.time)+.4*Math.sin(1.011*a.time));a.cx+=.11*(.6*Math.sin(.374*a.time)+.4*Math.sin(.294*a.time));a.cy+=.11*(.6*Math.sin(.393*a.time)+.4*Math.sin(.223*a.time));a.decay-=.01*equal(mod(a.frame,20),0);a.zoom+=.3*(.01*Math.cos(.317*a.time+1)+.01*Math.cos(.1132*a.time+4));a.rot+=.5*(.01*Math.cos(.214*a.time+3)+.01*Math.cos(.2732*\na.time+2));a.wave_mystery=.05*a.time;a.q4=Math.cos(6.2831854*a.wave_mystery);a.q5=Math.sin(6.2831854*a.wave_mystery);","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"wave_r = wave_r + 0.350*( 0.60*sin(0.980*time) + 0.40*sin(1.047*time) );\nwave_g = wave_g + 0.350*( 0.60*sin(0.835*time) + 0.40*sin(1.081*time) );\nwave_b = wave_b + 0.350*( 0.60*sin(0.814*time) + 0.40*sin(1.011*time) );\ncx = cx + 0.110*( 0.60*sin(0.374*time) + 0.40*sin(0.294*time) );\ncy = cy + 0.110*( 0.60*sin(0.393*time) + 0.40*sin(0.223*time) );\ndecay = decay - 0.01*equal(frame%20,0);\n//zoom = 1;\n//warp = 0;\nzoom = zoom + 0.3*(0.01*cos(time*0.317+1) + 0.01*cos(time*0.1132+4));\nrot  = rot  + 0.5*(0.01*cos(time*0.214+3) + 0.01*cos(time*0.2732+2));\nwave_mystery = time*0.05;\nq4 = cos(wave_mystery*3.1415927*2);\nq5 = sin(wave_mystery*3.1415927*2);\n//zoom = zoom + (max(1, bass_att)-1)*0.01;","pixel_eqs_eel":"","warp":" shader_body { \n  vec3 ret_1;\n  ret_1 = texture (sampler_main, uv).xyz;\n  ret_1 = (ret_1 + ((ret_1 - \n    ((texture (sampler_blur2, uv).xyz * scale2) + bias2)\n  ) * 0.3));\n  ret_1 = (ret_1 * 0.9);\n  ret_1 = (ret_1 + ((\n    ((texture (sampler_noise_lq, ((\n      (uv_orig * texsize.xy)\n     * \n      (texsize_noise_lq.zw * 0.4)\n    ) + rand_frame.xy)).xyz - 0.5) / 256.0)\n   * 122.0) * clamp (\n    (treb_att - 1.0)\n  , 0.0, 1.0)));\n  ret_1 = mix (ret_1, vec3(dot (ret_1, vec3(0.32, 0.49, 0.29))), vec3(0.2, 0.2, 0.2));\n  vec4 tmpvar_2;\n  tmpvar_2.w = 1.0;\n  tmpvar_2.xyz = ret_1;\n  ret = tmpvar_2.xyz;\n }","comp":" shader_body { \n  vec2 uv_1;\n  vec2 uv3_2;\n  vec2 uv2_3;\n  uv_1 = (uv - 0.5);\n  uv_1 = (uv_1 * aspect.xy);\n  uv2_3.x = ((uv_1.x * -0.497265) - (uv_1.y * 0.8675987));\n  uv2_3.y = ((uv_1.x * 0.8675987) + (uv_1.y * -0.497265));\n  uv3_2.x = ((uv_1.x * -0.5000263) - (uv_1.y * -0.8660102));\n  uv3_2.y = ((uv_1.x * -0.8660102) + (uv_1.y * -0.5000263));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = max (max (texture (sampler_main, (uv_1 + 0.5)).xyz, texture (sampler_main, (uv2_3 + 0.5)).xyz), texture (sampler_main, (uv3_2 + 0.5)).xyz);\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret.xyz = tex2D( sampler_main, uv ).xyz;\n\n      // take the difference between the crisp and blurred images,\n      // then add it back into the image.  Creates spots and stripes over time.\n      ret.xyz += (ret.xyz - GetBlur2(uv))*0.3;\n      ret.xyz *= 0.9;\n\n      // add noise:\n      float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.4 + rand_frame.xy;\n      ret.xyz += (tex2D(sampler_noise_lq, dither_uv).xyz-0.5)/256.0 * 122 * saturate(treb_att-1);\n\n      // desaturate over time, to keep the globs white\n      ret.xyz = lerp(ret.xyz, lum(ret.xyz), 0.2);\n}","comp_hlsl":"shader_body\n{\n    float2 uv2, uv3;\n    float ang2, c, s;\n\n    uv -= 0.5;\n    uv *= aspect.xy;    \n\n    ang2 = 6.28*0.333;\n    c = cos(ang2);\n    s = sin(ang2);\n    uv2.x =  uv.x*c - uv.y*s;\n    uv2.y =  uv.x*s + uv.y*c;\n\n    ang2 = 6.28*0.667;\n    c = cos(ang2);\n    s = sin(ang2);\n    uv3.x =  uv.x*c - uv.y*s;\n    uv3.y =  uv.x*s + uv.y*c;\n\n    ret = tex2D(sampler_main, uv + 0.5).xyz;\n    ret = max(ret, tex2D(sampler_main,uv2 + 0.5).xyz);\n    ret = max(ret, tex2D(sampler_main,uv3 + 0.5).xyz);\n\n    //ret *= 1.3; // a little bit of overbright\n}\n\n"}