{"version":2,"baseVals":{"rating":5,"gammaadj":1.72,"decay":1,"echo_zoom":1.006,"echo_alpha":0.5,"echo_orient":3,"wave_mode":7,"additivewave":1,"wave_thick":1,"wave_a":100,"wave_scale":0.01,"wave_smoothing":0.5,"wave_mystery":1,"modwavealphastart":0.5,"modwavealphaend":1,"warpscale":1.772,"zoomexp":1.001,"zoom":1.007,"warp":0,"wave_y":0.98,"ob_size":0.005,"ob_r":0.4,"ob_g":0.3,"ob_a":0.7,"ib_size":0.005,"ib_r":0.65,"ib_g":0.05,"ib_b":0.45,"ib_a":0.3,"mv_x":64,"mv_y":2.4,"mv_dy":-0.1,"mv_l":5},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.ok_to_change=0;a.beat_time=0;a.bass_effect=0;a.effect=0;a.treb_effect=0;a.mid_effect=0;","frame_eqs_str":"a.wave_r+=.2*(.6*Math.sin(.823*a.time)+.4*Math.sin(.916*a.time));a.wave_g+=.5*(.6*Math.sin(.9*a.time)+.4*Math.sin(1.023*a.time));a.wave_b+=.5*(.6*Math.sin(.808*a.time)+.4*Math.sin(.949*a.time));a.decay-=.03*equal(mod(a.frame,30),0);a.treb_effect=Math.max(Math.max(a.treb,a.treb_att)-1.25,0);a.mid_effect=Math.max(Math.max(a.mid,a.mid_att)-1.25,0);a.ob_size+=.005*a.treb_effect;a.ib_size+=.005*a.mid_effect;a.ob_r=a.ob_r-.2*a.treb_effect+.2*a.mid_effect;a.ib_g=a.ib_g+.2*a.mid_effect-\n.2*a.treb_effect;","pixel_eqs_str":"a.ok_to_change=.00001<Math.abs(above(a.time,a.beat_time+5))?1:0;a.bass_effect=Math.max(a.bass,a.bass_att)-1;a.beat_time=.00001<Math.abs(above(a.bass_effect,.5))?.00001<Math.abs(a.ok_to_change)?a.time:a.beat_time:a.beat_time;a.effect=.00001<Math.abs(equal(a.time,a.beat_time))?Math.abs(a.effect-1):a.effect;a.bass_effect=Math.max(Math.max(a.bass,a.bass_att)-1.34,0);a.zoom=(.00001<Math.abs(above(a.effect,0))?.4*a.x:.4*a.y)+.6-.13*Math.min(a.bass_effect,.3);","init_eqs_eel":"","frame_eqs_eel":"wave_r = wave_r + 0.200*( 0.60*sin(0.823*time) + 0.40*sin(0.916*time) );\nwave_g = wave_g + 0.500*( 0.60*sin(0.900*time) + 0.40*sin(1.023*time) );\nwave_b = wave_b + 0.500*( 0.60*sin(0.808*time) + 0.40*sin(0.949*time) );\ndecay = decay - 0.03*equal(frame%30,0);\ntreb_effect = max(max(treb,treb_att)-1.25,0);\nmid_effect= max(max(mid,mid_att)-1.25,0);\nob_size = ob_size + 0.005*treb_effect;\nib_size = ib_size + 0.005*mid_effect;\nob_r = ob_r -0.2* treb_effect +0.2* mid_effect;\nib_g = ib_g + 0.2*mid_effect- 0.2*treb_effect;","pixel_eqs_eel":"ok_to_change = if(above(time,beat_time+5),1,0);\nbass_effect = max(bass, bass_att)-1;\nbeat_time = if(above(bass_effect,0.5), if(ok_to_change,time,beat_time),beat_time);\neffect = if(equal(time,beat_time),abs(effect-1),effect);\nbass_effect = max(max(bass,bass_att)-1.34,0);\nzoom = if(above(effect,0),0.4*x,0.4*y) +0.6 -0.13*(min(bass_effect,0.3));","warp":"","comp":" shader_body { \n  float ang2_1;\n  ang2_1 = ((ang * 0.1591549) + q9);\n  float tmpvar_2;\n  tmpvar_2 = (3.0 + floor((rand_preset.z * 2.95)));\n  ang2_1 = (fract((ang2_1 * tmpvar_2)) / tmpvar_2);\n  ang2_1 = (abs((ang2_1 - \n    (0.5 / tmpvar_2)\n  )) * 6.283185);\n  vec2 tmpvar_3;\n  tmpvar_3.x = cos(ang2_1);\n  tmpvar_3.y = sin(ang2_1);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (texture (sampler_main, (0.5 + (\n    ((0.4 * (rad * sqrt(\n      dot (texsize.xy, texsize.xy)\n    ))) * tmpvar_3)\n   * texsize.zw))).xyz * 1.2);\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"","comp_hlsl":"shader_body\n{\n    float rad_lq = rad * length(texsize.xy)*0.5;\n    float ang_lq = ang;\n    float2 uv_temp1 = (uv - 0.5) * texsize.xy;\n    float rad_hq = length(uv_temp1);\n    float ang_hq = atan2(-uv_temp1.y, uv_temp1.x);\n\n    float2 uv2 = (uv - 0.5);\n    float rad2 = rad_lq*0.8;\n    float ang2 = ang_lq * M_INV_PI_2;\n\n        // ROTATION OVER TIME\n        #if 1\n          ang2 += q9;   //rotate over time\n        #endif\n\n        // FIN TYPE\n        //float fins = 1 + floor(rand_preset.z*5.95);\n        float fins = 3 + floor(rand_preset.z*2.95);\n              \n        #if 1     // SHARP FINS\n          ang2 = frac(ang2*fins)/fins;\n              // ENABLE THIS TO MAKE THE FINS ALTERNATE: (seamless!)\n              ang2 = abs(ang2 - 0.5/fins);\n        #else     // COSINE FINS - a bit slow\n          ang2 = cos(ang2*M_PI_2*fins) * 0.023;\n        #endif\n\n        // RADIAL KALEIDOSCOPING?\n        #if 0\n          rad2 *= g_fTexSize.z;\n            // choose one:\n            //rad2 = lerp(rad2, frac(rad2*3)/3.0, 0.5);\n            rad2 = cos(rad2*5);\n            //rad2 = sqrt(rad2)*0.5;\n            //rad2 += abs(frac(rad2*7)-0.5)/7.0 * 1.15;  // stepifier\n            //rad2 += cos(rad2*61)*0.02;\n          rad2 *= g_fTexSize.x;\n        #endif\n\n    ang2 *= M_PI_2;\n    uv2 = 0.5 + rad2*float2(cos(ang2),sin(ang2))*texsize.zw;\n\n    ret = tex2D(sampler_main, uv2).xyz;\n    ret *= 1.2; // a little bit of overbright\n}"}