{"version":2,"baseVals":{"rating":5,"gammaadj":1.9,"echo_zoom":1.169,"wave_mode":7,"additivewave":1,"wave_a":0.168,"wave_scale":2.827,"wave_smoothing":0.09,"modwavealphastart":0.63,"modwavealphaend":0.87,"warpscale":2.853,"zoomexp":2.1,"zoom":1.025,"warp":0.309,"wave_r":0.5,"wave_g":0.5,"wave_b":0.5,"wave_y":0.72,"mv_a":0},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"r = 0.","point_eqs_str":"x = sa","init_eqs_eel":"","frame_eqs_eel":"r = 0.","point_eqs_eel":"x = sa"},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"a.wave_r+=.4*(.6*Math.sin(.933*a.time)+.4*Math.sin(1.045*a.time));a.wave_g+=.4*(.6*Math.sin(.9*a.time)+.4*Math.sin(.956*a.time));a.wave_b+=.4*(.6*Math.sin(.91*a.time)+.4*Math.sin(.92*a.time));a.zoom+=.01*(.6*Math.sin(.339*a.time)+.4*Math.sin(.276*a.time));a.rot+=.01*(.6*Math.sin(.381*a.time)+.4*Math.sin(.579*a.time));a.decay-=.01*equal(mod(a.frame,5),0);","pixel_eqs_str":"a.rot+=.16*Math.sin(-3.3*a.time+11*a.rad)*(1.3-a.rad);a.zoom+=.04*Math.sin(1.2*a.time+18.84*a.ang);","init_eqs_eel":"","frame_eqs_eel":"wave_r = wave_r + 0.400*( 0.60*sin(0.933*time) + 0.40*sin(1.045*time) );\nwave_g = wave_g + 0.400*( 0.60*sin(0.900*time) + 0.40*sin(0.956*time) );\nwave_b = wave_b + 0.400*( 0.60*sin(0.910*time) + 0.40*sin(0.920*time) );\nzoom = zoom + 0.01*( 0.60*sin(0.339*time) + 0.40*sin(0.276*time) );\nrot = rot + 0.010*( 0.60*sin(0.381*time) + 0.40*sin(0.579*time) );\ndecay = decay - 0.01*equal(frame%5,0);","pixel_eqs_eel":"rot=rot+0.16*sin(time*-3.3+rad*11)*(1.3-rad);\nzoom=zoom+0.04*sin(time*1.2+ang*6.28*3);","warp":" shader_body { \n  vec3 ret_1;\n  vec4 tmpvar_2;\n  tmpvar_2 = texture (sampler_main, uv);\n  ret_1 = (tmpvar_2.xyz + ((tmpvar_2.xyz - \n    ((texture (sampler_blur1, uv).xyz * scale1) + bias1)\n  ) * 0.3));\n  ret_1 = (ret_1 * 0.9);\n  ret_1 = (ret_1 + ((\n    (texture (sampler_noise_lq, (((uv_orig * texsize.xy) * (texsize_noise_lq.zw * 0.4)) + rand_frame.xy)).xyz - 0.5)\n   / 256.0) * 112.0));\n  vec3 tmpvar_3;\n  tmpvar_3 = mix (ret_1, vec3(dot (ret_1, vec3(0.32, 0.49, 0.29))), vec3(0.2, 0.2, 0.2));\n  ret_1 = tmpvar_3;\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = tmpvar_3;\n  ret = tmpvar_4.xyz;\n }","comp":" shader_body { \n  float ang2_1;\n  ang2_1 = ((ang * 0.1591549) + (time * 0.025));\n  float tmpvar_2;\n  tmpvar_2 = (3.0 + floor((rand_preset.z * 5.95)));\n  ang2_1 = (fract((ang2_1 * tmpvar_2)) / tmpvar_2);\n  ang2_1 = (abs((ang2_1 - \n    (0.5 / tmpvar_2)\n  )) * 6.283185);\n  vec2 tmpvar_3;\n  tmpvar_3.x = cos(ang2_1);\n  tmpvar_3.y = sin(ang2_1);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (texture (sampler_main, (0.5 + (\n    ((0.4 * (rad * sqrt(\n      dot (texsize.xy, texsize.xy)\n    ))) * tmpvar_3)\n   * texsize.zw))).xyz * 1.333);\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_main, uv ).xyz;\n\n    // take the difference between the crisp and blurred images,\n    // then add it back into the image.  Creates spots and stripes over time.\n    ret += (ret - GetBlur1(uv))*0.3;\n    ret *= 0.9;\n\n    // add noise:\n    float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.4 + rand_frame.xy;\n    ret += (tex2D(sampler_noise_lq, dither_uv).xyz-0.5)/256.0 * 112;\n\n    // desaturate over time, to keep the globs white\n    ret = lerp(ret, lum(ret), 0.2);\n}","comp_hlsl":"shader_body\n{\n    float rad_lq = rad * length(texsize.xy)*0.5;\n    float ang_lq = ang;\n    float2 uv_temp1 = (uv - 0.5) * texsize.xy;\n    float rad_hq = length(uv_temp1);\n    float ang_hq = atan2(-uv_temp1.y, uv_temp1.x);\n\n    float2 uv2 = (uv - 0.5);\n    float rad2 = rad_lq*0.8;\n    float ang2 = ang_lq * M_INV_PI_2;\n\n        // ROTATION OVER TIME\n        #if 1\n          ang2 += time*0.025;   //rotate over time\n        #endif\n\n        // FIN TYPE\n        float fins = 3 + floor(rand_preset.z*5.95);\n        #if 1     // SHARP FINS\n          ang2 = frac(ang2*fins)/fins;\n              // ENABLE THIS TO MAKE THE FINS ALTERNATE: (seamless!)\n              ang2 = abs(ang2 - 0.5/fins);\n        #else     // COSINE FINS - a bit slow\n          ang2 = cos(ang2*M_PI_2*fins) * 0.023;\n        #endif\n\n        // RADIAL KALEIDOSCOPING?\n        #if 0\n          rad2 *= g_fTexSize.z;\n            // choose one:\n            //rad2 = lerp(rad2, frac(rad2*3)/3.0, 0.5);\n            rad2 = cos(rad2*5);\n            //rad2 = sqrt(rad2)*0.5;\n            //rad2 += abs(frac(rad2*7)-0.5)/7.0 * 1.15;  // stepifier\n            //rad2 += cos(rad2*61)*0.02;\n          rad2 *= g_fTexSize.x;\n        #endif\n\n    ang2 *= M_PI_2;\n    uv2 = 0.5 + rad2*float2(cos(ang2),sin(ang2))*texsize.zw;\n\n    ret = tex2D(sampler_main, uv2).xyz;\n    ret *= 1.333; // a little bit of overbright\n}"}