{"version":2,"baseVals":{"rating":5,"gammaadj":1,"decay":0.975,"echo_zoom":1,"echo_orient":3,"additivewave":1,"modwavealphabyvolume":1,"wave_brighten":0,"wrap":0,"bmotionvectorson":0,"wave_a":0.0001,"wave_scale":1.285751,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpscale":1.331,"//zoom":1.0105,"//rot":-0.01,"warp":0,"wave_r":0.65,"wave_g":0.65,"wave_b":0.65,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26},"shapes":[{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"usedots":1,"thick":1},"init_eqs_str":"a.pad=0;a.av=0;a.q1=0;a.v=0;a.pi=0;a.tv=0;a.xv=0;a.x2=0;a.y2=0;a.q2=0;a.yv=0;","frame_eqs_str":"a.q1=3.1415;a.q2=0;","point_eqs_str":"a.pi=a.q1;a.pad=.001;a.q2+=1;a.v=a.q2;a.av+=div(a.q1,100);a.tv+=.001*a.bass;a.a=(.5+.5*Math.cos(6.3*a.pi*a.tv))*(1-a.sample);a.xv+=1e-7*(Math.floor(rand(100))-Math.floor(rand(100)));a.yv+=1e-7*(Math.floor(rand(100))-Math.floor(rand(100)));a.xv=.00001<Math.abs(below(a.xv,-a.pad))?-a.pad:a.xv;a.yv=.00001<Math.abs(below(a.yv,-a.pad))?-a.pad:a.yv;a.xv=.00001<Math.abs(above(a.xv,a.pad))?a.pad:a.xv;a.yv=.00001<Math.abs(above(a.yv,a.pad))?a.pad:a.yv;a.x2=.00001<Math.abs(below(a.x2,\n-.15))?1.15:a.x2;a.x2=.00001<Math.abs(above(a.x2,1.15))?-.15:a.x2;a.y2=.00001<Math.abs(below(a.y2,-.15))?1.15:a.y2;a.y2=.00001<Math.abs(above(a.y2,1.15))?-.15:a.y2;a.x2+=.1*a.xv;a.y2+=.1*a.yv;a.x=a.x2;a.y=a.y2;","init_eqs_eel":"","frame_eqs_eel":"q1=3.1415;\nq2=0;","point_eqs_eel":"pi=q1; pad=0.001;\nq2=q2+1;\nv=q2;\nav=av+q1/100;\ntv=tv+bass*.001;\na=(.5+cos(pi*6.3*tv)*.5)*(1-sample);\nxv=xv+(int(rand(100))-int(rand(100)))*.0000001;\nyv=yv+(int(rand(100))-int(rand(100)))*.0000001;\n xv=if(below(xv,-pad),-pad,xv); yv=if(below(yv,-pad),-pad,yv);\nxv=if(above(xv,pad),pad,xv); yv=if(above(yv,pad),pad,yv);\n//xv=if(below(x2,.15),-xv,xv); xv=if(above(x2,.85),-xv,xv); yv=if(below(y2,.15),-yv,yv); yv=if(above(y2,.85),-yv,yv);\nx2=if(below(x2,-.15),1.15,x2); x2=if(above(x2,1.15),-.15,x2);\ny2=if(below(y2,-.15),1.15,y2); y2=if(above(y2,1.15),-.15,y2);\n\n\nx2=x2+xv*.1; y2=y2+yv*.1;\n\nx=x2; y=y2;"},{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"","frame_eqs_str":"","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","pixel_eqs_eel":"","warp":"vec3 xlat_mutablecol;\nvec3 xlat_mutablecol_old;\nvec2 xlat_mutabled;\n shader_body { \n  vec3 ret_1;\n  xlat_mutabled = (2.0 * texsize.zw);\n  vec4 tmpvar_2;\n  tmpvar_2 = texture (sampler_main, uv);\n  xlat_mutablecol_old = tmpvar_2.xyz;\n  xlat_mutablecol.xy = (vec3(((\n    ((((texture (sampler_main, \n      (uv + (xlat_mutabled * vec2(-1.0, 0.0)))\n    ).y + texture (sampler_main, \n      (uv + (xlat_mutabled * vec2(1.0, 0.0)))\n    ).y) + texture (sampler_main, (uv + \n      (xlat_mutabled * vec2(0.0, -1.0))\n    )).y) + texture (sampler_main, (uv + (xlat_mutabled * vec2(0.0, 1.0)))).y) * 0.5)\n   - tmpvar_2.x) + (texture (sampler_pw_main, uv).z * 0.005))) * 0.998).xy;\n  xlat_mutablecol.z = (((\n    (texture (sampler_main, (uv + (xlat_mutabled * vec2(-1.0, 0.0)))).z + texture (sampler_main, (uv + (xlat_mutabled * vec2(1.0, 0.0)))).z)\n   + texture (sampler_main, \n    (uv + (xlat_mutabled * vec2(0.0, -1.0)))\n  ).z) + texture (sampler_main, (uv + \n    (xlat_mutabled * vec2(0.0, 1.0))\n  )).z) + tmpvar_2.z);\n  if ((xlat_mutablecol.z > 1.0)) {\n    xlat_mutablecol.z = 0.0;\n  };\n  vec3 tmpvar_3;\n  tmpvar_3.x = xlat_mutablecol_old.y;\n  tmpvar_3.y = xlat_mutablecol.x;\n  tmpvar_3.z = xlat_mutablecol.z;\n  ret_1 = tmpvar_3;\n  if ((rad > (aspect.y * 0.95))) {\n    ret_1 = vec3(1.0, 1.0, 1.0);\n  };\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = ret_1;\n  ret = tmpvar_4.xyz;\n }","comp":" shader_body { \n  float tmpvar_1;\n  tmpvar_1 = uv.x;\n  float tmpvar_2;\n  tmpvar_2 = uv.y;\n  vec2 tmpvar_3;\n  tmpvar_3.x = (uv.x + 2.0);\n  tmpvar_3.y = tmpvar_2;\n  vec2 tmpvar_4;\n  tmpvar_4.x = (uv.x - 2.0);\n  tmpvar_4.y = tmpvar_2;\n  vec2 tmpvar_5;\n  tmpvar_5.x = tmpvar_1;\n  tmpvar_5.y = (uv.y + 2.0);\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_1;\n  tmpvar_6.y = (uv.y - 2.0);\n  vec2 tmpvar_7;\n  tmpvar_7.x = (time * 20.0);\n  tmpvar_7.y = (time * 10.0);\n  vec2 tmpvar_8;\n  tmpvar_8.x = ((texture (sampler_main, (uv + \n    (texsize.zw * tmpvar_3)\n  )).x - texture (sampler_main, (uv + \n    (texsize.zw * tmpvar_4)\n  )).x) / 128.0);\n  tmpvar_8.y = ((texture (sampler_main, (uv + \n    (texsize.zw * tmpvar_5)\n  )).x - texture (sampler_main, (uv + \n    (texsize.zw * tmpvar_6)\n  )).x) / 128.0);\n  vec4 tmpvar_9;\n  tmpvar_9.w = 1.0;\n  tmpvar_9.xyz = texture (sampler_noise_hq, (((texsize.zw * tmpvar_7) + (uv * 0.2)) + ((17000.0 * texsize.zw) * tmpvar_8))).xxx;\n  ret = tmpvar_9.xyz;\n }","warp_hlsl":" float x, y;\n float2 d;\n float3 col_old, col;\n\n shader_body{\n  d=2*texsize.zw; x=uv.x, y=uv.y;\n  \n  col_old=GetPixel(uv);\n  col=\n  (GetPixel(uv+d*float2(-1,0)).y\n  +GetPixel(uv+d*float2(1,0)).y\n  +GetPixel(uv+d*float2(0,-1)).y\n  +GetPixel(uv+d*float2(0,1)).y)*.5-col_old.x\n  +tex2D(sampler_pw_main,uv).z*.005; // remove this line to see the old method, controls the length of the waves\n col*=.998;\n col.z=\n  (GetPixel(uv+d*float2(-1,0)).z\n  +GetPixel(uv+d*float2(1,0)).z\n  +GetPixel(uv+d*float2(0,-1)).z\n  +GetPixel(uv+d*float2(0,1)).z\n  +GetPixel(uv).z);\n \n if(col.z>1)col.z=0;\n ret=float3(col_old.y,col.x,col.z);\n \n if(rad>aspect.y*.95)ret=1;\n}","comp_hlsl":" float s1, s2, s3, s4, ioffs, x, y;\n float2 d;\n\n shader_body{\n  ioffs=2; // higher values = smoother results for distortion\n  x=uv.x, y=uv.y;\n  d=texsize.zw;\n \n  s1=GetPixel(uv+d*float2(x+ioffs,y)).x;\n s2=GetPixel(uv+d*float2(x-ioffs,y)).x;\n s3=GetPixel(uv+d*float2(x,y+ioffs)).x;\n s4=GetPixel(uv+d*float2(x,y-ioffs)).x;\n\n // distorted noise\n ret=tex2D(sampler_noise_hq,d*float2(time*20,time*10)+uv*.2+17000*d*float2( (s1-s2)/(ioffs*64), (s3-s4)/(ioffs*64) ) ).x;\n\n // distorted, blurred drop shadow to simulate refracted caustics, slow\n //ret=float3(1.5,1.85,2.5)*(1-GetBlur1(d*float2(0,-30)+uv+17000*d*float2( (s1-s2)/(ioffs*64), (s3-s4)/(ioffs*64) ) ).x);\n\n // layer 3, in case you're interested\n //ret=lum(tex2d(sampler_main, uv).z);\n}"}