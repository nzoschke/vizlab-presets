{"version":2,"baseVals":{"rating":5,"gammaadj":1,"decay":0.925,"echo_zoom":1.007,"echo_alpha":0.5,"echo_orient":1,"wave_mode":3,"additivewave":1,"wave_brighten":0,"brighten":1,"wave_a":100,"wave_scale":0.241,"wave_smoothing":0,"wave_mystery":0.684,"modwavealphastart":0.5,"modwavealphaend":1,"warpanimspeed":5.996,"warpscale":1.331,"fshader":1,"zoom":0.99822,"warp":0.4241,"wave_r":0.556,"wave_g":0.791,"wave_b":0.26,"wave_x":0.267,"wave_y":0.192,"ob_size":0,"ob_r":0.5,"ob_g":0.5,"ob_b":0.5,"ob_a":1,"ib_size":0,"ib_r":0.5,"ib_g":0.5,"ib_b":0.5,"mv_x":3,"mv_y":48,"mv_dx":0.479,"mv_dy":0.439,"mv_l":5,"mv_r":0.833,"mv_g":0.835,"mv_b":0.745,"mv_a":0.204},"shapes":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.ib_=0;a.bass_residual=0;a.ob_bob_b=0;a.old_treb_flop=0;a.bass_flop=0;a.q6=0;a.q1=0;a.q5=0;a.treb_flop=0;a.bass_thresh=0;a.old_bass_flop=0;a.treb_thresh=0;a.pulse=0;a.bass_changed=0;a.mid_thresh=0;a.q4=0;a.mid_changed=0;a.entropy=0;a.c2=0;a.old_mid_flop=0;a.mid_residual=0;a.checkx=0;a.c3=0;a.treb_residual=0;a.chaos=0;a.mid_flop=0;a.q2=0;a.treb_changed=0;a.q3=0;a.radix=0;a.q7=0;a.bdecay=0;a.c1=0;a.checky=0;a.q8=0;","frame_eqs_str":"a['old_bass_flop']=a['bass_flop']; a['old_treb_flop']=a['treb_flop']; a['old_mid_flop']=a['mid_flop']; a['chaos']=(0.9+(0.1*Math.sin(a['pulse']))); a['bass_thresh']=((above(a['bass_att'], a['bass_thresh'])*2)+((1-above(a['bass_att'], a['bass_thresh']))*(((a['bass_thresh']-1.6)*a['chaos'])+1.6))); a['bass_flop']=Math.abs((a['bass_flop']-equal(a['bass_thresh'], 2))); a['treb_thresh']=((above(a['treb_att'], a['treb_thresh'])*2)+((1-above(a['treb_att'], a['treb_thresh']))*(((a['treb_thresh']-1.6)*a['chaos'])+1.6))); a['treb_flop']=Math.abs((a['treb_flop']-equal(a['treb_thresh'], 2))); a['mid_thresh']=((above(a['mid_att'], a['mid_thresh'])*2)+((1-above(a['mid_att'], a['mid_thresh']))*(((a['mid_thresh']-1.6)*a['chaos'])+1.6))); a['mid_flop']=Math.abs((a['mid_flop']-equal(a['mid_thresh'], 2))); a['bass_changed']=bnot(equal(a['old_bass_flop'], a['bass_flop'])); a['mid_changed']=bnot(equal(a['old_mid_flop'], a['mid_flop'])); a['treb_changed']=bnot(equal(a['old_treb_flop'], a['treb_flop'])); a['bass_residual']=((a['bass_changed']*Math.sin((a['pulse']*3)))+(bnot(a['bass_changed'])*a['bass_residual'])); a['treb_residual']=((a['treb_changed']*Math.sin((a['pulse']*3)))+(bnot(a['treb_changed'])*a['treb_residual'])); a['mid_residual']=((a['mid_changed']*Math.sin((a['pulse']*3)))+(bnot(a['mid_changed'])*a['mid_residual'])); a['pulse']=((Math.abs(above(Math.abs(a['pulse']), 3.14))>0.00001)?(-3.14):((a['pulse']+(((a['bass_thresh']+a['mid_thresh'])+a['treb_thresh'])*0.007)))); a['entropy']=((Math.abs(((a['bass_changed']*a['mid_changed'])*a['treb_changed']))>0.00001)?(((((1+a['bass_flop'])+a['treb_flop'])+a['mid_flop'])*(1+rand(3)))):(a['entropy'])); a['q1']=a['mid_residual']; a['q2']=a['bass_residual']; a['q3']=a['treb_residual']; a['q4']=Math.sin(a['pulse']); a['q5']=Math.cos((a['pulse']*(0.5+(0.1*a['entropy'])))); a['q6']=Math.sin((a['pulse']*(0.5+pow(0.25, a['entropy'])))); a['q7']=(((((above(a['q1'], 0)+above(a['q2'], 0))+above(a['q3'], 0))+(above(a['q3'], 0)*a['treb_flop']))+(above(a['q2'], 0)*a['bass_flop']))+(above(a['q1'], 0)*a['mid_flop'])); a['q8']=a['entropy']; a['wave_r']=(a['wave_r']+(a['wave_r']*a['q1'])); a['wave_b']=(a['wave_b']+(a['wave_b']*a['q2'])); a['wave_g']=(a['wave_g']+(a['wave_g']*a['q3'])); a['ob_r']=(a['ob_r']+(a['ob_r']*Math.sin((a['q1']+(a['q2']*2.14))))); (a['ob_bob_b']+(a['ob_b']*Math.sin((a['q2']+(a['q3']*2.14))))) a['ob_g']=(a['ob_g']+(a['ob_g']*Math.sin((a['q3']+(a['q1']*2.14))))); a['ib_r']=(a['ib_r']+(a['ib_r']*Math.cos((a['q5']+(a['q1']*2.14))))); a['ib_b']=(a['ib_b']+(a['ib_']*Math.cos((a['q5']+(a['q2']*2.14))))); a['ib_g']=(a['ib_g']+(a['ib_g']*Math.cos((a['q5']+(a['q3']*2.14))))); a['ob_a']=(0.25+(0.25*Math.sin((a['q2']+(a['q3']*2.14))))); a['ib_a']=(0.25+(0.25*Math.sin(((a['q2']*2.14)+a['q3'])))); a['ob_size']=(0.1+(0.1*Math.sin(((a['q3']*3)+a['q1'])))); a['ib_size']=(0.1+(0.1*Math.sin(((a['q1']*3)+a['q3'])))); a['wave_mystery']=(0.5*a['q6']); a['warp']=0; a['wave_mode']=mod(a['q8'],7); a['bdecay']=(0.99+(a['q8']*0.0005));","pixel_eqs_str":"a.c1=a.x*a.q1;a.c2=a.y*a.q2;a.c3=a.rad*a.q3;a.radix=.00001<Math.abs(above(a.q5,0))?Math.min(a.c1,a.c2):Math.max(a.c1,a.c2);a.radix=.00001<Math.abs(above(a.q6,0))?Math.min(a.radix,a.c3):Math.max(a.radix,a.c3);a.radix=.00001<Math.abs(above(a.q4,0))?Math.min(a.radix*a.q1,a.radix*a.q2):Math.max(a.radix*a.q1,a.radix*a.q3);a.rot=Math.cos(a.radix*a.q7*1.386+a.rad*a.q8*above(a.q7,4))*(.75+.25*a.q4);a.zoom=.00001<Math.abs(below(Math.abs(a.q1),.5))?a.zoom:.00001<Math.abs(below(Math.abs(a.q2),\n.5))?1+.1*Math.sin(3.14*a.radix):1+.1*Math.sin(a.radix*a.q8*1.618);a.checkx=bor(above(Math.abs(a.q1),a.x)*below(Math.abs(a.q2),a.x),above(Math.abs(a.q2),a.x)*below(Math.abs(a.q1),a.x));a.checky=bor(above(Math.abs(a.q1),a.y)*below(Math.abs(a.q2),a.y),above(Math.abs(a.q2),a.y)*below(Math.abs(a.q1),a.y));a.sx-=.00001<Math.abs(bnot(mod(a.q7,2)))?.00001<Math.abs(bnot(a.checky))?.3*a.q3:.3*a.q2*Math.sin(a.radix):.1*a.q4*above(a.q7,3);a.sy-=.00001<Math.abs(bnot(mod(a.q7,2)))?.00001<Math.abs(bnot(a.checkx))?\n.3*a.q2:.3*a.q3*Math.sin(a.radix):.1*a.q1*above(a.q7,3);","init_eqs_eel":"","frame_eqs_eel":"old_bass_flop=bass_flop;\nold_treb_flop=treb_flop;\nold_mid_flop=mid_flop;\nchaos=.9+.1*sin(pulse);\nbass_thresh = above(bass_att,bass_thresh)*2 + (1-above(bass_att,bass_thresh))*((bass_thresh-1.6)*chaos+1.6);\nbass_flop=abs(bass_flop-equal(bass_thresh,2));\ntreb_thresh=above(treb_att,treb_thresh)*2 + (1-above(treb_att,treb_thresh))*((treb_thresh-1.6)*chaos+1.6);\ntreb_flop=abs(treb_flop-equal(treb_thresh,2));\nmid_thresh=above(mid_att,mid_thresh)*2 + (1-above(mid_att,mid_thresh))*((mid_thresh-1.6)*chaos+1.6);\nmid_flop=abs(mid_flop-equal(mid_thresh,2));\nbass_changed=bnot(equal(old_bass_flop,bass_flop));\nmid_changed=bnot(equal(old_mid_flop,mid_flop));\ntreb_changed=bnot(equal(old_treb_flop,treb_flop));\nbass_residual = bass_changed*sin(pulse*3) + bnot(bass_changed)*bass_residual;\ntreb_residual = treb_changed*sin(pulse*3) + bnot(treb_changed)*treb_residual;\nmid_residual = mid_changed*sin(pulse*3) + bnot(mid_changed)*mid_residual;\npulse=if(above(abs(pulse),3.14),-3.14,pulse+(bass_thresh+mid_thresh+treb_thresh)*.007);\nentropy=if(bass_changed*mid_changed*treb_changed,(1+bass_flop+treb_flop+mid_flop)*(1+rand(3)),entropy);\nq1=mid_residual;\nq2=bass_residual;\nq3=treb_residual;\nq4=sin(pulse);\nq5=cos(pulse*(.5+.1*entropy));\nq6=sin(pulse*(.5+pow(.25,entropy)));\nq7=above(q1,0)+above(q2,0)+above(q3,0)+above(q3,0)*treb_flop+above(q2,0)*bass_flop+above(q1,0)*mid_flop;\nq8=entropy;\nwave_r=wave_r+wave_r*q1;\nwave_b=wave_b+wave_b*q2;\nwave_g=wave_g+wave_g*q3;\nob_r=ob_r+ob_r*sin(q1+q2*2.14);\nob_bob_b+ob_b*sin(q2+q3*2.14);\nob_g=ob_g+ob_g*sin(q3+q1*2.14);\nib_r=ib_r+ib_r*cos(q5+q1*2.14);\nib_b=ib_b+ib_*cos(q5+q2*2.14);\nib_g=ib_g+ib_g*cos(q5+q3*2.14);\nob_a=.25+.25*sin(q2+q3*2.14);\nib_a=.25+.25*sin(q2*2.14+q3);\nob_size=.1+.1*sin(q3*3+q1);\nib_size=.1+.1*sin(q1*3+q3);\nwave_mystery=.5*q6;\nwarp=0;\nwave_mode=q8%7;\nbdecay=.99+q8*.0005;","pixel_eqs_eel":"c1=x*q1;\nc2=y*q2;\nc3=rad*q3;\nradix=if(above(q5,0),min(c1,c2),max(c1,c2));\nradix=if(above(q6,0),min(radix,c3),max(radix,c3));\nradix=if(above(q4,0),min(radix*q1,radix*q2),max(radix*q1,radix*q3));\nrot=cos(radix*q7*1.386+rad*q8*above(q7,4))*(.75+.25*q4);\nzoom=if(below(abs(q1),.5),zoom,if(below(abs(q2),.5),1+.1*sin(3.14*radix),1+.1*sin(radix*q8*1.618)));\ncheckx=bor(above(abs(q1),x)*below(abs(q2),x),above(abs(q2),x)*below(abs(q1),x));\nchecky=bor(above(abs(q1),y)*below(abs(q2),y),above(abs(q2),y)*below(abs(q1),y));\nsx=sx-if(bnot(q7%2),if(bnot(checky),q3*.3,.3*q2*sin(radix)),.1*q4*above(q7,3));\nsy=sy-if(bnot(q7%2),if(bnot(checkx),q2*.3,.3*q3*sin(radix)),.1*q1*above(q7,3));","warp":" shader_body { \n  vec3 ret_1;\n  vec4 tmpvar_2;\n  tmpvar_2 = texture (sampler_main, uv);\n  ret_1 = (tmpvar_2.xyz + ((tmpvar_2.xyz - \n    ((texture (sampler_blur1, uv).xyz * scale1) + bias1)\n  ) * 0.5));\n  ret_1 = (ret_1 * 0.9);\n  ret_1 = (ret_1 + ((\n    ((texture (sampler_noise_lq, ((\n      (uv_orig * texsize.xy)\n     * \n      (texsize_noise_lq.zw * 0.4)\n    ) + rand_frame.xy)).xyz - 0.5) / 256.0)\n   * 12.0) * clamp (\n    (treb_att - 1.0)\n  , 0.0, 1.0)));\n  vec3 tmpvar_3;\n  tmpvar_3 = mix (ret_1, vec3(dot (ret_1, vec3(0.32, 0.49, 0.29))), vec3(0.08, 0.08, 0.08));\n  ret_1 = tmpvar_3;\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = tmpvar_3;\n  ret = tmpvar_4.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  ret_1 = ((texture (sampler_main, uv).xyz * 1.5) - 0.1);\n  ret_1.y = (ret_1 * 0.7).y;\n  ret_1.x = (((texture (sampler_blur1, uv).xyz * scale1) + bias1).x - 0.03);\n  ret_1.z = (((\n    (texture (sampler_blur2, uv).xyz * scale2)\n   + bias2).z * 1.5) - 0.05);\n  ret_1 = (ret_1 * 2.3);\n  vec4 tmpvar_2;\n  tmpvar_2.w = 1.0;\n  tmpvar_2.xyz = ret_1;\n  ret = tmpvar_2.xyz;\n }","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_main, uv ).xyz;\n\n    // take the difference between the crisp and blurred images,\n    // then add it back into the image.  Creates spots and stripes over time,\n    // basically by breaking up big blocks of white color.\n    ret += (ret - GetBlur1(uv))*0.5;\n    ret *= 0.9;\n\n   // add noise:\n   float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw * 0.4 + rand_frame.xy;\n   ret += (tex2D(sampler_noise_lq, dither_uv).xyz-0.5)/256.0 * 12 * saturate(treb_att-1);\n\n   // desaturate over time, to keep the globs white\n   ret = lerp(ret, lum(ret), 0.08);\n}","comp_hlsl":"shader_body\n{\n    ret = tex2D(sampler_main, uv).xyz;\n    ret = ret*1.5 - 0.1;\n\n    float4 g;\n    float3 d = float3(texsize.zw * 4, 0);\n    g.x = lum(GetBlur1(uv + d.xz));\n    g.y = lum(GetBlur1(uv - d.xz));\n    g.z = lum(GetBlur1(uv + d.zy));\n    g.w = lum(GetBlur1(uv - d.zy));\n    \n    ret *= 0.7;\n    ret.x += saturate(g.x-g.y)*5;\n    ret.z += saturate(g.y-g.x)*5;\n    //ret.xy += (g.xz-g.yw)*3;\n\nret.x = GetBlur1(uv).x - 0.03;\nret.z = GetBlur2(uv).z*1.5 - 0.05;\nret *= 2.3;\n\n}\n\n"}