{"version":2,"baseVals":{"rating":5,"gammaadj":1,"decay":1,"echo_zoom":1,"echo_alpha":0.5,"wave_mode":7,"additivewave":1,"modwavealphabyvolume":1,"wave_brighten":0,"wave_a":0.001,"wave_scale":1.286,"wave_smoothing":0.63,"modwavealphastart":0.71,"modwavealphaend":1.3,"warpscale":1.331,"zoom":13.29089,"dx":-0.28,"dy":-0.32,"warp":0.00909,"wave_r":0.65,"wave_g":0.65,"wave_b":0.65,"ob_size":0,"ob_a":1,"ib_size":0,"ib_r":1,"ib_g":0,"ib_b":0,"ib_a":1,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"textured":1,"rad":5.3898,"tex_ang":1.19381,"tex_zoom":0.18923,"g":0.97,"b":1,"a":0.94,"r2":1,"b2":1,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"textured":1,"rad":3.99882,"tex_zoom":0.25005,"g":1,"b":1,"a":0.6,"r2":1,"b2":1,"a2":0.6,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":18,"textured":1,"num_inst":10,"x":0.463,"rad":1.60089,"tex_zoom":0.67634,"g":1,"b":1,"r2":0.7,"g2":0.8,"b2":0.8,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"enabled":1,"sides":16,"num_inst":353,"x":0.503,"rad":0.0376,"tex_zoom":1.11234,"g":1,"b":1,"g2":0,"border_a":0.06},"init_eqs_str":"a.my_z=0;a.d=0;a.y3=0;a.z2=0;a.y1=0;a.w=0;a.w2=0;a.x1=0;a.zoom=0;a.p=0;a.q1=0;a.z3=0;a.w3=0;a.my_x=0;a.x3=0;a.my_y=0;a.q10=0;a.p2=0;a.w1=0;a.x2=0;a.l=0;a.p1=0;a.y2=0;a.q2=0;a.z1=0;a.q3=0;a.sample=0;","frame_eqs_str":"a.sample=div(a.instance,a.num_inst);a.rad=.05+.04*Math.sin(a.sample);a.q10=250*a.sample;a.my_x=-.22*Math.cos(a.q10)-1.28*Math.sin(a.q10)-.44*Math.cos(3*a.q10)-.78*Math.sin(3*a.q10);a.my_y=-.1*Math.cos(2*a.q10)-.27*Math.sin(2*a.q10)+.38*Math.cos(4*a.q10)+.46*Math.sin(4*a.q10);a.my_z=.7*Math.cos(3*a.q10)-.4*Math.sin(3*a.q10);a.d=.2;a.zoom=1;a.w3=a.q1;a.w2=a.q2;a.w1=a.q3;a.x1=Math.cos(a.w1)*a.my_x+Math.sin(a.w1)*a.my_y;a.y1=-Math.sin(a.w1)*a.my_x+Math.cos(a.w1)*a.my_y;a.z1=a.my_z;\na.x2=Math.cos(a.w2)*a.x1+Math.sin(a.w2)*a.z1;a.z2=-Math.sin(a.w2)*a.x1+Math.cos(a.w2)*a.z1;a.y2=a.y1;a.y3=Math.cos(a.w3)*a.y2+Math.sin(a.w3)*a.z2;a.z3=-Math.sin(a.w3)*a.y2+Math.cos(a.w3)*a.z2;a.x3=a.x2;a.l=sqrt(a.x3*a.x3+a.y3*a.y3);a.w=Math.atan2(a.x3,a.y3);a.p=Math.tan(Math.asin(1)+Math.atan2(a.d+a.z3,a.l));a.d=sqrt(a.x3*a.x3+a.y3*a.y3+(a.z3+a.d)*(a.z3+a.d));a.my_x=a.zoom*Math.sin(a.w)*a.p;a.my_y=a.zoom*Math.cos(a.w)*a.p;a.p1=.2*Math.sin(50*a.sample);a.p2=.2*Math.sin(80*a.sample);a.x=.5+a.my_x*a.p1;\na.y=.5+a.my_y*a.p2;a.r=.4*Math.sin(80*a.sample);a.b=.8*Math.sin(66*a.sample);a.g=.6*Math.sin(120*a.sample);","init_eqs_eel":"","frame_eqs_eel":"sample=instance/num_inst;\nrad=.05+.04*sin(sample);\n\n/////  Knot\n\nq10=250*sample;\nmy_x = -.22*cos(q10)-1.28*sin(q10)-.44*cos(3*q10)-.78*sin(3*q10);\nmy_y= -.1*cos(2*q10)-.27*sin(2*q10)+.38*cos(4*q10)+.46*sin(4*q10);\nmy_z=.7*cos(3*q10)-.4*sin(3*q10);\n\n\n/////// rotations... by flexi\n\nd = .2; \nzoom = 1;\n\nw3 = q1;\nw2 = q2;\nw1 = q3;\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\nl = sqrt(x3*x3 + y3*y3);\nw = atan2(x3,y3);\np = tan(asin(1) + atan2(d+z3,l));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nmy_x = zoom*sin(w)*p;\nmy_y = zoom*cos(w)*p;\n\np1 = .2*sin(sample*50);\np2 = .2*sin(sample*80);\n\nx = .5+my_x*p1;\ny = .5+my_y*p2;\n\nr = .4*sin(sample*80);\nb = .8*sin(sample*66);\ng = .6*sin(sample*120);"}],"waves":[{"baseVals":{"spectrum":1,"additive":1,"smoothing":0,"r":0.4,"g":0.4,"b":0.4,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"spectrum":1,"smoothing":0,"r":0,"g":0,"b":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"thick":1,"r":0,"g":0,"b":0,"a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.c_inv_i=0;a.translation_x=0;a.a_i=0;a.c_r=0;a.a_r=0;a.iangle=0;a.scale=0;a.q6=0;a.ac_i=0;a.itranslation_u=0;a.q1=0;a.itranslation_v=0;a.q5=0;a.c_inv_r=0;a.d_i=0;a.angle=0;a.mu_i=0;a.bcad_r=0;a.iscale=0;a.q4=0;a.b_r=0;a.mu_r=0;a.bcad_i=0;a.c_i=0;a.q2=0;a.ac_r=0;a.translation_y=0;a.q3=0;a.b_i=0;a.q7=0;a.d_r=0;a.q8=0;a.zoom=1;a.xpos=0;a.ypos=0;","frame_eqs_str":"a.scale=1;a.angle=.2*a.time;a.translation_x=0;a.translation_y=.1;a.iscale=1;a.iangle=.2;a.itranslation_u=0;a.itranslation_v=0;a.a_r=Math.cos(a.angle)*a.scale;a.a_i=Math.sin(a.angle)*a.scale;a.b_r=a.translation_x;a.b_i=a.translation_y;a.c_r=-Math.cos(a.iangle)*a.iscale;a.c_i=-Math.sin(a.iangle)*a.iscale;a.d_r=a.itranslation_u;a.d_i=a.itranslation_v;a.c_inv_r=div(a.c_r,a.c_r*a.c_r+a.c_i*a.c_i);a.c_inv_i=div(a.c_i,a.c_r*a.c_r+a.c_i*a.c_i);a.ac_r=a.a_r*a.c_inv_r-a.a_i*a.c_inv_i;\na.ac_i=a.a_r*a.c_inv_i-a.a_i*a.c_inv_r;a.bcad_r=a.b_r*a.c_r-a.b_i*a.c_i-(a.a_r*a.d_r-a.a_i*a.d_i);a.bcad_i=a.b_r*a.c_i-a.b_i*a.c_r-(a.a_r*a.d_i-a.a_i*a.d_r);a.mu_r=a.bcad_r*a.c_inv_r-a.bcad_i*a.c_inv_i;a.mu_i=a.bcad_r*a.c_inv_i-a.bcad_i*a.c_inv_r;a.q1=a.ac_r;a.q2=a.ac_i;a.q3=a.mu_r;a.q4=a.mu_i;a.q5=a.c_r;a.q6=a.c_i;a.q7=a.d_r;a.q8=a.d_i;a.monitor=a.bcad_r;","pixel_eqs_str":"","init_eqs_eel":"zoom=1;\nxpos=0;\nypos=0;","frame_eqs_eel":"//before inversion\nscale = 1;\nangle = time*.2;\ntranslation_x = 0;\ntranslation_y = 0.1;\n\n//complex inverted\niscale = 1;\niangle = 0.2;\nitranslation_u = 0;\nitranslation_v = 0;\n\n\n// the mï¿½bius transformation\n// z -> (az+b)/(cz-d); where a,b,c,d are complex numbers and z will be the uv-vector\n// (az+b)/(cz-d) = a/c + mu/(cz+d), with mu = (bc-ad)/c\n// so a/c and mu can be calculated outside of the shader\n\na_r = cos(angle)*scale;\na_i = sin(angle)*scale;\nb_r = translation_x;\nb_i = translation_y;\n\nc_r = -cos(iangle)*iscale;\nc_i = -sin(iangle)*iscale;\nd_r = itranslation_u;\nd_i = itranslation_v;\n\n// c^(-1)\nc_inv_r = c_r/(c_r*c_r+c_i*c_i);\nc_inv_i = c_i/(c_r*c_r+c_i*c_i);\n\n// a*c^(-1)\nac_r = (a_r*c_inv_r - a_i*c_inv_i);\nac_i = (a_r*c_inv_i - a_i*c_inv_r);\n\n// (bc-ad)\nbcad_r = (b_r*c_r - b_i*c_i)-(a_r*d_r-a_i*d_i);\nbcad_i = (b_r*c_i - b_i*c_r)-(a_r*d_i-a_i*d_r);\n\n// mu*c^(-1)\nmu_r = bcad_r*c_inv_r - bcad_i*c_inv_i;\nmu_i = bcad_r*c_inv_i - bcad_i*c_inv_r;\n\nq1 = ac_r;\nq2 = ac_i;\nq3 = mu_r;\nq4 = mu_i;\n\nq5 = c_r;\nq6 = c_i;\nq7 = d_r;\nq8 = d_i;\n\nmonitor = bcad_r;","pixel_eqs_eel":"","warp":" shader_body { \n  vec2 tmpvar_1;\n  tmpvar_1 = (((uv_orig * texsize.xy) * (texsize_noise_lq.zw * 1.5)) + rand_frame.xy);\n  vec4 tmpvar_2;\n  tmpvar_2.w = 1.0;\n  tmpvar_2.xyz = ((texture (sampler_main, (\n    mix (uv_orig, uv, vec2(((dot (texture (sampler_main, \n      mix (uv_orig, uv, vec2(4.0, 4.0))\n    ).xyz, vec3(0.32, 0.49, 0.29)) - dot (\n      ((texture (sampler_blur2, mix (uv_orig, uv, vec2(-12.0, -12.0))).xyz * scale2) + bias2)\n    , vec3(0.32, 0.49, 0.29))) * 12.0)))\n   + \n    (((texture (sampler_noise_lq, tmpvar_1) - 0.5).xy * texsize.zw) * 0.5)\n  )).xyz + (\n    (texture (sampler_noise_lq, tmpvar_1) - 0.5)\n   * 0.006).xyz) + -0.0006);\n  ret = tmpvar_2.xyz;\n }","comp":"vec3 xlat_mutableblur;\nvec3 xlat_mutableret1;\nvec2 xlat_mutableuv2;\nvec2 xlat_mutableuv3;\n shader_body { \n  vec2 uv_1;\n  float inten_2;\n  float dist_3;\n  float ang2_4;\n  uv_1 = (uv - 0.5);\n  uv_1 = (uv_1 * aspect.xy);\n  float tmpvar_5;\n  tmpvar_5 = cos(q30);\n  float tmpvar_6;\n  tmpvar_6 = sin(q30);\n  xlat_mutableuv2.x = ((uv_1.x * tmpvar_5) - (uv_1.y * tmpvar_6));\n  xlat_mutableuv2.y = ((uv_1.x * tmpvar_6) + (uv_1.y * tmpvar_5));\n  xlat_mutableuv2 = (xlat_mutableuv2 * aspect.yx);\n  dist_3 = (1.0 - fract(q29));\n  inten_2 = ((4.0 * dist_3) * (1.0 - (dist_3 * dist_3)));\n  xlat_mutableuv3 = (((3.0 * xlat_mutableuv2) * dist_3) + 0.5);\n  xlat_mutableblur = (((texture (sampler_blur1, \n    fract(xlat_mutableuv3)\n  ).xyz * scale1) + bias1) * vec3(0.8, 0.9, 1.0));\n  xlat_mutableret1 = max (vec3(0.0, 0.0, 0.0), ((texture (sampler_main, xlat_mutableuv3).xyz + xlat_mutableblur) * inten_2));\n  ang2_4 = (2.093333 + q30);\n  float tmpvar_7;\n  tmpvar_7 = cos(ang2_4);\n  float tmpvar_8;\n  tmpvar_8 = sin(ang2_4);\n  xlat_mutableuv2.x = ((uv_1.x * tmpvar_7) - (uv_1.y * tmpvar_8));\n  xlat_mutableuv2.y = ((uv_1.x * tmpvar_8) + (uv_1.y * tmpvar_7));\n  xlat_mutableuv2 = (xlat_mutableuv2 * aspect.yx);\n  dist_3 = (1.0 - fract((0.3333333 + q29)));\n  inten_2 = ((4.0 * dist_3) * (1.0 - (dist_3 * dist_3)));\n  xlat_mutableuv3 = (((3.0 * xlat_mutableuv2) * dist_3) + 0.5);\n  xlat_mutableblur = (((texture (sampler_blur1, \n    fract(xlat_mutableuv3)\n  ).xyz * scale1) + bias1) * vec3(0.8, 0.9, 1.0));\n  xlat_mutableret1 = max (xlat_mutableret1, ((texture (sampler_main, xlat_mutableuv3).xyz + xlat_mutableblur) * inten_2));\n  ang2_4 = (4.186667 + q30);\n  float tmpvar_9;\n  tmpvar_9 = cos(ang2_4);\n  float tmpvar_10;\n  tmpvar_10 = sin(ang2_4);\n  xlat_mutableuv2.x = ((uv_1.x * tmpvar_9) - (uv_1.y * tmpvar_10));\n  xlat_mutableuv2.y = ((uv_1.x * tmpvar_10) + (uv_1.y * tmpvar_9));\n  xlat_mutableuv2 = (xlat_mutableuv2 * aspect.yx);\n  dist_3 = (1.0 - fract((0.6666667 + q29)));\n  inten_2 = ((4.0 * dist_3) * (1.0 - (dist_3 * dist_3)));\n  xlat_mutableuv3 = (((3.0 * xlat_mutableuv2) * dist_3) + 0.5);\n  xlat_mutableblur = (((texture (sampler_blur1, \n    fract(xlat_mutableuv3)\n  ).xyz * scale1) + bias1) * vec3(0.8, 0.9, 1.0));\n  xlat_mutableret1 = max (xlat_mutableret1, ((texture (sampler_main, xlat_mutableuv3).xyz + xlat_mutableblur) * inten_2));\n  ang2_4 = (6.28 + q30);\n  float tmpvar_11;\n  tmpvar_11 = cos(ang2_4);\n  float tmpvar_12;\n  tmpvar_12 = sin(ang2_4);\n  xlat_mutableuv2.x = ((uv_1.x * tmpvar_11) - (uv_1.y * tmpvar_12));\n  xlat_mutableuv2.y = ((uv_1.x * tmpvar_12) + (uv_1.y * tmpvar_11));\n  xlat_mutableuv2 = (xlat_mutableuv2 * aspect.yx);\n  dist_3 = (1.0 - fract((1.0 + q29)));\n  inten_2 = ((4.0 * dist_3) * (1.0 - (dist_3 * dist_3)));\n  xlat_mutableuv3 = (((3.0 * xlat_mutableuv2) * dist_3) + 0.5);\n  xlat_mutableblur = (((texture (sampler_blur1, \n    fract(xlat_mutableuv3)\n  ).xyz * scale1) + bias1) * vec3(0.8, 0.9, 1.0));\n  xlat_mutableret1 = max (xlat_mutableret1, ((texture (sampler_main, xlat_mutableuv3).xyz + xlat_mutableblur) * inten_2));\n  vec4 tmpvar_13;\n  tmpvar_13.w = 1.0;\n  tmpvar_13.xyz = xlat_mutableret1;\n  ret = tmpvar_13.xyz;\n }","warp_hlsl":"shader_body\n{\n\n\nfloat error     = 0.5;        // maximum random pixel offset\nfloat diffusion = 0.006;      // dither strength\nfloat fadeout   = -0.0006;    // may be minor 1/256 due to the error diffusion dither;\n\nfloat2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw*1.5 + rand_frame.xy;\nfloat magic = lum(GetPixel(lerp(uv_orig,uv, 4))) - lum(GetBlur2(lerp(uv_orig,uv,-12)));\nuv = lerp(uv_orig,uv, magic*12 ) + (tex2D(sampler_noise_lq, dither_uv)-0.5)*texsize.zw*error;\nret = GetPixel(uv)+(tex2D(sampler_noise_lq, dither_uv)-0.5)*diffusion + fadeout;\n\n}","comp_hlsl":"float3 ret1, neu, crisp, blur;\nfloat2 uv2, uv3;\n\nshader_body\n{\nfloat ang2, c, s;\nuv -= 0.5;\nuv *= aspect.xy;    \n\nfloat2 tmp = uv;\nfloat dist = 1;\nfloat inten = 1;\nfloat mask = 0;\nret1 = 0;\nint anz = 3;\nfloat n = 0;\nfloat t_rel = q29;\nwhile (n <= anz) {\n    ang2 = 6.28*n/anz+q30;\n    c = cos(ang2);\n    s = sin(ang2);\n    uv2.x =  uv.x*c - uv.y*s;\n    uv2.y =  uv.x*s + uv.y*c;\n    uv2*= aspect.yx;\n\n    dist = 1-frac(n/anz+t_rel); //evtl sqrt !\n\n    inten =  4*dist*(1-dist*dist);\n    uv3 = 3*uv2*dist + 0.5+.0*float2(q5,q6);\n    crisp = GetPixel(uv3);\n    blur = GetBlur1(frac(uv3)) * float3 (.8,.9,1);\n    ret1 = max(ret1,(crisp+blur)*inten);\nn++;\n}\n\n\nfloat3 ret1 = ret1 ;\n//ret1 = GetPixel(.5+uv_orig*aspect.yx*1.2);\n\n\nret = ret1;\n\n}"}