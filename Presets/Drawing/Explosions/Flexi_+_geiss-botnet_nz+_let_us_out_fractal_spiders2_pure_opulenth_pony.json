{"version":2,"baseVals":{"rating":5,"gammaadj":1,"wave_thick":1,"wrap":0,"wave_a":0.004,"wave_scale":9.731,"wave_smoothing":0,"wave_mystery":1,"modwavealphastart":1,"modwavealphaend":1,"warpanimspeed":0.442,"warpscale":7.315,"zoomexp":1.50374,"warp":0.08563,"wave_y":0.04,"ob_size":0,"ob_g":1,"ob_a":1,"ib_size":0,"ib_r":1,"ib_g":0,"ib_b":0.75,"ib_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_b":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"enabled":1,"num_inst":1024,"x":0.38,"y":0.28,"rad":0.03646,"tex_zoom":1.54929,"r":0,"g2":0,"a2":1,"border_a":0},"init_eqs_str":"a.i=0;a.x1=0;a.y1=0;a.zoom=0;a.q2=0;a.q6=0;","frame_eqs_str":"a.i=2*(a.instance+3072);a.x1=a.gmegabuf[Math.floor(a.i)];a.y1=a.gmegabuf[Math.floor(a.i+1)];a.zoom=a.q2;a.rad*=.1;a.y=.5+a.zoom*a.x1;a.x=.5+div(a.zoom*a.y1,a.q6);a.x=(Math.floor(a.x)-a.x+mod(a.x,2))*pow(-1,1+Math.floor(a.x));a.y=(Math.floor(a.y)-a.y+mod(a.y,2))*pow(-1,1+Math.floor(a.y));","init_eqs_eel":"","frame_eqs_eel":"i=2*(instance+3072);    \n\nx1=gmegabuf(i);   y1=gmegabuf(i+1);\n\nzoom=q2;\n\nrad=.1*rad;\ny= .5+zoom*x1;      \nx= .5+zoom*y1/q6;\n\nx= (int(x)-x+x%2)*pow(-1,1+int(x));\ny= (int(y)-y+y%2)*pow(-1,1+int(y));"},{"baseVals":{"enabled":1,"sides":12,"num_inst":92,"x":0.8,"rad":0.02705,"ang":1.5708,"tex_ang":1.25664,"tex_zoom":3.07268,"g":1,"b":1,"g2":0,"border_g":0,"border_b":0,"border_a":0},"init_eqs_str":"a.xang=0;a.ampl=0;a.fov=0;a.t1=0;a.yang=0;a.my=0;a.oz=0;a.k1=0;a.t_rel=0;a.k2=0;a.mz=0;a.oy=0;a.mx=0;a.zang=0;a.sample=0;a.t_abs=0;a.ox=0;","frame_eqs_str":"a.t1=a.time-Math.floor(a.time);a.sample=div(a.instance,a.num_inst);a.t_abs=3*a.sample;a.t_rel=a.sample-div(a.time,5);a.ampl=div(2*a.t_abs,2);a.k1=Math.sin(div(a.time,13));a.k2=Math.sin(div(a.time,12));a.ox=a.ampl*Math.sin(a.t_abs*(31+5*a.k1))+Math.sin(div(a.time,25))*(1-a.t_abs)*.4;a.oy=a.ampl*Math.cos(a.t_abs*(31+5*a.k2));a.oz=-1;a.r=sqr(Math.sin(3.4*a.t_rel));a.g=sqr(Math.sin(a.t_rel));a.b=sqr(Math.cos(1.8*a.t_rel));a.xang=div(a.time,9.5);a.yang=div(0*a.time,7);a.zang=div(-a.time,\n22);a.fov=.5;a.mx=a.ox*Math.cos(a.zang)-a.oy*Math.sin(a.zang);a.my=a.ox*Math.sin(a.zang)+a.oy*Math.cos(a.zang);a.ox=a.mx;a.oy=a.my;a.mx=a.ox*Math.cos(a.yang)+a.oz*Math.sin(a.yang);a.mz=-a.ox*Math.sin(a.yang)+a.oz*Math.cos(a.yang);a.ox=a.mx;a.oz=a.mz;a.my=a.oy*Math.cos(a.xang)-a.oz*Math.sin(a.xang);a.mz=a.oy*Math.sin(a.xang)+a.oz*Math.cos(a.xang);a.oy=a.my;a.oz=a.mz;a.oz-=6;a.x=div(a.ox*a.fov,a.oz)+.5;a.y=div(a.oy*a.fov,a.oz)+.5;a.a=.5*div(1,a.mz);a.rad=.005*div(1,a.mz);","init_eqs_eel":"","frame_eqs_eel":"t1 = time - int (time);\nsample = instance/num_inst;\nt_abs = sample*3;\nt_rel = sample-time/5;\n\nampl = 2*t_abs/2 ;\n\nk1=sin(time/13);\nk2=sin(time/12);\nox = ampl*sin (t_abs*(31+5*k1)) + sin(time/25)*(1-t_abs)*0.4  ;\noy = ampl*cos (t_abs*(31+5*k2));\noz = -1  ;\n\n\nr = sqr(sin(t_rel*3.4));\ng = sqr(sin(t_rel));\nb = sqr (cos(t_rel*1.8));\n\n//a=(0.1*(sin(t_abs*3)) + 0.6*q3*below (abs(1-t_abs-t1 ),0.3))*a;\n\nxang = time/9.5;\nyang = 0*time/7;\nzang = -time/22;\nfov = 0.5;\n\n\n// Rotation um x,y,z\n\nmx = ox*cos(zang) - oy*sin(zang);\nmy = ox*sin(zang) + oy*cos(zang);\n\nox = mx;\noy = my;\nmx = ox*cos(yang) + oz*sin(yang);\nmz = - ox*sin(yang) + oz*cos(yang);\nox = mx;\noz = mz;\nmy = oy*cos(xang) - oz*sin(xang);\nmz = oy*sin(xang) + oz*cos(xang);\noy = my;\noz = mz;\n\noz = oz - 6;\nx = ox*fov/oz +0.5;\n//x = (x-.5)*0.75 + 0.5;\ny = oy*fov/oz + 0.5;\n\na=1/mz*.5;\n//a2=1/mz*.5;\n//border_a=1/mz*.5;\nrad=1/mz*.005;"},{"baseVals":{"enabled":1,"sides":3,"thickoutline":1,"textured":1,"num_inst":311,"rad":0.01,"tex_ang":0.62832,"r":0,"g2":0,"border_r":0,"border_g":0,"border_b":0,"border_a":0},"init_eqs_str":"a.ma=0;a.mx=0;a.my=0;a.pi23=0;a.t1=0;","frame_eqs_str":"a.ma+=3.1415*above(a.bass,1)*.01*a.bass;a.ma-=3.1415*above(a.treb,1)*.01*a.treb;a.mx+=.0002*Math.cos(a.ma);a.my+=.0002*Math.tan(a.ma);a.mx=.00001<Math.abs(above(a.mx,.9))?.9-a.mx:a.mx;a.my=.00001<Math.abs(above(a.my,.9))?.9-a.my:a.my;a.mx=.00001<Math.abs(below(a.mx,.1))?.9+a.mx:a.mx;a.my=.00001<Math.abs(below(a.my,.1))?.9+a.my:a.my;a.x=1-a.mx;a.y=1-a.my;a.ang=3*(Math.sin(.35*a.time)+1);a.pi23=1.333333332*Math.asin(1);a.t1=a.bass+a.mid+a.treb;","init_eqs_eel":"","frame_eqs_eel":"ma=ma+(above(bass,1)*3.1415*.01*bass);\nma=ma-(above(treb,1)*3.1415*.01*treb);\n\nmx=mx+(.0002*cos(ma));\nmy=my+(.0002*tan(ma));\n\nmx=if(above(mx,.9),(.9-mx),mx);\nmy=if(above(my,.9),(.9-my),my);\nmx=if(below(mx,.1),(.9+mx),mx);\nmy=if(below(my,.1),(.9+my),my);\n\nx=1-mx;\ny=1-my;\n\nang=(sin(time*.35)+1)*3;\n//a=(above(bass+mid+treb,.8));\npi23=4*asin(1)*.333333333;\nt1=bass+mid+treb;"},{"baseVals":{"enabled":1,"sides":3,"additive":1,"num_inst":392,"rad":0.16283,"tex_zoom":0.73458,"r":0,"g":1,"b":1,"a":0.5,"g2":0,"border_a":0},"init_eqs_str":"a.bending=0;a.ppo=0;a.index=0;a.i3=0;a.dir=0;a.i4=0;a.size=0;a.q2=0;a.q32=0;a.sample=0;a.i3=0;a.i4=0;","frame_eqs_str":"a.i3=.00001<Math.abs(equal(a.instance,0))?0:a.i3;a.i4=.00001<Math.abs(equal(a.instance,0))?0:a.i4;a.ppo=8;a.index=a.i4*a.q32;a.sample=mod(a.i3,a.ppo);a.size=40*a.gmegabuf[Math.floor(a.index+4)];a.x=a.gmegabuf[Math.floor(a.index)];a.y=a.gmegabuf[Math.floor(a.index+1)];a.ang=a.gmegabuf[Math.floor(a.index+9)];a.rad=.05*a.size;a.r=a.gmegabuf[Math.floor(a.index+5)];a.g=a.gmegabuf[Math.floor(a.index+6)];a.b=a.gmegabuf[Math.floor(a.index+7)];a.sample=div(a.sample,a.ppo);a.bending=\n5*a.gmegabuf[Math.floor(a.index+12)]+5*a.gmegabuf[Math.floor(a.index+10)];a.dir=-a.ang+(a.sample-.4)*a.bending;a.ang=1.5*Math.asin(1)-a.dir+.05*a.bending;a.x+=.06*(a.sample-.3)*Math.cos(a.dir)*a.size+Math.sin(a.dir)*a.size*a.bending*.01;a.y+=.06*(a.sample-.3)*Math.sin(a.dir)*a.size-Math.cos(a.dir)*a.size*a.bending*.01;a.x=.5+div(a.x-.5,a.q2);a.rad=1.5*a.rad-.05*a.sample*a.size;a.i3+=1;a.i4=.00001<Math.abs(equal(mod(a.i3,a.ppo),0))?a.i4+1:a.i4;","init_eqs_eel":"i3 = 0;\ni4 = 0;","frame_eqs_eel":"i3 = if(equal(instance,0),0,i3);\ni4 = if(equal(instance,0),0,i4);\nppo = 8;\nindex = i4*q32;\nsample = i3 % ppo;\n\nsize = gmegabuf(index+4)*40;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nang = gmegabuf(index+9);\nrad = size*0.05;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\n\nsample = sample/ppo;\nbending = gmegabuf(index + 12)*5 + gmegabuf(index + 10)*5;\ndir = -ang + (sample-0.4)*bending;\n\n ang =  asin(1)*1.5 - dir + bending*0.05;\n\nx = x + ((sample-0.3)*0.06*cos(dir)*size + sin(dir)*size*bending*0.01);\ny = y + ((sample-0.3)*0.06*sin(dir)*size - cos(dir)*size*bending*0.01);\n\nx = 0.5 + (x-0.5)/q2;\n\nrad = rad*1.5 - sample*0.05*size;\n\ni3 = i3 + 1;\ni4 = if( equal(i3%ppo,0), i4 +1, i4);"}],"waves":[{"baseVals":{"samples":452,"thick":1,"additive":1,"scaling":2.44415,"smoothing":0,"a":0.25,"enabled":0},"init_eqs_str":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_str":"t1 = 0;\nt2 = 0;","point_eqs_str":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + q30); // the next neighbor's index\nnnindex = gmegabuf(index + q30+1); // the next neighbor's index\nnnnindex = gmegabuf(index + q30+2); // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0;//0.5 + gmegabuf(index+5)*0.5;\ng = 0;//0.5 + gmegabuf(index+6)*0.5;\nb = 1;//.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t1 = 0;\nt2 = 0;","point_eqs_eel":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + q30); // the next neighbor's index\nnnindex = gmegabuf(index + q30+1); // the next neighbor's index\nnnnindex = gmegabuf(index + q30+2); // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0;//0.5 + gmegabuf(index+5)*0.5;\ng = 0;//0.5 + gmegabuf(index+6)*0.5;\nb = 1;//.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);"},{"baseVals":{"enabled":1,"samples":65,"spectrum":1,"usedots":1,"thick":1,"additive":1,"scaling":0.33408,"smoothing":0,"a":0},"init_eqs_str":"a.d=0;a.q32=0;a.t8=0;a.t1=0;a.t2=0;a.t2=0;a.t3=0;a.t4=0;a.cl=0;","frame_eqs_str":"a.t8=1;a.t1=.5;a.t2=.9;","point_eqs_str":"a.d=0;a.y=.2+a.value1+a.value2;a.x=.9-.8*a.sample;a.gmegabuf[Math.floor((64*a.sample-1)*a.q32+14)]=a.value1+a.value2;","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t8 = 1;\n\nt1 = 0.5;\nt2 = 0.9;","point_eqs_eel":"d = 0;//d*0.85 + (value1)*1;\n\ny = 0.2 + value1+value2;\nx = 0.9 - sample*0.8;\n\ngmegabuf((sample*64-1)*q32 + 14) = value1 + value2;"},{"baseVals":{"samples":350,"additive":1,"scaling":5.92556,"smoothing":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"t1 = 0;\nt2 = 0;\n\n","point_eqs_str":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0; \nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d; \n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0;//.5 + gmegabuf(index + 5)*0.5;\ng = 0;//.5 + gmegabuf(index + 6)*0.5;\nb = 1;//0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);","init_eqs_eel":"","frame_eqs_eel":"t1 = 0;\nt2 = 0;\n\n","point_eqs_eel":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0; \nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d; \n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0;//.5 + gmegabuf(index + 5)*0.5;\ng = 0;//.5 + gmegabuf(index + 6)*0.5;\nb = 1;//0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);"},{"baseVals":{"samples":15,"thick":1,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.4,"enabled":0},"init_eqs_str":"t2 = 0","frame_eqs_str":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_str":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n","init_eqs_eel":"t2 = 0","frame_eqs_eel":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_eel":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n"}],"init_eqs_str":"a.fric=0;a.mq29=0;a.cthr=0;a.d=0;a.px=0;a.mq1=0;a.nliststart=0;a.w=0;a.random=0;a.index2=0;a.q25=0;a.index=0;a.q12=0;a.w2=0;a.rotatefactor=0;a.ref_ang=0;a.smaller=0;a.t1=0;a.q22=0;a.q21=0;a.q13=0;a.q29=0;a.q6=0;a.dt=0;a.q1=0;a.mq31=0;a.q5=0;a.py=0;a.mq21=0;a.j=0;a.mq24=0;a.x=0;a.g2=0;a.v=0;a.chng=0;a.mq28=0;a.count=0;a.mq23=0;a.shock=0;a.q31=0;a.q23=0;a.q24=0;a.vx=0;a.q11=0;a.nn=0;a.vrr=0;a.check=0;a.gravity=0;a.atime=0;a.vy=0;a.vr2=0;a.direction=0;a.q4=0;a.bouncefactor=0;a.r2=\n0;a.smallestfind=0;a.distance=0;a.bounce=0;a.q26=0;a.vr=0;a.x4=0;a.t=0;a.vv1=0;a.vv2=0;a.vrr2=0;a.p2=0;a.w1=0;a.attributes=0;a.i=0;a.b=0;a.r=0;a.y=0;a.mq27=0;a.mq25=0;a.m2=0;a.g=0;a.hit=0;a.b2=0;a.mq22=0;a.t2=0;a.vol=0;a.p1=0;a.mq26=0;a.q2=0;a.q27=0;a.m1=0;a.q14=0;a.h=0;a.v1=0;a.speed=0;a.q3=0;a.s1=0;a.t0=0;a.s2=0;a.acceleration=0;a.q32=0;a.findindex=0;a.y4=0;a.friction=0;a.q28=0;a.c=0;a.pi2=0;a.q30=0;a.sample=0;a.v2=0;a.dampening=0;for(var b=a.i=0;1048576>b;b++)a.gmegabuf[Math.floor(a.i)]=0,a.i+=\n1;a.count=50;a.attributes=32;a.nliststart=24;a.minradius=.004;a.maxradius=.04;a.v=0;for(b=a.index=0;b<a.count;b++)a.gmegabuf[Math.floor(a.index*a.attributes)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+1)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+2)]=a.v*(div(rand(1E3),1E3)-.5),a.gmegabuf[Math.floor(a.index*a.attributes+3)]=a.v*(div(rand(1E3),1E3)-.5),a.gmegabuf[Math.floor(a.index*a.attributes+4)]=a.minradius+div((a.maxradius-a.minradius)*(a.index+1),a.count),\na.gmegabuf[Math.floor(a.index*a.attributes+5)]=0,a.gmegabuf[Math.floor(a.index*a.attributes+6)]=1,a.gmegabuf[Math.floor(a.index*a.attributes+7)]=0,a.gmegabuf[Math.floor(a.index*a.attributes+8)]=pow(a.gmegabuf[Math.floor(a.index*a.attributes+4)],3),a.gmegabuf[Math.floor(a.index*a.attributes+9)]=div(4*Math.asin(1)*rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+10)]=0,a.gmegabuf[Math.floor(a.index*a.attributes+13)]=div(a.index,a.count-1),a.gmegabuf[Math.floor(a.index*a.attributes+14)]=0,a.index+=\n1;a.q30=a.nliststart;a.q31=a.count;a.q32=a.attributes;a.q29=(a.count-1)*a.attributes;a.q28=Math.asin(1);for(b=a.i=0;1E4>b;b++)a.gmegabuf[Math.floor(a.i)]=0,a.i+=1;a.t=0;a.t0=a.time;","frame_eqs_str":"a.chng=Math.sin(.5*a.time);a.cthr=.9999;a.mq21=.00001<Math.abs(above(a.chng,a.cthr))?rand(3):a.mq21;a.mq22=.00001<Math.abs(above(a.chng,a.cthr))?rand(3):a.mq22;a.mq23=.00001<Math.abs(above(a.chng,a.cthr))?rand(3):a.mq23;a.mq24=.00001<Math.abs(above(a.chng,a.cthr))?rand(2):a.mq24;a.mq25=.00001<Math.abs(above(a.chng,a.cthr))?rand(2):a.mq25;a.mq26=.00001<Math.abs(above(a.chng,a.cthr))?rand(2):a.mq26;a.mq27=.00001<Math.abs(above(a.chng,a.cthr))?rand(1):a.mq27;a.mq28=.00001<Math.abs(above(a.chng,\na.cthr))?rand(1):a.mq28;a.mq29=.00001<Math.abs(above(a.chng,a.cthr))?.3*rand(1):a.mq29;a.mq31=.00001<Math.abs(above(a.chng,a.cthr))?.3*rand(1):a.mq31;a.monitor=a.chng;a.q21=a.mq21;a.q22=a.mq22;a.q23=a.mq23;a.q24=a.mq24;a.q25=a.mq25;a.q26=a.mq26;a.q27=a.mq27;a.q28=a.mq28;a.q29=a.mq29;a.q31=a.mq31;a.monitor=a.mq1;a.vol=a.bass+a.treb+a.mid;a.atime+=a.vol;a.q11=.4+.4*Math.sin(.006*a.atime);a.q12=.4+.4*Math.cos(.00613828348*a.atime);a.q13=.4+.4*Math.sin(.00598593455*a.atime);a.monitor=a.q13;a.wave_a=0;\na.warp=0;a.q6=a.aspecty;a.t+=div(.001,a.fps);a.c=bnot(mod(a.frame,3));a.s1=15+5*Math.sin(a.t);a.s2=100*Math.sin(a.t);a.i=0;a.x=0;a.y=0;a.p1=0;for(var c=a.p2=0;c<4096*a.c;c++)a.p1=a.s1*Math.sin(a.i*a.s2),a.p2=-a.s1*Math.cos(a.i*a.s2)+a.p1-a.p2,a.x+=Math.sin(a.p2),a.y+=Math.cos(a.p2),a.gmegabuf[Math.floor(2*a.i)]=a.x,a.gmegabuf[Math.floor(2*a.i+1)]=a.y,a.i+=1;a.zoom=above(a.time-a.t0,.1);a.speed=25;a.t2+=div(1,a.fps);a.decay=1-a.t1;a.t1+=div(2*equal(mod(.1*a.t2*a.speed,20),0),a.fps);a.t1*=above(.2,\nmod(.1*a.t2*a.speed,20));a.monitor=a.s2;a.q2=.004;a.q30=2*(a.bass+a.treb+a.mid);a.zoom=1-(1-pow(2,.0031*(a.bass+a.treb+a.mid)));a.dt=div(1,a.fps);a.warp=0;a.zoom=1;a.wave_a=0;a.gravity=0*a.dt;a.dampening=0;a.friction=2048*a.dt;a.shock=.002;a.pi2=Math.asin(1);a.nn=3;a.check=2;a.bouncefactor=.1;a.rotatefactor=0;a.h=.5*(a.aspecty-1);a.w=.5*(a.aspectx-1);a.index=0;for(c=a.index2=0;c<a.count;c++){a.random=div(rand(1E3),1E3);a.sample=a.gmegabuf[Math.floor(a.index+13)];a.gmegabuf[Math.floor(a.index+11)]=\n.92*a.gmegabuf[Math.floor(a.index+11)]-4*a.gmegabuf[Math.floor(a.index+12)]*a.dt+2*(a.random-.5)*a.dt*a.gmegabuf[Math.floor(a.index+14)];a.gmegabuf[Math.floor(a.index+12)]+=60*a.gmegabuf[Math.floor(a.index+11)]*a.dt;a.v=sqrt(sqr(a.gmegabuf[Math.floor(a.index+2)])+sqr(a.gmegabuf[Math.floor(a.index+3)]));a.fric=Math.max(0,1-sqr(a.v*a.friction)-2*a.v);a.gmegabuf[Math.floor(a.index+2)]*=a.fric;a.gmegabuf[Math.floor(a.index+3)]*=a.fric;a.gmegabuf[Math.floor(a.index+10)]=a.gmegabuf[Math.floor(a.index+10)]*\na.fric+a.v*a.gmegabuf[Math.floor(a.index+12)]*0;a.acceleration=0*a.random+.003*Math.abs(a.gmegabuf[Math.floor(a.index+11)]);a.direction=a.gmegabuf[Math.floor(a.index+9)]-a.pi2;a.gmegabuf[Math.floor(a.index+2)]+=Math.sin(a.direction)*a.acceleration;a.gmegabuf[Math.floor(a.index+3)]+=Math.cos(a.direction)*a.acceleration;a.gmegabuf[Math.floor(a.index)]+=60*a.gmegabuf[Math.floor(a.index+2)]*a.dt;a.gmegabuf[Math.floor(a.index+1)]+=60*a.gmegabuf[Math.floor(a.index+3)]*a.dt;a.gmegabuf[Math.floor(a.index+\n9)]+=.5*a.gmegabuf[Math.floor(a.index+10)];a.gmegabuf[Math.floor(a.index+3)]-=a.gravity;a.vr=Math.sin(a.gmegabuf[Math.floor(a.index+10)])*a.gmegabuf[Math.floor(a.index+4)];a.bounce=above(a.gmegabuf[Math.floor(a.index+1)],1-a.gmegabuf[Math.floor(a.index+4)]+a.w);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+2)]+(a.vr+a.gmegabuf[Math.floor(a.index+2)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.bounce)?\n-Math.abs(a.gmegabuf[Math.floor(a.index+3)])*a.dampening-a.shock:a.gmegabuf[Math.floor(a.index+3)];a.vr=.00001<Math.abs(a.bounce)?a.vr-(a.gmegabuf[Math.floor(a.index+2)]+a.vr)*(1-a.rotatefactor):a.vr;a.bounce=below(a.gmegabuf[Math.floor(a.index+1)],a.gmegabuf[Math.floor(a.index+4)]-a.w);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+2)]+(a.vr-a.gmegabuf[Math.floor(a.index+2)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+\n3)]=.00001<Math.abs(a.bounce)?Math.abs(a.gmegabuf[Math.floor(a.index+3)])*a.dampening+a.shock:a.gmegabuf[Math.floor(a.index+3)];a.vr=.00001<Math.abs(a.bounce)?a.vr+(a.gmegabuf[Math.floor(a.index+2)]-a.vr)*(1-a.rotatefactor):a.vr;a.bounce=above(a.gmegabuf[Math.floor(a.index)],1-a.gmegabuf[Math.floor(a.index+4)]+a.h);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?-Math.abs(a.gmegabuf[Math.floor(a.index+2)])*a.dampening-a.shock:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+\n3)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+3)]+(a.vr-a.gmegabuf[Math.floor(a.index+3)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+3)];a.vr=.00001<Math.abs(a.bounce)?a.vr+(a.gmegabuf[Math.floor(a.index+3)]-a.vr)*(1-a.rotatefactor):a.vr;a.bounce=below(a.gmegabuf[Math.floor(a.index)],a.gmegabuf[Math.floor(a.index+4)]-a.h);a.gmegabuf[Math.floor(a.index+2)]=.00001<Math.abs(a.bounce)?Math.abs(a.gmegabuf[Math.floor(a.index+2)])*a.dampening+a.shock:a.gmegabuf[Math.floor(a.index+2)];a.gmegabuf[Math.floor(a.index+\n3)]=.00001<Math.abs(a.bounce)?a.gmegabuf[Math.floor(a.index+3)]-(a.vr+a.gmegabuf[Math.floor(a.index+3)])*a.rotatefactor:a.gmegabuf[Math.floor(a.index+3)];a.vr=.00001<Math.abs(a.bounce)?a.vr-(a.gmegabuf[Math.floor(a.index+3)]+a.vr)*(1-a.rotatefactor):a.vr;a.gmegabuf[Math.floor(a.index+10)]=Math.asin(div(a.vr,a.gmegabuf[Math.floor(a.index+4)]));a.i=0;for(var b=a.j=0;b<a.count;b++)a.d=sqrt(sqr(a.gmegabuf[Math.floor(a.index)]-a.gmegabuf[Math.floor(a.i)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.i+\n1)])),a.d=.00001<Math.abs(equal(a.d,0))?10:a.d,a.d-=.5*(a.gmegabuf[Math.floor(a.index+4)]+a.gmegabuf[Math.floor(a.i+4)]),a.megabuf[Math.floor(a.j)]=a.i,a.megabuf[Math.floor(a.j+1)]=a.d,a.j+=2,a.i+=a.attributes;for(b=a.i=0;b<a.nn;b++){a.j=a.i;a.smallestfind=10;a.findindex=-1;for(var d=0;d<a.count-a.j;d++)a.distance=a.megabuf[Math.floor(2*a.j+1)],a.smaller=above(a.smallestfind,a.distance),a.smallestfind=.00001<Math.abs(a.smaller)?a.distance:a.smallestfind,a.findindex=.00001<Math.abs(a.smaller)?2*a.j:\na.findindex,a.j+=1;a.j=a.megabuf[Math.floor(2*a.i)];a.d=a.megabuf[Math.floor(2*a.i+1)];a.megabuf[Math.floor(2*a.i)]=a.megabuf[Math.floor(a.findindex)];a.megabuf[Math.floor(2*a.i+1)]=a.megabuf[Math.floor(a.findindex+1)];a.megabuf[Math.floor(a.findindex)]=a.j;a.megabuf[Math.floor(a.findindex+1)]=a.d;a.i+=1}for(b=a.i=0;b<a.nn;b++)a.gmegabuf[Math.floor(a.index+a.nliststart+a.i)]=a.megabuf[Math.floor(2*a.i)],a.i+=1;for(b=a.i=0;b<a.check;b++)a.index2=a.megabuf[Math.floor(a.i)],a.hit=below(sqrt(sqr(a.gmegabuf[Math.floor(a.index)]-\na.gmegabuf[Math.floor(a.index2)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.index2+1)])),a.gmegabuf[Math.floor(a.index+4)]+a.gmegabuf[Math.floor(a.index2+4)])*above(sqrt(sqr(a.gmegabuf[Math.floor(a.index)]-a.gmegabuf[Math.floor(a.index2)])+sqr(a.gmegabuf[Math.floor(a.index+1)]-a.gmegabuf[Math.floor(a.index2+1)])),sqrt(sqr(a.gmegabuf[Math.floor(a.index+0)]-a.gmegabuf[Math.floor(a.index2+0)]+a.gmegabuf[Math.floor(a.index+2)]-a.gmegabuf[Math.floor(a.index2+2)])+sqr(a.gmegabuf[Math.floor(a.index+\n1)]-a.gmegabuf[Math.floor(a.index2+1)]+a.gmegabuf[Math.floor(a.index+3)]-a.gmegabuf[Math.floor(a.index2+3)]))),a.ref_ang=Math.atan2(a.gmegabuf[Math.floor(a.index2)]-a.gmegabuf[Math.floor(a.index)],a.gmegabuf[Math.floor(a.index2+1)]-a.gmegabuf[Math.floor(a.index+1)])+a.pi2,a.v1=sqrt(sqr(a.gmegabuf[Math.floor(a.index+2)])+sqr(a.gmegabuf[Math.floor(a.index+3)])),a.v2=sqrt(sqr(a.gmegabuf[Math.floor(a.index2+2)])+sqr(a.gmegabuf[Math.floor(a.index2+3)])),a.w1=Math.atan2(a.gmegabuf[Math.floor(a.index+2)],\na.gmegabuf[Math.floor(a.index+3)]),a.w2=Math.atan2(a.gmegabuf[Math.floor(a.index2+2)],a.gmegabuf[Math.floor(a.index2+3)]),a.vr2=Math.sin(a.gmegabuf[Math.floor(a.index2+10)])*a.gmegabuf[Math.floor(a.index2+4)],a.m1=a.gmegabuf[Math.floor(a.index+8)],a.m2=a.gmegabuf[Math.floor(a.index2+8)],a.vv1=div((a.m1-a.m2)*a.v1+2*a.m2*a.v2,a.m1+a.m2),a.vv2=div((a.m2-a.m1)*a.v2+2*a.m1*a.v1,a.m1+a.m2),a.vrr=div((a.m1-a.m2)*a.vr+2*a.m2*a.vr2,a.m1+a.m2),a.vrr2=div((a.m2-a.m1)*a.vr2+2*a.m1*a.vr,a.m1+a.m2),a.gmegabuf[Math.floor(a.index+\n2)]=.00001<Math.abs(a.hit)?Math.sin(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang)+.1*(a.vr-a.vr2-Math.sin(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang))+Math.cos(a.ref_ang)*a.vv1*Math.sin(a.w2-a.ref_ang):a.gmegabuf[Math.floor(a.index+2)],a.gmegabuf[Math.floor(a.index+3)]=.00001<Math.abs(a.hit)?Math.cos(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang)+.1*(a.vr-a.vr2-Math.cos(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang))-Math.sin(a.ref_ang)*a.vv1*Math.sin(a.w2-a.ref_ang):a.gmegabuf[Math.floor(a.index+3)],a.gmegabuf[Math.floor(a.index2+\n2)]=.00001<Math.abs(a.hit)?Math.sin(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang)+.1*(a.vr2-a.vr-Math.sin(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang))+Math.cos(a.ref_ang)*a.vv2*Math.sin(a.w1-a.ref_ang):a.gmegabuf[Math.floor(a.index2+2)],a.gmegabuf[Math.floor(a.index2+3)]=.00001<Math.abs(a.hit)?Math.cos(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang)+.1*(a.vr2-a.vr-Math.cos(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang))-Math.sin(a.ref_ang)*a.vv2*Math.sin(a.w1-a.ref_ang):a.gmegabuf[Math.floor(a.index2+3)],a.vr=.00001<\nMath.abs(a.hit)?a.vr+(Math.cos(a.w1-a.ref_ang)*(a.v1-a.v2)-a.vr):a.vr,a.gmegabuf[Math.floor(a.index+10)]=Math.asin(div(a.vr,a.gmegabuf[Math.floor(a.index+4)])),a.vr2=.00001<Math.abs(a.hit)?a.vr2+(Math.cos(a.w2-a.ref_ang)*(a.v2-a.v1)-a.vr2):a.vr2,a.gmegabuf[Math.floor(a.index2+10)]=Math.asin(div(a.vr2,a.gmegabuf[Math.floor(a.index2+4)])),a.i+=2;a.index+=a.attributes}a.index=(a.q31-1)*a.q32;a.px=a.gmegabuf[Math.floor(a.index)];a.py=a.gmegabuf[Math.floor(a.index+1)];a.w=a.gmegabuf[Math.floor(a.index+\n9)];a.r2=a.r;a.g2=a.g;a.b2=a.b;a.x=.5+div(a.x-.5,a.q2);a.zoom=1;a.warp=0;a.q1=a.aspectx;a.q2=a.aspecty;a.x4=.5;a.y4=.5;a.vx=Math.cos(a.w);a.vy=-Math.sin(a.w);a.q3=a.x4;a.q4=a.y4;a.q5=.5+div(a.px-.5,a.aspecty);a.q6=.5+div(a.py-.5,a.aspectx);a.monitor=a.r;a.w=-2*Math.atan2(a.vy,a.vx);a.q13=Math.cos(a.w);a.q14=Math.sin(a.w);","pixel_eqs_str":"","init_eqs_eel":"// clear buffer\ni = 0; loop(1024*1024, gmegabuf(i) = 0; i = i+1);\n\ncount = 50;\nattributes = 32;\nnListStart = 24; // starting index of neighbor list\n\nminradius = 0.004;\nmaxradius = 0.04;\nv = 0.0;\n\n// randomize initial coordinates\nindex = 0;\nloop(count, \n     gmegabuf(index*attributes) = rand(1000)/1000;\n     gmegabuf(index*attributes+1) = rand(1000)/1000;\n     gmegabuf(index*attributes+2) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+3) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+4) = minradius + (maxradius-minradius)*(index+1)/count;\n     gmegabuf(index*attributes+5) = 0;\n     gmegabuf(index*attributes+6) = 1;\n     gmegabuf(index*attributes+7) = 0;\n     gmegabuf(index*attributes+8) = pow(gmegabuf(index*attributes+4),3) ;\n     gmegabuf(index*attributes+9) = 4*asin(1)*rand(1000)/1000;\n     gmegabuf(index*attributes+10) = 0;\n     gmegabuf(index*attributes+13) = index/(count-1);\n     gmegabuf(index*attributes+14) = 0;\n     index = index+1;\n    );\n\nq30 = nListStart;\nq31 = count;\nq32 = attributes;\n\nq29 = (count-1)*attributes; // last index\nq28 = asin(1);\n// 0, x\n// 1, y\n// 2, vx\n// 3, vy\n// 4, radius\n// 5, red\n// 6, green\n// 7, blue\n// 8, mass\n// 9, angle\n// 10, rotation\n// 11, bend force\n// 12, bending\n// 13, sample\n// 14, spectrum\n//prma init\ni=0;  \nloop(10000, gmegabuf(i)=0;\ni=i+1;);\nt=0;\nt0=time;","frame_eqs_eel":"chng=sin(time*.5);\ncthr=.9999;\nmq21=if(above(chng,cthr),rand(3),mq21);\nmq22=if(above(chng,cthr),rand(3),mq22);\nmq23=if(above(chng,cthr),rand(3),mq23);\nmq24=if(above(chng,cthr),rand(2),mq24);\nmq25=if(above(chng,cthr),rand(2),mq25);\nmq26=if(above(chng,cthr),rand(2),mq26);\nmq27=if(above(chng,cthr),rand(1),mq27);\nmq28=if(above(chng,cthr),rand(1),mq28);\nmq29=if(above(chng,cthr),rand(1)*.3,mq29);\nmq31=if(above(chng,cthr),rand(1)*.3,mq31);\nmonitor=chng;\nq21=mq21;q22=mq22;q23=mq23;q24=mq24;q25=mq25;q26=mq26;\nq27=mq27;q28=mq28;q29=mq29;q31=mq31;\n\nmonitor=mq1;\nvol=bass+treb+mid;\natime=atime+vol;\nq11=.4+sin(atime*.006        )*.4;\nq12=.4+cos(atime*.00613828348)*.4;\nq13=.4+sin(atime*.00598593455)*.4;\nmonitor=q13;\n//prma\nwave_a=0;        warp=0;        q6=aspecty; \nt=t+.001/fps;     c=bnot(frame%3);\ns1=15+5*sin(t);         s2=100*sin(t);\ni=0;    x=0;     y=0;    p1=0;    p2=0;\nloop(1024*c*4,\np1 = s1*sin(i*s2);   \np2 = -s1*cos(i*s2)+p1-p2;\nx=x+sin(p2);         y=y+cos(p2);\ngmegabuf(2*i)=x;      gmegabuf(2*i+1)=y;\ni=i+1;);\n///////////\nzoom=above(time-t0,.1);\nspeed = 25; //// tweak\nt2=t2+1/fps;\ndecay=1-t1;\nt1=t1+2*equal((.1*t2*speed)%20,0)/fps;\nt1=t1*above(0.2,(.1*t2*speed)%20);\nmonitor=s2;\nq2=.004;\n\nq30=(bass+treb+mid)*2;\n\nzoom=1-(1-pow(2,(bass+treb+mid)*.0031));\n\ndt = 1/fps;\n\nwarp = 0;\nzoom = 1;\nwave_a = 0;\n\ngravity = 0.0015*dt*0;\ndampening = 0.;\nfriction = 2048*dt;\nshock = 0.002;\npi2 = asin(1);\n\nnn = 3; // number of nearest neighbors to search, reduce if not needed\n        // provide enough attributes, otherwise the next object's coordinate will be overwritten\n        // collision detection is based on nearest neighbors, so keep it at least at 1.\n\ncheck = 2; // how many neighbors will be checked for a possible collision. may not be above nn.\n           // raise to avoid odd behavior in clusters of touching objects.\n\nbouncefactor = 0.1;\nrotatefactor = 0; // relation between angular and translative momentum, when object hits a border. this is an empirical value for a convincing impression\n\n\n\nh = (aspecty-1)*0.5; w = (aspectx-1)*0.5;\nindex = 0; index2 = 0;\nloop(count, \n\n     random = rand(1000)/1000;\n     sample = gmegabuf(index+13);\n\n     // bend force\n     gmegabuf(index + 11) = gmegabuf(index + 11)*0.92 - 4*gmegabuf(index+12)*dt + 2*(random-0.5)*dt*gmegabuf(index+14);\n\n     // bend\n     gmegabuf(index + 12) += 60*gmegabuf(index + 11)*dt;\n     \n     v = sqrt( sqr( gmegabuf(index + 2) ) + sqr( gmegabuf(index + 3) ) );\n\n     // apply friction\n     fric = max(0,1 - sqr(v*friction) - v*2);\n     gmegabuf(index + 2) *= fric;\n     gmegabuf(index + 3) *= fric;\n\n     // apply direction change\n     gmegabuf(index + 10) = gmegabuf(index + 10)*fric +  v*gmegabuf(index +12)*0;\n\n     // apply acceleration force\n     acceleration = random*0.000 + abs(gmegabuf(index+11))*0.003;\n     direction = gmegabuf(index + 9) - pi2;\n     gmegabuf(index + 2) += sin(direction)*acceleration;\n     gmegabuf(index + 3) += cos(direction)*acceleration;\n\n     // adding velocity vectors\n     gmegabuf(index) = gmegabuf(index) + gmegabuf(index+2)*60*dt;\n     gmegabuf(index+1) = gmegabuf(index+1) + gmegabuf(index+3)*60*dt;\n     gmegabuf(index+9) = gmegabuf(index+9) + gmegabuf(index+10)*0.5;\n\n     // applying gravity\n     gmegabuf(index+3) = gmegabuf(index+3) - gravity;\n\n     vr = sin(gmegabuf(index+10))*gmegabuf(index+4); // rotation speed at the surface\n\n     // bounce off ceiling\n     bounce = above( gmegabuf(index+1), 1 - gmegabuf(index+4) + w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr+gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, -abs(gmegabuf(index+3))*dampening - shock, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+2) + vr)*(1-rotatefactor), vr);\n\n     // bounce off floor\n     bounce = below( gmegabuf(index+1), gmegabuf(index+4) - w);\n     gmegabuf(index+2) = if( bounce, gmegabuf(index+2) + (vr-gmegabuf(index+2))*rotatefactor, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, abs(gmegabuf(index+3))*dampening + shock, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+2) - vr)*(1-rotatefactor), vr);\n\n     // bounce off right border\n     bounce = above( gmegabuf(index), 1 - gmegabuf(index+4) + h);\n     gmegabuf(index+2) = if( bounce, -abs(gmegabuf(index+2))*dampening - shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) + (vr-gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr + (gmegabuf(index+3) - vr)*(1-rotatefactor), vr);\n\n     // bounce off left border\n     bounce = below( gmegabuf(index), gmegabuf(index+4) - h);\n     gmegabuf(index+2) = if( bounce, abs(gmegabuf(index+2))*dampening + shock, gmegabuf(index+2));\n     gmegabuf(index+3) = if( bounce, gmegabuf(index+3) - (vr+gmegabuf(index+3))*rotatefactor, gmegabuf(index+3));\n     vr = if( bounce, vr - (gmegabuf(index+3) + vr)*(1-rotatefactor), vr);\n\n     gmegabuf(index+10) = asin(vr/gmegabuf(index+4));\n\n     i = 0; j = 0; // collecting pairs of index and distance to the current object in a local buffer\n     loop( count,\n           d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n           d = if( equal(d,0), 10, d); // leave out comparison with itself (where d == 0, set d to a high value)\n           d = d - (gmegabuf(index+4)+gmegabuf(i+4))*0.5; // subtract radius (surface to surface distance)\n           megabuf(j)   = i; // store index/distance pairs\n           megabuf(j+1) = d; \n           j = j+2;\n           i = i+attributes; );\n     i = 0; // sort that buffer, but only as many cycles as needed for the _nn_ nearest neighbors\n     loop( nn,\n           j = i; smallestfind = 10; findindex = -1;\n           loop( count-j,\n                 distance =megabuf(j*2+1);\n                 smaller = above( smallestfind, distance);\n                 smallestfind = if(smaller, distance, smallestfind);\n                 findindex = if( smaller, j*2, findindex);\n                 j = j + 1; );\n           j = megabuf(i*2); d = megabuf(i*2+1);\n           megabuf(i*2)   = megabuf(findindex);\n           megabuf(i*2+1) = megabuf(findindex+1);\n           megabuf(findindex)   = j;\n           megabuf(findindex+1) = d;\n           i = i+1;\n         );\n     i = 0; // storing the indexes of the nearest neighbors in the list\n     loop( nn,\n           gmegabuf(index + nListStart + i) = megabuf(i*2);\n           i = i +1;\n         );\n     i = 0; // collision detection and impulse transmission below\n     loop( check,\n           index2 = megabuf(i);\n           hit = below( sqrt( sqr( gmegabuf(index) - gmegabuf(index2)) +\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        gmegabuf(index + 4) + gmegabuf(index2 + 4)\n                      )\n                 *\n                 above( sqrt( sqr( gmegabuf(index)   - gmegabuf(index2))+\n                        sqr( gmegabuf(index+1) - gmegabuf(index2+1))),\n                        sqrt( sqr( gmegabuf(index+0) - gmegabuf(index2+0)+ \n                                   gmegabuf(index+2) - gmegabuf(index2+2))+\n                              sqr( gmegabuf(index+1) - gmegabuf(index2+1)+\n                                   gmegabuf(index+3) - gmegabuf(index2+3)) ) );\n           ref_ang = atan2( gmegabuf(index2)-gmegabuf(index), // calculating the angle of the common tangent\n                            gmegabuf(index2 + 1)-gmegabuf(index + 1)) + pi2;\n           v1 = sqrt(sqr( gmegabuf(index + 2)) + sqr( gmegabuf(index + 3))); // velocity of object1\n           v2 = sqrt(sqr( gmegabuf(index2 + 2)) + sqr( gmegabuf(index2 + 3)));  // velocity of object2\n           w1 = atan2( gmegabuf(index + 2), gmegabuf(index + 3));   // object1 motion angle\n           w2 = atan2( gmegabuf(index2 + 2), gmegabuf(index2 + 3)); // object2 motion angle\n           vr2 = sin(gmegabuf(index2 + 10))*gmegabuf(index2+4); // the other object's surface velocity\n           m1 = gmegabuf(index + 8); m2 = gmegabuf(index2 + 8);\n           vv1 = ((m1-m2)*v1 + 2*m2*v2)/(m1+m2); vv2 = ((m2-m1)*v2 + 2*m1*v1)/(m1+m2);\n           vrr = ((m1-m2)*vr + 2*m2*vr2)/(m1+m2); vrr2 = ((m2-m1)*vr2 + 2*m1*vr)/(m1+m2);\n\n           gmegabuf( index + 2) = if( hit, sin(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-sin(ref_ang)*v1*cos(w1-ref_ang))*0.1\n                                         + cos(ref_ang)*vv1*sin(w2-ref_ang),\n                                                  gmegabuf( index + 2) );\n\n           gmegabuf( index + 3) = if( hit, cos(ref_ang)*v1*cos(w1-ref_ang) + ((vr-vr2)-cos(ref_ang)*v1*cos(w1-ref_ang))*0.1\n                                         - sin(ref_ang)*vv1*sin(w2-ref_ang),\n                                                 gmegabuf( index + 3) );\n\n           gmegabuf( index2 + 2) = if( hit, sin(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-sin(ref_ang)*v2*cos(w2-ref_ang))*0.1\n                                          + cos(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 2) );\n\n           gmegabuf( index2 + 3) = if( hit, cos(ref_ang)*v2*cos(w2-ref_ang) + ((vr2-vr)-cos(ref_ang)*v2*cos(w2-ref_ang))*0.1\n                                          - sin(ref_ang)*vv2*sin(w1-ref_ang),\n                                                  gmegabuf( index2 + 3) );\n\n           vr = if( hit, vr + (cos(w1-ref_ang)*(v1-v2)-vr) , vr);\n           gmegabuf( index + 10) = asin( vr / gmegabuf(index+4) );\n\n           vr2 = if( hit, vr2 + (cos(w2-ref_ang)*(v2-v1)-vr2) , vr2);\n           gmegabuf( index2 + 10) = asin( vr2 / gmegabuf(index2+4) );\n\n           i=i+2;\n         );\n     index = index+attributes;\n    );\n\n\n// lines for the predator shader\nindex = (q31-1)*q32;\n\npx = gmegabuf(index);\npy = gmegabuf(index+1);\n\nw = gmegabuf(index+9);\n//rad = gmegabuf(index+4)*2;\n\n//r = gmegabuf(index+5);\n//g = gmegabuf(index+6);\n//b = gmegabuf(index+7);\n\nr2 = r; g2 = g; b2 = b;\n\n\nx = 0.5 + (x-0.5)/q2;\n\nzoom = 1;\nwarp = 0;\nq1 = aspectx;\nq2 = aspecty;\n\nx4 = 0.5;\ny4 = 0.5;\nvx = cos(w);\nvy = -sin(w);\nq3 = x4;\nq4 = y4;\nq5 = 0.5 + (px-0.5)/aspecty;\nq6 = 0.5 + (py-0.5)/aspectx;\nmonitor = r;\nw = -2*atan2(vy,vx);\nq13 = cos(w);\nq14 = sin(w);","pixel_eqs_eel":"","warp":"vec3 xlat_mutablemus;\n shader_body { \n  vec3 ret7_1;\n  vec3 crisp_2;\n  vec2 uv6_3;\n  vec3 ret_4;\n  vec2 tmpvar_5;\n  tmpvar_5 = (uv - 0.5);\n  float tmpvar_6;\n  tmpvar_6 = (dot (texture (sampler_noise_hq, (uv / 4.0)), vec4(0.32, 0.49, 0.29, 0.0)) * q31);\n  mat2 tmpvar_7;\n  tmpvar_7[uint(0)].x = cos(tmpvar_6);\n  tmpvar_7[uint(0)].y = sin(tmpvar_6);\n  tmpvar_7[1u].x = -(sin(tmpvar_6));\n  tmpvar_7[1u].y = cos(tmpvar_6);\n  uv6_3 = (tmpvar_5 * tmpvar_7);\n  uv6_3 = (uv6_3 + sin((q32 * tmpvar_5)));\n  xlat_mutablemus = (vec3((0.2 / (\n    sqrt(uv6_3.x)\n   + 0.2))) * vec3(1.1, 1.0, 0.95));\n  xlat_mutablemus = (xlat_mutablemus * (0.9 + (0.1 * texture (sampler_noise_hq, uv))).xyz);\n  vec3 tmpvar_8;\n  tmpvar_8 = ((texture (sampler_blur1, fract(uv)).xyz * scale1) + bias1);\n  vec2 tmpvar_9;\n  tmpvar_9.x = dot ((texture (sampler_main, (uv + vec2(0.005, 0.0))) - texture (sampler_main, (uv - vec2(0.005, 0.0)))), vec4(0.32, 0.49, 0.29, 0.0));\n  tmpvar_9.y = dot ((texture (sampler_main, (uv + vec2(0.0, 0.005))) - texture (sampler_main, (uv - vec2(0.0, 0.005)))), vec4(0.32, 0.49, 0.29, 0.0));\n  crisp_2 = (texture (sampler_main, (uv + (tmpvar_9 * 0.02))).xyz + (texture (sampler_main, uv).xyz / 2.0));\n  crisp_2 = (crisp_2 * 0.67);\n  crisp_2 = (crisp_2 + ((0.08 * xlat_mutablemus) - (\n    sqrt(dot (tmpvar_9, tmpvar_9))\n   * tmpvar_8)));\n  ret_4 = (((crisp_2 - \n    (dot (tmpvar_8, vec3(0.32, 0.49, 0.29)) * 0.04)\n  ) * 0.99) - 0.04);\n  ret7_1 = ret_4;\n  ret_4.z = (0.3 - ret_4.x);\n  vec4 tmpvar_10;\n  tmpvar_10 = texture (sampler_noisevol_hq, (((vec3(0.05, 0.05, 0.0) * tmpvar_9.xyy) * (\n    (q27 * texsize.xyy)\n   * texsize_noisevol_hq.zww)) + ((time * vec3(0.0, 0.0, 1.0)) * q29)));\n  if (((ret_4.x > (q21 * q13)) && (ret_4.x <= (q24 * q11)))) {\n    ret_4.y = (ret_4.y - (tmpvar_10.x * 0.5));\n  };\n  ret_4.x = (0.3 - ret7_1.y);\n  if (((ret_4.y > (q22 * q11)) && (ret_4.y <= (q25 * q12)))) {\n    ret_4.z = (ret_4.z - (tmpvar_10.y * 0.5));\n  };\n  ret_4.y = (0.3 - ret7_1.z);\n  if (((ret_4.z > (q23 * q12)) && (ret_4.z <= (q26 * q13)))) {\n    ret_4.x = (ret_4.x - (tmpvar_10.z * 0.5));\n  };\n  ret7_1 = ret_4;\n  ret_4.z = (0.3 - ret_4.y);\n  ret_4.y = (0.3 - ret7_1.x);\n  ret_4.x = (0.3 - ret7_1.z);\n  ret7_1 = ret_4;\n  ret_4.x = (0.3 - ret_4.x);\n  ret_4.yz = (vec2(0.3, 0.3) - ret7_1.yz);\n  vec4 tmpvar_11;\n  tmpvar_11.w = 1.0;\n  tmpvar_11.xyz = ret_4;\n  ret = tmpvar_11.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec4 tmpvar_2;\n  tmpvar_2 = texture (sampler_main, uv);\n  float tmpvar_3;\n  tmpvar_3 = dot (tmpvar_2.xyz, vec3(0.32, 0.49, 0.29));\n  ret_1 = (((vec3(1.1, 0.8, 0.7) * tmpvar_2.x) + (vec3(0.4, 0.6, 0.55) * tmpvar_2.y)) + (vec3(0.7, 0.6, 0.9) * tmpvar_2.z));\n  ret_1 = ((ret_1 * ret_1) * (1.3 + (\n    (clamp (((\n      cos(((tmpvar_3 * 27.0) + 3.0))\n     * 30.0) - 26.0), 0.0, 1.0) * clamp (((\n      cos(((tmpvar_3 * 27.0) + 3.0))\n     * 30.0) - 26.0), 0.0, 1.0))\n   * 5.0)));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = ret_1;\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"float3 color, mus;\nfloat dx,dy;\n\nshader_body {\nfloat corr = texsize.xy*texsize_noise_lq.zw;\n\nfloat2 uv1 = (uv-.5);\nfloat2 uv6 = uv1;\n\nfloat rota = lum(tex2D (sampler_noise_hq,uv/4))*q31;\n\nuv6 = mul(uv1,float2x2(cos(rota),-sin(rota),sin(rota),cos(rota)));\nuv6 += sin(q32*uv1);\nmus = .2/(sqrt(uv6.x)+.2);\n\nmus *= float3 (1.1,1,.95);\nmus *= .9+.1*tex2D (sampler_noise_hq,uv);\n\nfloat3 blur = GetBlur1(frac(uv));\n\nfloat2 hor = float2 (0.005,0);\nfloat2 ver = float2 (0,.005);\n\nfloat dx = lum(tex2D(sampler_main,uv+hor) \n         - tex2D(sampler_main,uv-hor));\nfloat dy = lum(tex2D(sampler_main,uv+ver) \n         - tex2D(sampler_main,uv-ver));\n\n\nfloat2 zz = float2 (dx,dy);\n\nfloat3 crisp= tex2D(sampler_main,uv+zz*.02);\nfloat3 crisp2 = tex2D(sampler_main,uv);\ncrisp += crisp2/2;\ncrisp *= .67;\ncrisp +=.08 * mus - length(zz)*blur;\n\nfloat3 ret1 = crisp - lum(blur)*.04;\nret = ret1 * .99 -  .04 ;\nfloat3 ret7=ret;\nret.z=.3-ret7.x;\nfloat4 noise9 = tex3D(sampler_noisevol_hq, \n                      ((zz.xyy*q27\n                       )*texsize.xyy*texsize_noisevol_hq.zww\n                      ).xyz*\n                      float3(1,1,0)*0.05 + \n                      time*float3(0,0,1)*q29\n                     );\nif(ret.x> q21*q13         && ret.x<= q24*q11        )ret.y -= (noise9).x*.5; \nret.x=.3-ret7.y;\nif(ret.y> q22*q11         && ret.y<= q25*q12        )ret.z -= (noise9).y*.5; \nret.y=.3-ret7.z;\nif(ret.z> q23*q12         && ret.z<= q26*q13        )ret.x -= (noise9).z*.5; \nret7=ret;\nret.z=.3-ret7.y;\nret.y=.3-ret7.x;\nret.x=.3-ret7.z;\nret7=ret;\nret.x=.3-ret7.x;\nret.y=.3-ret7.y;\nret.z=.3-ret7.z;\n\n\n}","comp_hlsl":"shader_body\n{\n    ret = tex2D(sampler_main, uv).xyz;\n    float L = lum(ret);\n    float bw = saturate(cos(L*27 + 3)*30 - 26);\n    float L2 = lum(GetBlur1(uv));\n    float bw2 = saturate(cos(L*27 + 3)*30 - 26);\n\n    ret = float3(1.1,0.8,0.7)*ret.x +\n          float3(0.4,0.6,0.55)*ret.y + \n          float3(0.7,0.6,0.9)*ret.z;\n\n    ret = ret*ret * (1.3 + bw*bw2*5);\n\n}"}