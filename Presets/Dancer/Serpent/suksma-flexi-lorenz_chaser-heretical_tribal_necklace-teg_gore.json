{"version":2,"baseVals":{"rating":5,"gammaadj":1,"decay":1,"additivewave":1,"modwavealphabyvolume":1,"wave_a":0.009,"wave_scale":2.713,"wave_smoothing":0,"modwavealphastart":1.2,"modwavealphaend":1.2,"warpscale":1.331,"zoom":0.99951,"warp":0.00909,"wave_r":0.44,"wave_g":0.4,"ob_size":0.5,"ob_r":0.01,"ib_size":0.26,"mv_x":64,"mv_y":48,"mv_l":0.85,"mv_r":0.5,"mv_g":0.5,"mv_b":0.5,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"enabled":1,"sides":3,"additive":1,"num_inst":179,"rad":0.20065,"ang":0.75398,"tex_ang":3.14159,"tex_zoom":0.99979,"r":0,"g2":0,"border_g":0.5,"border_b":0.15,"border_a":1},"init_eqs_str":"a.my_z=0;a.d=0;a.y3=0;a.z2=0;a.y1=0;a.w=0;a.q12=0;a.w2=0;a.x1=0;a.q13=0;a.q15=0;a.dy1=0;a.zoom=0;a.p=0;a.q5=0;a.dz1=0;a.z3=0;a.w3=0;a.my_x=0;a.x3=0;a.my_y=0;a.q11=0;a.dd=0;a.q4=0;a.yy1=0;a.q16=0;a.w1=0;a.x2=0;a.q17=0;a.l=0;a.y2=0;a.dx1=0;a.zz1=0;a.q14=0;a.z1=0;a.q3=0;a.xx1=0;","frame_eqs_str":"a.xx1=.00001<Math.abs(equal(a.instance,0))?a.q11:a.xx1;a.yy1=.00001<Math.abs(equal(a.instance,0))?a.q12:a.yy1;a.zz1=.00001<Math.abs(equal(a.instance,0))?a.q13:a.zz1;a.dx1=a.q14*(a.yy1-a.xx1);a.dy1=a.xx1*(a.q15-a.zz1)-a.yy1;a.dz1=a.xx1*a.yy1-a.q16*a.zz1;a.dd=sqrt(a.dx1*a.dx1+a.dy1*a.dy1+a.dz1*a.dz1);a.xx1+=div(a.q17*a.dx1,a.dd);a.yy1+=div(a.q17*a.dy1,a.dd);a.zz1+=div(a.q17*a.dz1,a.dd);a.my_x=.1*a.xx1;a.my_y=.1*a.yy1;a.my_z=.1*a.zz1-3;a.d=5;a.zoom=.66;a.w1=a.q3;a.w2=a.q4;a.w3=\na.q5;a.x1=Math.cos(a.w1)*a.my_x+Math.sin(a.w1)*a.my_y;a.y1=-Math.sin(a.w1)*a.my_x+Math.cos(a.w1)*a.my_y;a.z1=a.my_z;a.x2=Math.cos(a.w2)*a.x1+Math.sin(a.w2)*a.z1;a.z2=-Math.sin(a.w2)*a.x1+Math.cos(a.w2)*a.z1;a.y2=a.y1;a.y3=Math.cos(a.w3)*a.y2+Math.sin(a.w3)*a.z2;a.z3=-Math.sin(a.w3)*a.y2+Math.cos(a.w3)*a.z2;a.x3=a.x2;a.l=sqrt(a.x3*a.x3+a.y3*a.y3);a.w=Math.atan2(a.x3,a.y3);a.p=Math.tan(Math.asin(1)+Math.atan2(a.d+a.z3,a.l));a.d=sqrt(a.x3*a.x3+a.y3*a.y3+(a.z3+a.d)*(a.z3+a.d));a.my_x=a.zoom*Math.sin(a.w)*\na.p;a.my_y=a.zoom*Math.cos(a.w)*a.p;a.x=.5+a.my_x;a.y=.5+a.my_y;a.rad=div(a.rad,a.d);a.ang-=div(a.instance,a.num_inst)*Math.asin(1)*8;a.r=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.g=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.b=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.r2=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.g2=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.b2=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.border_r=div(Math.floor(rand(30)),\n30)+a.instance-a.instance;a.border_g=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.border_b=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.a=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.a2=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.border_a=div(Math.floor(rand(30)),30)+a.instance-a.instance;a.sides=Math.floor(rand(30))+a.instance-a.instance;a.rad=div(Math.floor(rand(30)),500)+a.instance-a.instance;","init_eqs_eel":"","frame_eqs_eel":"//lorenz-attractor calc\nxx1 = if(equal(instance,0),q11,xx1);\nyy1 = if(equal(instance,0),q12,yy1);\nzz1 = if(equal(instance,0),q13,zz1);\n\ndx1 = q14*(yy1-xx1);\ndy1 = xx1*(q15-zz1)-yy1;\ndz1 = xx1*yy1-q16*zz1;\ndd = sqrt(dx1*dx1+dy1*dy1+dz1*dz1);\nxx1 = xx1 + q17*dx1/dd;\nyy1 = yy1 + q17*dy1/dd;\nzz1 = zz1 + q17*dz1/dd;\n\n\n// 3D object model coordinates\nmy_x = xx1*0.1;\nmy_y = yy1*0.1;\nmy_z = zz1*0.1 - 3;\n\n\nd = 5; // camera distance\nzoom = 0.66;\n\n// solid angles\nw1 = q3;\nw2 = q4;\nw3 = q5;\n\n// 3D rotation\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\nl = sqrt(x3*x3 + y3*y3);\nw = atan2(x3,y3);\np = tan(asin(1) + atan2(d+z3,l));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nmy_x = zoom*sin(w)*p;\nmy_y = zoom*cos(w)*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nrad = rad/d;\nang = ang-instance/num_inst*asin(1)*8;\nr=int(rand(30))/30+instance-instance;\ng=int(rand(30))/30+instance-instance;\nb=int(rand(30))/30+instance-instance;\nr2=int(rand(30))/30+instance-instance;\ng2=int(rand(30))/30+instance-instance;\nb2=int(rand(30))/30+instance-instance;\nborder_r=int(rand(30))/30+instance-instance;\nborder_g=int(rand(30))/30+instance-instance;\nborder_b=int(rand(30))/30+instance-instance;\n\na=int(rand(30))/30+instance-instance;\na2=int(rand(30))/30+instance-instance;\nborder_a=int(rand(30))/30+instance-instance;\nsides=int(rand(30))+instance-instance;\nrad=int(rand(30))/500+instance-instance;\n"},{"baseVals":{"sides":12,"additive":1,"num_inst":512,"y":0.55,"rad":0.0986,"tex_zoom":0.7874,"r":0.2,"g":0.03,"b":0.55,"g2":0,"border_a":0,"enabled":0},"init_eqs_str":"started = 0;\nt1 = 0.412; //seeds for pseudo random generator\nt2 = 0.4563;\nt3 = 0.6452;\nt4 = 0.2565;","frame_eqs_str":"rnd1 = if(equal(instance,0),t1,rnd1);\nrnd2 = if(equal(instance,0),t2,rnd2);\nrnd3 = if(equal(instance,0),t3,rnd3);\nrnd4 = if(equal(instance,0),t4,rnd4);\nrnd1 = 4*rnd1*(1-rnd1);\nrnd2 = 4*rnd2*(1-rnd2);\nrnd3 = 4*rnd3*(1-rnd3);\nrnd4 = 4*rnd4*(1-rnd4);\nt = .6;\nt =  (rnd1+time*t) - int(rnd1+time*t);\nt = t + rnd2*0.1;\nwh = rnd4*asin(1)*4;\nwv = 0.25 + rnd3*0.1;\n\nd = 6; // makes the perspective impact\nzoom = 1;\nl = 1;\n\n// Kardan angles\n\nw1 = q3; // first rotation: clockwise in the desktop pane\nw2 = q4; // rotation around vertical axis\nw3 = q5; // rotation around horizontal axis\n\n\n// definition of the 3D shape\n\ni = instance;\n\nmy_x = t *(cos(wh)*sin(wv)*l)*2;\nmy_z = -(-0.5 +(t-0.75)*(t-0.75))*cos(wv)*l*2;\nmy_y = t*(sin(wh)*sin(wv)*l)*2;\n\n\n\n// 3D rotations\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\np = tan(asin(1) + atan2(d+z3,sqrt(x3*x3 + y3*y3)));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nrad = rad/d;\nmy_x = zoom*sin(atan2(x3,y3))*p;\nmy_y = zoom*cos(atan2(x3,y3))*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;","init_eqs_eel":"started = 0;\nt1 = 0.412; //seeds for pseudo random generator\nt2 = 0.4563;\nt3 = 0.6452;\nt4 = 0.2565;","frame_eqs_eel":"rnd1 = if(equal(instance,0),t1,rnd1);\nrnd2 = if(equal(instance,0),t2,rnd2);\nrnd3 = if(equal(instance,0),t3,rnd3);\nrnd4 = if(equal(instance,0),t4,rnd4);\nrnd1 = 4*rnd1*(1-rnd1);\nrnd2 = 4*rnd2*(1-rnd2);\nrnd3 = 4*rnd3*(1-rnd3);\nrnd4 = 4*rnd4*(1-rnd4);\nt = .6;\nt =  (rnd1+time*t) - int(rnd1+time*t);\nt = t + rnd2*0.1;\nwh = rnd4*asin(1)*4;\nwv = 0.25 + rnd3*0.1;\n\nd = 6; // makes the perspective impact\nzoom = 1;\nl = 1;\n\n// Kardan angles\n\nw1 = q3; // first rotation: clockwise in the desktop pane\nw2 = q4; // rotation around vertical axis\nw3 = q5; // rotation around horizontal axis\n\n\n// definition of the 3D shape\n\ni = instance;\n\nmy_x = t *(cos(wh)*sin(wv)*l)*2;\nmy_z = -(-0.5 +(t-0.75)*(t-0.75))*cos(wv)*l*2;\nmy_y = t*(sin(wh)*sin(wv)*l)*2;\n\n\n\n// 3D rotations\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\np = tan(asin(1) + atan2(d+z3,sqrt(x3*x3 + y3*y3)));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nrad = rad/d;\nmy_x = zoom*sin(atan2(x3,y3))*p;\nmy_y = zoom*cos(atan2(x3,y3))*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;"},{"baseVals":{"sides":12,"additive":1,"num_inst":512,"y":0.55,"rad":0.2667,"tex_zoom":0.7874,"r":0,"g":0.1,"b":0.55,"g2":0,"border_a":0,"enabled":0},"init_eqs_str":"started = 0;\nt1 = 0.412; //seeds for pseudo random generator\nt2 = 0.4563;\nt3 = 0.6452;\nt4 = 0.2565;","frame_eqs_str":"rnd1 = if(equal(instance,0),t1,rnd1);\nrnd2 = if(equal(instance,0),t2,rnd2);\nrnd3 = if(equal(instance,0),t3,rnd3);\nrnd4 = if(equal(instance,0),t4,rnd4);\nrnd1 = 4*rnd1*(1-rnd1);\nrnd2 = 4*rnd2*(1-rnd2);\nrnd3 = 4*rnd3*(1-rnd3);\nrnd4 = 4*rnd4*(1-rnd4);\nt = .6;\nt =  (rnd1+time*t) - int(rnd1+time*t);\nt = t + rnd2*0.1;\nwh = rnd4*asin(1)*4;\nwv = 0.25 + rnd3*0.1;\n\nd = 6; // makes the perspective impact\nzoom = 1;\nl = 1;\n\n// Kardan angles\n\nw1 = q3; // first rotation: clockwise in the desktop pane\nw2 = q4; // rotation around vertical axis\nw3 = q5; // rotation around horizontal axis\n\n\n// definition of the 3D shape\n\ni = instance;\n\nmy_x = t *(cos(wh)*sin(wv)*l)*4;\nmy_z = (-0.5 +(t-0.75)*(t-0.75))*cos(wv)*l*4;\nmy_y = t*(sin(wh)*sin(wv)*l)*4;\n\n\n// 3D rotations\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\np = tan(asin(1) + atan2(d+z3,sqrt(x3*x3 + y3*y3)));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nrad = rad/d;\nmy_x = zoom*sin(atan2(x3,y3))*p;\nmy_y = zoom*cos(atan2(x3,y3))*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;","init_eqs_eel":"started = 0;\nt1 = 0.412; //seeds for pseudo random generator\nt2 = 0.4563;\nt3 = 0.6452;\nt4 = 0.2565;","frame_eqs_eel":"rnd1 = if(equal(instance,0),t1,rnd1);\nrnd2 = if(equal(instance,0),t2,rnd2);\nrnd3 = if(equal(instance,0),t3,rnd3);\nrnd4 = if(equal(instance,0),t4,rnd4);\nrnd1 = 4*rnd1*(1-rnd1);\nrnd2 = 4*rnd2*(1-rnd2);\nrnd3 = 4*rnd3*(1-rnd3);\nrnd4 = 4*rnd4*(1-rnd4);\nt = .6;\nt =  (rnd1+time*t) - int(rnd1+time*t);\nt = t + rnd2*0.1;\nwh = rnd4*asin(1)*4;\nwv = 0.25 + rnd3*0.1;\n\nd = 6; // makes the perspective impact\nzoom = 1;\nl = 1;\n\n// Kardan angles\n\nw1 = q3; // first rotation: clockwise in the desktop pane\nw2 = q4; // rotation around vertical axis\nw3 = q5; // rotation around horizontal axis\n\n\n// definition of the 3D shape\n\ni = instance;\n\nmy_x = t *(cos(wh)*sin(wv)*l)*4;\nmy_z = (-0.5 +(t-0.75)*(t-0.75))*cos(wv)*l*4;\nmy_y = t*(sin(wh)*sin(wv)*l)*4;\n\n\n// 3D rotations\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\np = tan(asin(1) + atan2(d+z3,sqrt(x3*x3 + y3*y3)));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nrad = rad/d;\nmy_x = zoom*sin(atan2(x3,y3))*p;\nmy_y = zoom*cos(atan2(x3,y3))*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;"},{"baseVals":{"sides":12,"additive":1,"num_inst":512,"y":0.55,"rad":0.05012,"tex_zoom":0.7874,"r":0,"g":0.02,"b":0.11,"g2":0,"border_a":0,"enabled":0},"init_eqs_str":"started = 0;\nt1 = 0.412; //seeds for pseudo random generator\nt2 = 0.4563;\nt3 = 0.6452;\nt4 = 0.2565;","frame_eqs_str":"rnd1 = if(equal(instance,0),t1,rnd1);\nrnd2 = if(equal(instance,0),t2,rnd2);\nrnd3 = if(equal(instance,0),t3,rnd3);\nrnd4 = if(equal(instance,0),t4,rnd4);\nrnd1 = 4*rnd1*(1-rnd1);\nrnd2 = 4*rnd2*(1-rnd2);\nrnd3 = 4*rnd3*(1-rnd3);\nrnd4 = 4*rnd4*(1-rnd4);\nt = .6;\nt =  (rnd1+time*t) - int(rnd1+time*t);\nt = t + rnd2*0.1;\nwh = rnd4*asin(1)*4;\nwv = 0.25 + rnd3*0.1;\n\nd = 1.4; // makes the perspective impact\nzoom = 1;\nl = 1;\n\n// Kardan angles\n\nw1 = q3; // first rotation: clockwise in the desktop pane\nw2 = q4; // rotation around vertical axis\nw3 = q5; // rotation around horizontal axis\n\n\n// definition of the 3D shape\n\ni = instance;\n\nmy_x = t *(cos(wh)*sin(wv)*l);\nmy_y = (-0.5 +(t-0.75)*(t-0.75))*cos(wv)*l;\nmy_z = t*(sin(wh)*sin(wv)*l);\n\n\n// 3D rotations\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\np = tan(asin(1) + atan2(d+z3,sqrt(x3*x3 + y3*y3)));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nrad = rad/d;\nmy_x = zoom*sin(atan2(x3,y3))*p;\nmy_y = zoom*cos(atan2(x3,y3))*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;","init_eqs_eel":"started = 0;\nt1 = 0.412; //seeds for pseudo random generator\nt2 = 0.4563;\nt3 = 0.6452;\nt4 = 0.2565;","frame_eqs_eel":"rnd1 = if(equal(instance,0),t1,rnd1);\nrnd2 = if(equal(instance,0),t2,rnd2);\nrnd3 = if(equal(instance,0),t3,rnd3);\nrnd4 = if(equal(instance,0),t4,rnd4);\nrnd1 = 4*rnd1*(1-rnd1);\nrnd2 = 4*rnd2*(1-rnd2);\nrnd3 = 4*rnd3*(1-rnd3);\nrnd4 = 4*rnd4*(1-rnd4);\nt = .6;\nt =  (rnd1+time*t) - int(rnd1+time*t);\nt = t + rnd2*0.1;\nwh = rnd4*asin(1)*4;\nwv = 0.25 + rnd3*0.1;\n\nd = 1.4; // makes the perspective impact\nzoom = 1;\nl = 1;\n\n// Kardan angles\n\nw1 = q3; // first rotation: clockwise in the desktop pane\nw2 = q4; // rotation around vertical axis\nw3 = q5; // rotation around horizontal axis\n\n\n// definition of the 3D shape\n\ni = instance;\n\nmy_x = t *(cos(wh)*sin(wv)*l);\nmy_y = (-0.5 +(t-0.75)*(t-0.75))*cos(wv)*l;\nmy_z = t*(sin(wh)*sin(wv)*l);\n\n\n// 3D rotations\n\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\np = tan(asin(1) + atan2(d+z3,sqrt(x3*x3 + y3*y3)));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nrad = rad/d;\nmy_x = zoom*sin(atan2(x3,y3))*p;\nmy_y = zoom*cos(atan2(x3,y3))*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q1;"}],"waves":[{"baseVals":{"samples":495,"sep":4,"spectrum":1,"thick":1,"additive":1,"scaling":100,"smoothing":1,"a":0.21,"enabled":0},"init_eqs_str":"t2 = 0;\nt3 = 0;\nt4 = 0;\nab = 1;","frame_eqs_str":"","point_eqs_str":"// lorenz-attractor calc\nxx1 = if(equal(sample,0),q11,xx1);\nyy1 = if(equal(sample,0),q12,yy1);\nzz1 = if(equal(sample,0),q13,zz1);\ndx1 = q14*(yy1-xx1);\ndy1 = xx1*(q15-zz1)-yy1;\ndz1 = xx1*yy1-q16*zz1;\nxx1 = xx1 + q17*dx1;\nyy1 = yy1 + q17*dy1;\nzz1 = zz1 + q17*dz1;\n\n// 3D model coordinates\nmy_x = xx1*0.1;\nmy_y = yy1*0.1;\nmy_z = zz1*0.1 - 3;\n\n\nd = 5; // distance of the camera (on the z-axis) to the origin\nzoom = 0.4;\n\n// solid angles\nw1 = q2;\nw2 = q3;\nw3 = q4;\n\n// rotations\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\nl = sqrt(x3*x3 + y3*y3);\nw = atan2(x3,y3);\np = tan(asin(1) + atan2(d+z3,l));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nmy_x = zoom*sin(w)*p;\nmy_y = zoom*cos(w)*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\nab = 1;","frame_eqs_eel":"","point_eqs_eel":"// lorenz-attractor calc\nxx1 = if(equal(sample,0),q11,xx1);\nyy1 = if(equal(sample,0),q12,yy1);\nzz1 = if(equal(sample,0),q13,zz1);\ndx1 = q14*(yy1-xx1);\ndy1 = xx1*(q15-zz1)-yy1;\ndz1 = xx1*yy1-q16*zz1;\nxx1 = xx1 + q17*dx1;\nyy1 = yy1 + q17*dy1;\nzz1 = zz1 + q17*dz1;\n\n// 3D model coordinates\nmy_x = xx1*0.1;\nmy_y = yy1*0.1;\nmy_z = zz1*0.1 - 3;\n\n\nd = 5; // distance of the camera (on the z-axis) to the origin\nzoom = 0.4;\n\n// solid angles\nw1 = q2;\nw2 = q3;\nw3 = q4;\n\n// rotations\nx1 = cos(w1)*my_x + sin(w1)*my_y;\ny1 = -sin(w1)*my_x + cos(w1)*my_y;\nz1 = my_z;\n\nx2 = cos(w2)*x1 + sin(w2)*z1;\nz2 = -sin(w2)*x1 + cos(w2)*z1;\ny2 = y1;\n\ny3 = cos(w3)*y2 + sin(w3)*z2;\nz3 = -sin(w3)*y2 + cos(w3)*z2;\nx3 = x2;\n\n// perspective calculation\n\nl = sqrt(x3*x3 + y3*y3);\nw = atan2(x3,y3);\np = tan(asin(1) + atan2(d+z3,l));\nd = sqrt(x3*x3 + y3*y3 + (z3+d)*(z3+d));\n\nmy_x = zoom*sin(w)*p;\nmy_y = zoom*cos(w)*p;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;"},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"xx1 = if(equal(sample,0),q11,xx1);\nyy1 = if(equal(sample,0),q12,yy1);\nzz1 = if(equal(sample,0),q13,zz1);\n\ndx1 = q14*(yy1-xx1);\ndy1 = xx1*(q15-zz1)-yy1;\ndz1 = xx1*yy1-q16*zz1;\nxx1 = xx1 + q17*dx1;\nyy1 = yy1 + q17*dy1;\nzz1 = zz1 + q17*dz1;\n\nmy_x = xx1*0.02;\nmy_y = yy1*0.02;\nmy_z = zz1*0.02;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":"xx1 = if(equal(sample,0),q11,xx1);\nyy1 = if(equal(sample,0),q12,yy1);\nzz1 = if(equal(sample,0),q13,zz1);\n\ndx1 = q14*(yy1-xx1);\ndy1 = xx1*(q15-zz1)-yy1;\ndz1 = xx1*yy1-q16*zz1;\nxx1 = xx1 + q17*dx1;\nyy1 = yy1 + q17*dy1;\nzz1 = zz1 + q17*dz1;\n\nmy_x = xx1*0.02;\nmy_y = yy1*0.02;\nmy_z = zz1*0.02;\n\nx = 0.5 + my_x;\ny = 0.5 + my_y;"},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.d=0;a.n=0;a.cx1=0;a.y3=0;a.y1=0;a.n2=0;a.cy1=0;a.q12=0;a.x1=0;a.q13=0;a.q15=0;a.j3=0;a.dy1=0;a.q1=0;a.q5=0;a.n1=0;a.dz1=0;a.v=0;a.x3=0;a.q11=0;a.dd=0;a.q4=0;a.a=0;a.j2=0;a.dir=0;a.q16=0;a.b=0;a.x2=0;a.q17=0;a.y2=0;a.dx1=0;a.j1=0;a.q2=0;a.q14=0;a.z1=0;a.q3=0;a.c=0;a.x1=2;a.y1=2;a.z1=2;","frame_eqs_str":"a.q1=a.aspectx;a.q2=a.aspecty;a.wave_a=0;a.v=.5;a.j1=.95*a.j1+sqr(4*a.bass)*a.v;a.j2=.95*a.j2+sqr(4*a.mid)*a.v;a.j3=.95*a.j3+sqr(4*a.treb)*a.v;a.n+=.0052*a.j1;a.n1+=.0052*a.j2;a.n2+=.0052*a.j3;a.q3=.01*a.n;a.q4=.01*a.n1;a.q5=.01*a.n2;a.a=10;a.b=28;a.c=div(8,3);a.dx1=a.a*(a.y1-a.x1);a.dy1=a.x1*(a.b-a.z1)-a.y1;a.dz1=a.x1*a.y1-a.c*a.z1;a.d=1;a.dd=sqrt(a.dx1*a.dx1+a.dy1*a.dy1+a.dz1*a.dz1);a.x1+=div(a.d*a.dx1,a.dd);a.y1+=div(a.d*a.dy1,a.dd);a.z1+=div(a.d*a.dz1,a.dd);a.q11=a.x1;a.q12=\na.y1;a.q13=a.z1;a.q14=a.a;a.q15=a.b;a.q16=a.c;a.q17=a.d;","pixel_eqs_str":"a.cx1=.5+.2*Math.sin(.618*a.time);a.cy1=.5+.2*Math.cos(1.618*a.time);a.dir=a.bass;a.d=sqrt((a.x-a.cx1)*(a.x-a.cx1)+(a.y-a.cy1)*(a.y-a.cy1));a.x1=.00001<Math.abs(above(a.d,.3))?0:.05*Math.sin(a.y-a.cy1)*a.dir;a.y1=.00001<Math.abs(above(a.d,.3))?0:.05*-Math.sin(a.x-a.cx1)*a.dir;a.cx1=.5+.3*Math.sin(2.618*a.time);a.cy1=.5+.3*Math.cos(3.14*a.time);a.dir=2*-a.mid;a.d=sqrt((a.x-a.cx1)*(a.x-a.cx1)+(a.y-a.cy1)*(a.y-a.cy1));a.x2=.00001<Math.abs(above(a.d,.2))?0:.05*Math.sin(a.y-a.cy1)*\na.dir;a.y2=.00001<Math.abs(above(a.d,.2))?0:.05*-Math.sin(a.x-a.cx1)*a.dir;a.cx1=.5+.4*Math.sin(2.618*-a.time);a.cy1=.5+.4*Math.cos(1.14*-a.time);a.dir=3*a.treb;a.d=sqrt((a.x-a.cx1)*(a.x-a.cx1)+(a.y-a.cy1)*(a.y-a.cy1));a.x3=.00001<Math.abs(above(a.d,.1))?0:.05*Math.sin(a.y-a.cy1)*a.dir;a.y3=.00001<Math.abs(above(a.d,.1))?0:.05*-Math.sin(a.x-a.cx1)*a.dir;a.dx=a.dx+a.x1+a.x2+a.x3;a.dy=a.dy+a.y1+a.y2+a.y3;","init_eqs_eel":"x1 = 2;\ny1= 2;\nz1 = 2;","frame_eqs_eel":"q1 = aspectx;\nq2 = aspecty;\nwave_a = 0;\nv = 0.5;\nj1 = j1*0.95 + sqr(bass*4)*v;\nj2 = j2*0.95 + sqr(mid*4)*v;\nj3 = j3*0.95 + sqr(treb*4)*v;\n\nn = n + j1*0.0052;\nn1 = n1 + j2*0.0052;\nn2 = n2 + j3*0.0052;\n\n\nq3 = n*0.01; // passing the 3 room angles\nq4 = n1*0.01;\nq5 = n2*0.01;\n\n\n// lorenz-attractor calc\na = 10;\nb = 28;\nc = 8/3;\ndx1 = a*(y1-x1);\ndy1 = x1*(b-z1)-y1;\ndz1 = x1*y1-c*z1;\nd = 1;\ndd = sqrt(dx1*dx1 + dy1*dy1 + dz1*dz1);\nx1 = x1 + d*dx1/dd;\ny1 = y1 + d*dy1/dd;\nz1 = z1 + d*dz1/dd;\n\nq11 = x1;\nq12 = y1;\nq13 = z1;\nq14 = a;\nq15 = b;\nq16 = c;\nq17 = d;","pixel_eqs_eel":"cx1 = 0.5+sin(time*0.618)*0.2;\ncy1 = 0.5+cos(time*1.618)*0.2;\n\ndir = bass;\n\nd = sqrt((x-cx1)*(x-cx1)+(y-cy1)*(y-cy1));\n\nx1 = if( above(d,0.3),0,  sin(y-cy1)*0.05*dir);\ny1 = if( above(d,0.3),0, -sin(x-cx1)*0.05*dir);\n\n\ncx1 = 0.5+sin(time*2.618)*0.3;\ncy1 = 0.5+cos(time*3.14)*0.3;\n\ndir = -mid*2;\n\nd = sqrt((x-cx1)*(x-cx1)+(y-cy1)*(y-cy1));\n\nx2 = if( above(d,0.2),0,  sin(y-cy1)*0.05*dir);\ny2 = if( above(d,0.2),0, -sin(x-cx1)*0.05*dir);\n\ncx1 = 0.5+sin(-time*2.618)*0.4;\ncy1 = 0.5+cos(-time*1.14)*0.4;\n\ndir = treb*3;\n\nd = sqrt((x-cx1)*(x-cx1)+(y-cy1)*(y-cy1));\n\nx3 = if( above(d,0.1),0,  sin(y-cy1)*0.05*dir);\ny3 = if( above(d,0.1),0, -sin(x-cx1)*0.05*dir);\n\n\ndx = dx+x1+x2+x3;\ndy = dy+y1+y2+y3;","warp":" shader_body { \n  vec4 tmpvar_1;\n  tmpvar_1 = texture (sampler_main, uv);\n  vec3 tmpvar_2;\n  tmpvar_2.z = 0.0;\n  tmpvar_2.xy = abs((uv - uv_orig));\n  float tmpvar_3;\n  tmpvar_3 = ((dot (tmpvar_2, vec3(0.32, 0.49, 0.29)) * 0.6) + 0.003);\n  vec2 tmpvar_4;\n  tmpvar_4.x = (uv.x - tmpvar_3);\n  tmpvar_4.y = uv.y;\n  vec2 tmpvar_5;\n  tmpvar_5.x = (uv.x - tmpvar_3);\n  tmpvar_5.y = (uv.y + tmpvar_3);\n  vec2 tmpvar_6;\n  tmpvar_6.x = uv.x;\n  tmpvar_6.y = (uv.y - tmpvar_3);\n  vec2 tmpvar_7;\n  tmpvar_7.x = uv.x;\n  tmpvar_7.y = (uv.y + tmpvar_3);\n  vec2 tmpvar_8;\n  tmpvar_8.x = (uv.x + tmpvar_3);\n  tmpvar_8.y = (uv.y - tmpvar_3);\n  vec2 tmpvar_9;\n  tmpvar_9.x = (uv.x + tmpvar_3);\n  tmpvar_9.y = uv.y;\n  vec3 tmpvar_10;\n  tmpvar_10 = clamp (max (max (\n    max (abs((tmpvar_1.xyz - texture (sampler_main, (uv - vec2(tmpvar_3))).xyz)), abs((tmpvar_1.xyz - texture (sampler_main, tmpvar_4).xyz)))\n  , \n    max (abs((tmpvar_1.xyz - texture (sampler_main, tmpvar_5).xyz)), abs((tmpvar_1.xyz - texture (sampler_main, tmpvar_6).xyz)))\n  ), max (\n    max (max (abs((tmpvar_1.xyz - tmpvar_1.xyz)), abs((tmpvar_1.xyz - texture (sampler_main, tmpvar_7).xyz))), max (abs((tmpvar_1.xyz - texture (sampler_main, tmpvar_8).xyz)), abs((tmpvar_1.xyz - texture (sampler_main, tmpvar_9).xyz))))\n  , \n    abs((tmpvar_1.xyz - texture (sampler_main, (uv + vec2(tmpvar_3))).xyz))\n  )), 0.0, 1.0);\n  vec4 tmpvar_11;\n  tmpvar_11.w = 1.0;\n  tmpvar_11.xyz = ((tmpvar_10 + (texture (sampler_main, \n    (uv + (tmpvar_10.xy * 0.01))\n  ).xyz * 0.8)) / 1.4);\n  ret = tmpvar_11.xyz;\n }","comp":" shader_body { \n  vec3 ret_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = rad;\n  tmpvar_2.y = uv.y;\n  ret_1 = (texture (sampler_main, tmpvar_2).xyz + ((texture (sampler_blur1, tmpvar_2).xyz * scale1) + bias1));\n  vec3 tmpvar_3;\n  tmpvar_3.x = bass;\n  tmpvar_3.y = mid;\n  tmpvar_3.z = treb;\n  ret_1 = (ret_1 * (tmpvar_3 * 0.8));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = ret_1;\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{ret=GetPixel(uv);\nfloat d=lum(abs(uv-uv_orig))*0.6+0.003;\nfloat3 one,two,three,four,five;\nfloat3 sex,drugs,rock,roll,bugs;\nfloat3 maxx;\none=max(\nabs(ret-GetPixel(float2(uv.x-d,uv.y-d))),\nabs(ret-GetPixel(float2(uv.x-d,uv.y)))\n);\ntwo=max(\nabs(ret-GetPixel(float2(uv.x-d,uv.y+d))),\nabs(ret-GetPixel(float2(uv.x,uv.y-d)))\n);\nthree=max(\nabs(ret-GetPixel(float2(uv.x,uv.y))),\nabs(ret-GetPixel(float2(uv.x,uv.y+d)))\n);\nfour=max(\nabs(ret-GetPixel(float2(uv.x+d,uv.y-d))),\nabs(ret-GetPixel(float2(uv.x+d,uv.y)))\n);\nfive=abs(ret-GetPixel(float2(uv.x+d,uv.y+d)));\nsex=abs(one-ret);\ndrugs=abs(two-ret);\nrock=abs(three-ret);\nroll=abs(four-ret);\nbugs=abs(five-ret);\nmaxx=max(one,max(two,max(three,max(four,five))));\nmaxx=saturate(maxx);\nret=maxx;\nret=(ret+GetPixel(uv+ret.xy*0.01)*0.8)/1.4;\n}","comp_hlsl":"shader_body\n{\n    //uv = lerp(uv, float2(rad,uv.x), roam_cos.x);\n    //uv = lerp(uv, float2(uv.y,rad), roam_cos.y);\n    uv = float2(rad,uv.y);\n\n    ret = tex2D(sampler_main, uv).xyz;\n    ret += GetBlur1(uv);\n    ret *= float3(bass,mid,treb)*0.8;    \n}"}