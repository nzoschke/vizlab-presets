{"version":2,"baseVals":{"rating":5,"warp":0.01,"mv_a":0},"shapes":[{"baseVals":{"enabled":1,"rad":0.26252,"ang":0.75398,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.15*Math.sin(a.time);a.y=.5+sign(Math.sin(1.57+a.time))*sqrt(.0225-(a.x-.5)*(a.x-.5));","init_eqs_eel":"","frame_eqs_eel":"x=.5+.15*sin(time);\ny=.5+sign(sin(1.57+time))*sqrt(.0225-(x-.5)*(x-.5));"},{"baseVals":{"enabled":1,"sides":100,"rad":0.40508,"g":1,"b":1,"r2":1,"b2":1,"a2":0.5,"border_a":1},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.2*Math.sin(a.time);a.y=.5-sign(Math.sin(1.57+a.time))*sqrt(.04-(a.x-.5)*(a.x-.5));a.textured=1.5*Math.sin(.1*a.time);","init_eqs_eel":"","frame_eqs_eel":"x=.5+.2*sin(time);\ny=.5-sign(sin(1.57+time))*sqrt(.04-(x-.5)*(x-.5));\ntextured=1.5*sin(.1*time);\n"},{"baseVals":{"enabled":1,"sides":100,"rad":0.28428,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.3*Math.sin(.2*a.time);a.y=.5+sign(Math.sin(1.57+.2*a.time))*sqrt(.09-(a.x-.5)*(a.x-.5));","init_eqs_eel":"","frame_eqs_eel":"x=.5+.3*sin(.2*time);\ny=.5+sign(sin(1.57+.2*time))*sqrt(.09-(x-.5)*(x-.5));"},{"baseVals":{"enabled":1,"sides":100,"rad":0.02716,"r":0.22,"g":0.44,"b":0.71,"g2":0.2,"b2":0.3,"a2":1,"border_r":0.9,"border_g":0.9,"border_a":0},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.4*Math.sin(.21*a.time);a.y=.5+sign(Math.sin(1.57+.21*a.time))*sqrt(.16-(a.x-.5)*(a.x-.5));","init_eqs_eel":"","frame_eqs_eel":"x=.5+.4*sin(.21*time);\ny=.5+sign(sin(1.57+.21*time))*sqrt(.16-(x-.5)*(x-.5));"}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.angle=0;a.q31=0;a.q32=0;","frame_eqs_str":"a.warp=0;a.wave_a=0;a.angle=3.14+3*Math.sin(.02*a.time);a.q31=Math.sin(a.angle);a.q32=Math.cos(a.angle);a.monitor=a.angle;","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"warp = 0;\nwave_a = 0;\n\n//Here we define the rotation. The 'angle' is in the range of 0...2*Pi\n//We do this in the per-frame section because sin/cos functions cost a lot of shader operations:\nangle=3.14+3*sin(.02*time);\nq31 = sin(angle);\nq32 = cos(angle);\n\nmonitor=angle;","pixel_eqs_eel":"","warp":" shader_body { \n  vec2 uv_1;\n  vec2 uv6_2;\n  vec2 tmpvar_3;\n  tmpvar_3 = ((uv - 0.5) * aspect.xy);\n  uv_1 = (uv - ((-0.002 * \n    ((texture (sampler_blur1, uv).xyz * scale1) + bias1)\n  ).xy * normalize(tmpvar_3)));\n  uv6_2 = (0.4 * sin((tmpvar_3 * 34.0)));\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = (((\n    (texture (sampler_main, uv_1).xyz - (((texture (sampler_blur2, \n      fract(uv_1)\n    ).xyz * scale2) + bias2) * 0.03))\n   + \n    (vec3((0.05 / sqrt(dot (uv6_2, uv6_2)))) * vec3(0.15, 0.12, 0.075))\n  ) * 0.95) - 0.02);\n  ret = tmpvar_4.xyz;\n }","comp":" shader_body { \n  vec2 uv2_2;\n  vec3 ret_3;\n  ret_3 = texture (sampler_main, uv).xyz;\n  uv2_2 = uv;\n  for (int n_1 = 1; n_1 <= 10; n_1++) {\n    uv2_2 = (uv2_2 - 0.5);\n    vec2 tmpvar_4;\n    tmpvar_4.x = ((uv2_2.x * q32) - (uv2_2.y * q31));\n    tmpvar_4.y = ((uv2_2.x * q31) + (uv2_2.y * q32));\n    uv2_2 = (tmpvar_4 + 0.5);\n    ret_3 = abs((ret_3 - texture (sampler_main, uv2_2).xyz));\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.w = 1.0;\n  tmpvar_5.xyz = ret_3;\n  ret = tmpvar_5.xyz;\n }","warp_hlsl":"sampler sampler_worms;\nfloat3 color, mus;\nfloat dx,dy;\nshader_body {\nfloat2 uv1 = (uv-.5) * aspect.xy;\n\n\nfloat2 uv6 = uv1;\nfloat2 d = normalize(uv1);\nuv -= -.002*GetBlur1(uv)*d;\n\n\nuv6 = .4*sin(uv1*34);\nmus = .05/(length(uv6));\nmus *= float3 (1,.8,.5) ;\n\nfloat3 blur = GetBlur2(frac(uv));\n\nfloat3 crisp= tex2D(sampler_main,uv);\n\nfloat3 ret1 = crisp - blur*.03 + .15*mus;\n\nret = ret1*.95-.02;\n\n}","comp_hlsl":"shader_body\n{\n\n//As a base, sample the main sampler at normal uv coordinates and store as return value:\nret = tex2D(sampler_main, uv).xyz;\n\n//Define the translation in (x,y)-direction and multiply by texsize.zw to convert the length to pixels:\nfloat2 shift = float2(0,0)*texsize.zw; \n\n//Take the original uv coordinates as a starting point, store in second set of coordinates:\nfloat2 uv2 = uv;\n\n//Start iterations...\nint n = 1;\nwhile (n<=10) {\n\n//First step: put origin in center;\nuv2 = uv2-.5;\n\n//Next, rotate by a factor we set in the per-frame equations - q32 is cos(angle) and q31 is sin(angle): \nuv2 = float2((uv2.x)*q32 - (uv2.y) * q31,(uv2.x)* q31 + (uv2.y) * q32)+.5;\n\n//Then, shift uv coordinates n times - see the step after the next as to why:\nuv2 += n*shift;\n\n//Sample the main sampler at our new uv2 coordinates, \n//deduct the result from the current return value, \n//store in ret as absolute (difference) value:\nret = abs(ret-GetPixel(uv2));\n\n//Remove the shift so we won't rotate it with our coordinates in the next iteration:\nuv2 -= n*shift;\n\n//Iteration +1\nn++;\n}\n\n}"}