{"version":2,"baseVals":{"rating":5,"wrap":0,"warp":0.01,"mv_a":0},"shapes":[{"baseVals":{"enabled":1,"rad":0.262525,"ang":0.75398,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.15*Math.sin(a.time);a.y=.5+sign(Math.sin(1.57+a.time))*sqrt(.0225-(a.x-.5)*(a.x-.5));","init_eqs_eel":"","frame_eqs_eel":"x=.5+.15*sin(time);\ny=.5+sign(sin(1.57+time))*sqrt(.0225-(x-.5)*(x-.5));"},{"baseVals":{"enabled":1,"sides":100,"rad":0.405085,"g":1,"b":1,"r2":1,"b2":1,"a2":0.5,"border_a":1},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.2*Math.sin(a.time);a.y=.5-sign(Math.sin(1.57+a.time))*sqrt(.04-(a.x-.5)*(a.x-.5));a.textured=1.5*Math.sin(.1*a.time);","init_eqs_eel":"","frame_eqs_eel":"x=.5+.2*sin(time);\ny=.5-sign(sin(1.57+time))*sqrt(.04-(x-.5)*(x-.5));\ntextured=1.5*sin(.1*time);\n"},{"baseVals":{"enabled":1,"sides":100,"rad":0.284277,"g":1,"b":1,"r2":1,"b2":1,"a2":1,"border_a":0},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.3*Math.sin(.2*a.time);a.y=.5+sign(Math.sin(1.57+.2*a.time))*sqrt(.09-(a.x-.5)*(a.x-.5));","init_eqs_eel":"","frame_eqs_eel":"x=.5+.3*sin(.2*time);\ny=.5+sign(sin(1.57+.2*time))*sqrt(.09-(x-.5)*(x-.5));"},{"baseVals":{"enabled":1,"sides":100,"rad":0.027158,"r":0.22,"g":0.44,"b":0.71,"g2":0.2,"b2":0.3,"a2":1,"border_r":0.9,"border_g":0.9,"border_a":0},"init_eqs_str":"","frame_eqs_str":"a.x=.5+.4*Math.sin(.21*a.time);a.y=.5+sign(Math.sin(1.57+.21*a.time))*sqrt(.16-(a.x-.5)*(a.x-.5));","init_eqs_eel":"","frame_eqs_eel":"x=.5+.4*sin(.21*time);\ny=.5+sign(sin(1.57+.21*time))*sqrt(.16-(x-.5)*(x-.5));"}],"waves":[{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.angle=0;a.q31=0;a.q32=0;","frame_eqs_str":"a.warp=0;a.wave_a=0;a.angle=3.14+3*Math.sin(.02*a.time);a.q31=Math.sin(a.angle);a.q32=Math.cos(a.angle);a.monitor=a.angle;","pixel_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"warp = 0;\nwave_a = 0;\n\n//Here we define the rotation. The 'angle' is in the range of 0...2*Pi\n//We do this in the per-frame section because sin/cos functions cost a lot of shader operations:\nangle=3.14+3*sin(.02*time);\nq31 = sin(angle);\nq32 = cos(angle);\n\nmonitor=angle;","pixel_eqs_eel":"","warp":" shader_body { \n  vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xyz = (texture (sampler_fc_main, uv).xyz * 0.9);\n  ret = tmpvar_1.xyz;\n }","comp":" shader_body { \n  vec2 uv2_2;\n  vec3 ret_3;\n  ret_3 = texture (sampler_main, uv).xyz;\n  uv2_2 = uv;\n  for (int n_1 = 1; n_1 <= 10; n_1++) {\n    uv2_2 = (uv2_2 - 0.5);\n    vec2 tmpvar_4;\n    tmpvar_4.x = ((uv2_2.x * q32) - (uv2_2.y * q31));\n    tmpvar_4.y = ((uv2_2.x * q31) + (uv2_2.y * q32));\n    uv2_2 = (tmpvar_4 + 0.5);\n    ret_3 = abs((ret_3 - texture (sampler_main, uv2_2).xyz));\n  };\n  vec4 tmpvar_5;\n  tmpvar_5.w = 1.0;\n  tmpvar_5.xyz = ret_3;\n  ret = tmpvar_5.xyz;\n }","warp_hlsl":"shader_body\n{\n    // sample previous frame\n    ret = tex2D( sampler_fc_main, uv ).xyz;\n    \n    // darken (decay) over time\n    ret *= 0.9; //or try: ret -= 0.004;\n}","comp_hlsl":"shader_body\n{\n\n//As a base, sample the main sampler at normal uv coordinates and store as return value:\nret = tex2D(sampler_main, uv).xyz;\n\n//Define the translation in (x,y)-direction and multiply by texsize.zw to convert the length to pixels:\nfloat2 shift = float2(0,0)*texsize.zw; \n\n//Take the original uv coordinates as a starting point, store in second set of coordinates:\nfloat2 uv2 = uv;\n\n//Start iterations...\nint n = 1;\nwhile (n<=10) {\n\n//First step: put origin in center;\nuv2 = uv2-.5;\n\n//Next, rotate by a factor we set in the per-frame equations - q32 is cos(angle) and q31 is sin(angle): \nuv2 = float2((uv2.x)*q32 - (uv2.y) * q31,(uv2.x)* q31 + (uv2.y) * q32)+.5;\n\n//Then, shift uv coordinates n times - see the step after the next as to why:\nuv2 += n*shift;\n\n//Sample the main sampler at our new uv2 coordinates, \n//deduct the result from the current return value, \n//store in ret as absolute (difference) value:\nret = abs(ret-GetPixel(uv2));\n\n//Remove the shift so we won't rotate it with our coordinates in the next iteration:\nuv2 -= n*shift;\n\n//Iteration +1\nn++;\n}\n\n}"}