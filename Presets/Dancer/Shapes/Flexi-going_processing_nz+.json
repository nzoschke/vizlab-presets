{"version":2,"baseVals":{"rating":5,"gammaadj":1,"wave_thick":1,"wrap":0,"wave_a":0.004,"wave_scale":0.037,"wave_smoothing":0,"wave_mystery":-0.44,"modwavealphastart":1,"modwavealphaend":1,"warpanimspeed":0.803,"warpscale":1.22,"zoomexp":1.50374,"warp":0.31218,"wave_y":0.04,"ob_size":0.005,"ob_a":1,"ib_size":0,"ib_r":1,"ib_g":0,"ib_b":0.75,"ib_a":1,"mv_x":64,"mv_y":48,"mv_l":0,"mv_b":0,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"enabled":1,"sides":100,"additive":1,"num_inst":100,"rad":0.01,"ang":3.20442,"tex_zoom":6.23873,"g":1,"b":1,"a":0.62,"r2":1,"b2":1,"border_a":1},"init_eqs_str":"a.index=0;a.q32=0;a.q2=0;","frame_eqs_str":"a.index=a.instance*a.q32;a.x=a.gmegabuf[Math.floor(a.index)];a.y=a.gmegabuf[Math.floor(a.index+1)];a.rad=2*a.gmegabuf[Math.floor(a.index+4)];a.r=a.gmegabuf[Math.floor(a.index+5)];a.g=a.gmegabuf[Math.floor(a.index+6)];a.b=a.gmegabuf[Math.floor(a.index+7)];a.r2=a.r;a.g2=a.g;a.b2=a.b;a.x=.5+div(a.x-.5,a.q2);","init_eqs_eel":"","frame_eqs_eel":"index = instance*q32;\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\n\nrad = gmegabuf(index+4)*2;\n\nr = gmegabuf(index+5);\ng = gmegabuf(index+6);\nb = gmegabuf(index+7);\n\nr2 = r; g2 = g; b2 = b;\n\n\nx = 0.5 + (x-0.5)/q2;"},{"baseVals":{"sides":100,"additive":1,"thickoutline":1,"textured":1,"x":0.74,"y":0.27,"rad":0.64927,"ang":3.83274,"tex_zoom":0.81948,"g":1,"g2":0,"a2":1,"border_a":0,"enabled":0},"init_eqs_str":"vx = 0","frame_eqs_str":"","init_eqs_eel":"vx = 0","frame_eqs_eel":""},{"baseVals":{"sides":100,"additive":1,"thickoutline":1,"textured":1,"rad":0.33,"tex_zoom":0.73458,"r":0,"g":1,"border_a":0,"enabled":0},"init_eqs_str":"vx = 0","frame_eqs_str":"","init_eqs_eel":"vx = 0","frame_eqs_eel":""},{"baseVals":{"sides":64,"additive":1,"thickoutline":1,"rad":0.16283,"ang":0.75398,"tex_zoom":0.73458,"r":0,"g":1,"border_a":0,"enabled":0},"init_eqs_str":"vx = 0","frame_eqs_str":"","init_eqs_eel":"vx = 0","frame_eqs_eel":""}],"waves":[{"baseVals":{"enabled":1,"samples":452,"additive":1,"scaling":2.44415,"smoothing":0,"a":0.57},"init_eqs_str":"a.ppo=0;a.index=0;a.t1=0;a.nnindex=0;a.nnnx=0;a.nny=0;a.nindex=0;a.nnnindex=0;a.t2=0;a.nnx=0;a.ny=0;a.q2=0;a.q32=0;a.nx=0;a.nnny=0;a.t2=0;a.t3=0;a.t4=0;a.cl=0;","frame_eqs_str":"a.t1=0;a.t2=0;","point_eqs_str":"a.ppo=9;a.index=a.t2*a.q32;a.sample=mod(a.t1,a.ppo);a.nindex=a.gmegabuf[Math.floor(a.index+10)]*a.q32;a.nnindex=a.gmegabuf[Math.floor(a.index+11)]*a.q32;a.nnnindex=a.gmegabuf[Math.floor(a.index+12)]*a.q32;a.x=a.gmegabuf[Math.floor(a.index)];a.y=a.gmegabuf[Math.floor(a.index+1)];a.r=.5+.5*a.gmegabuf[Math.floor(a.index+5)];a.g=.5+.5*a.gmegabuf[Math.floor(a.index+6)];a.b=.5+.5*a.gmegabuf[Math.floor(a.index+7)];a.nx=a.gmegabuf[Math.floor(a.nindex)];a.ny=a.gmegabuf[Math.floor(a.nindex+\n1)];a.nnx=a.gmegabuf[Math.floor(a.nnindex)];a.nny=a.gmegabuf[Math.floor(a.nnindex+1)];a.nnnx=a.gmegabuf[Math.floor(a.nnnindex)];a.nnny=a.gmegabuf[Math.floor(a.nnnindex+1)];a.x=.5+div(a.x-.5,a.q2);a.y=.5+div(a.y-.5,a.q2);a.nx=.5+div(a.nx-.5,a.q2);a.ny=.5+div(a.ny-.5,a.q2);a.nnx=.5+div(a.nnx-.5,a.q2);a.nny=.5+div(a.nny-.5,a.q2);a.nnnx=.5+div(a.nnnx-.5,a.q2);a.nnny=.5+div(a.nnny-.5,a.q2);a.x=.00001<Math.abs(equal(a.sample,2))?a.nx:a.x;a.y=.00001<Math.abs(equal(a.sample,2))?a.ny:a.y;a.x=.00001<Math.abs(equal(a.sample,\n4))?a.nnx:a.x;a.y=.00001<Math.abs(equal(a.sample,4))?a.nny:a.y;a.x=.00001<Math.abs(equal(a.sample,6))?a.nnnx:a.x;a.y=.00001<Math.abs(equal(a.sample,6))?a.nnny:a.y;a.a*=above(a.sample,1)*below(a.sample,a.ppo-1);a.t1+=1;a.t2=.00001<Math.abs(equal(mod(a.t1,a.ppo),0))?a.t2+1:a.t2;","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t1 = 0;\nt2 = 0;","point_eqs_eel":"ppo = 9;\nindex = t2*q32;\nsample = t1 % ppo;\n\nnindex = gmegabuf(index + 10)*q32; // the next neighbor's index\nnnindex = gmegabuf(index + 11)*q32; // the next neighbor's index\nnnnindex = gmegabuf(index + 12)*q32; // the next neighbor's index\n\nx = gmegabuf(index);\ny = gmegabuf(index+1);\nr = 0.5 + gmegabuf(index+5)*0.5;\ng = 0.5 + gmegabuf(index+6)*0.5;\nb = 0.5 + gmegabuf(index+7)*0.5;\n\nnx = gmegabuf(nindex);\nny = gmegabuf(nindex+1);\nnnx = gmegabuf(nnindex);\nnny = gmegabuf(nnindex+1);\nnnnx = gmegabuf(nnnindex);\nnnny = gmegabuf(nnnindex+1);\n\nx = 0.5 + (x-0.5)/q2;\ny = 0.5 + (y-0.5)/q2;\nnx = 0.5 + (nx-0.5)/q2;\nny = 0.5 + (ny-0.5)/q2;\nnnx = 0.5 + (nnx-0.5)/q2;\nnny = 0.5 + (nny-0.5)/q2;\nnnnx = 0.5 + (nnnx-0.5)/q2;\nnnny = 0.5 + (nnny-0.5)/q2;\n\nx = if( equal(sample,2), nx, x);\ny = if( equal(sample,2), ny, y);\nx = if( equal(sample,4), nnx, x);\ny = if( equal(sample,4), nny, y);\nx = if( equal(sample,6), nnnx, x);\ny = if( equal(sample,6), nnny, y);\n\na = above(sample,1)*below(sample,ppo-1)*a;\n\nt1 = t1 + 1;\nt2 = if( equal(t1%ppo,0), t2 +1, t2);"},{"baseVals":{"scaling":7.7518,"smoothing":0,"a":0.21,"enabled":0},"init_eqs_str":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_str":"t8 = 1;\n\nt1 = 0.5;\nt2 = 0.9;","point_eqs_str":"d = d*0.85 + (value1)*1;\n\nx = 0.5 + d*sample*(1-sample);\ny = 0.9 - sample*0.8;","init_eqs_eel":"t2 = 0;\nt3 = 0;\nt4 = 0;\ncl = 0;","frame_eqs_eel":"t8 = 1;\n\nt1 = 0.5;\nt2 = 0.9;","point_eqs_eel":"d = d*0.85 + (value1)*1;\n\nx = 0.5 + d*sample*(1-sample);\ny = 0.9 - sample*0.8;"},{"baseVals":{"samples":280,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.5,"enabled":0},"init_eqs_str":"","frame_eqs_str":"t1 = 0;\nt2 = 0;\n\n","point_eqs_str":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0; \nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d; \n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0.5 + gmegabuf(index + 5)*0.5;\ng = 0.5 + gmegabuf(index + 6)*0.5;\nb = 0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);","init_eqs_eel":"","frame_eqs_eel":"t1 = 0;\nt2 = 0;\n\n","point_eqs_eel":"// q32 number of attributes\n// q31 number of objects\n\nppo = 7; // number of points used for each object\nindex = t2*q32; // object's index\n\nx = 0.5 +(gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\n\n// collecting pairs of index and distance to the current object in a local buffer\ni = 0;\nj = 0; \nloop(q31,\n     d = sqrt( sqr(gmegabuf(index)-gmegabuf(i)) + sqr(gmegabuf(index+1)-gmegabuf(i+1)));\n     d = if( equal(d,0), 1, d);\n     megabuf(j)   = i; // store index/distance pairs\n     megabuf(j+1) = d; \n     j = j+2;\n     i = i+q32;\n    );\n\n// sort that buffer, but only 5 cycles for the 5 nearest objects\ni = 0;\nloop( 5,\n      j = i;\n      smallestfind = 100;\n      findindex = 0;\n      loop( q31-j,\n            distance =megabuf(j*2+1);\n            smaller = above( smallestfind, distance);\n            smallestfind = if(smaller, distance, smallestfind);\n            findindex = if( smaller, j*2, findindex);\n            j = j + 1;\n          );\n\n      // now that the nearest object was found, swap it to the buffer's top\n\n      j = megabuf(i);\n      d = megabuf(i+1);\n\n      megabuf(i)   = megabuf(findindex);\n      megabuf(i+1) = megabuf(findindex+1);\n      megabuf(findindex)   = j;\n      megabuf(findindex+1) = d;\n\n      i = i+1;\n    );\n\n\nindex2 = (t1)%ppo;\ni = megabuf(index2-2);\nxx = 0.5 + (gmegabuf(i)-0.5)/q2;\nyy = 0.5 + (gmegabuf(i+1)-0.5)/q2;\nw = asin(1)*index2/4;\n//xx = x + sin(w)*0.1;\n//yy = y + cos(w)*0.1;\nx = if( equal(index2%2,0), x, xx);\ny = if( equal(index2%2,0), y, yy);\n\n\na = below(index2,ppo-1)*above(index2,1)*a;\nr = 0.5 + gmegabuf(index + 5)*0.5;\ng = 0.5 + gmegabuf(index + 6)*0.5;\nb = 0.5 + gmegabuf(index + 7)*0.5;\n\n\nt2 = t2 + equal(t1%ppo,ppo-1);\nt1 = t1 + 1;\n\n//a = above(t1,128);"},{"baseVals":{"samples":15,"thick":1,"additive":1,"scaling":5.92556,"smoothing":0,"a":0.4,"enabled":0},"init_eqs_str":"t2 = 0","frame_eqs_str":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_str":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n","init_eqs_eel":"t2 = 0","frame_eqs_eel":"t1 = 0;\nt2 = 0;\nt3 = 0;\nt4 = 0.5;","point_eqs_eel":"ppo = 5;\n\nindex = t2*q32;\nneighbor = 1;\nneighbor = gmegabuf(index+10+neighbor);\nx = 0.5 + (gmegabuf(index)-0.5)/q2;\ny = 0.5 + (gmegabuf(index+1)-0.5)/q2;\nxx = 0.5 + ( gmegabuf(neighbor) - 0.5)/q2;\nyy = 0.5 + ( gmegabuf(neighbor+1) - 0.5)/q2;\n\nx = if( equal(t1 % 2, 0), x, xx);\ny = if( equal(t1 % 2, 0), y, yx);\n\n\nt2 = t2 + equal(t1,ppo);\nt1 = if(above(t1,ppo),t1-ppo,t1) + 1;\n"}],"init_eqs_str":"a.mq29=0;a.cthr=0;a.d=0;a.mq1=0;a.w=0;a.index2=0;a.q25=0;a.index=0;a.w2=0;a.ref_ang=0;a.smaller=0;a.q22=0;a.q21=0;a.q29=0;a.q1=0;a.mq21=0;a.j=0;a.mq24=0;a.chng=0;a.mq28=0;a.count=0;a.mq23=0;a.q23=0;a.q24=0;a.nn=0;a.check=0;a.gravity=0;a.mq30=0;a.smallestfind=0;a.distance=0;a.q26=0;a.vv1=0;a.vv2=0;a.w1=0;a.attributes=0;a.i=0;a.mq27=0;a.mq25=0;a.m2=0;a.hit=0;a.mq22=0;a.mq26=0;a.q2=0;a.q27=0;a.m1=0;a.v1=0;a.findindex=0;a.q28=0;a.pi2=0;a.q30=0;a.v2=0;a.dampening=0;for(var b=a.i=\n0;1048576>b;b++)a.gmegabuf[Math.floor(a.i)]=0,a.i+=1;a.count=50;a.attributes=16;a.minradius=.005;a.maxradius=.045;a.v=.005;for(b=a.index=0;b<a.count;b++)a.gmegabuf[Math.floor(a.index*a.attributes)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+1)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+2)]=a.v*(div(rand(1E3),1E3)-.5),a.gmegabuf[Math.floor(a.index*a.attributes+3)]=a.v*(div(rand(1E3),1E3)-.5),a.gmegabuf[Math.floor(a.index*a.attributes+4)]=a.minradius+div((a.maxradius-\na.minradius)*(a.index+1),a.count),a.gmegabuf[Math.floor(a.index*a.attributes+5)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+6)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+7)]=div(rand(1E3),1E3),a.gmegabuf[Math.floor(a.index*a.attributes+8)]=sqr(a.gmegabuf[Math.floor(a.index*a.attributes+4)]),a.index+=1;a.q31=a.count;a.q32=a.attributes;","frame_eqs_str":"a.chng=Math.sin(.5*a.time);a.cthr=.9999;a.mq21=.00001<Math.abs(above(a.chng,a.cthr))?rand(3):a.mq21;a.mq22=.00001<Math.abs(above(a.chng,a.cthr))?rand(3):a.mq22;a.mq23=.00001<Math.abs(above(a.chng,a.cthr))?rand(3):a.mq23;a.mq24=.00001<Math.abs(above(a.chng,a.cthr))?rand(2):a.mq24;a.mq25=.00001<Math.abs(above(a.chng,a.cthr))?rand(2):a.mq25;a.mq26=.00001<Math.abs(above(a.chng,a.cthr))?rand(2):a.mq26;a.mq27=.00001<Math.abs(above(a.chng,a.cthr))?rand(1):a.mq27;a.mq28=.00001<Math.abs(above(a.chng,\na.cthr))?rand(1):a.mq28;a.mq29=.00001<Math.abs(above(a.chng,a.cthr))?.3*rand(1):a.mq29;a.mq30=.00001<Math.abs(above(a.chng,a.cthr))?.3*rand(1):a.mq30;a.monitor=a.chng;a.q21=a.mq21;a.q22=a.mq22;a.q23=a.mq23;a.q24=a.mq24;a.q25=a.mq25;a.q26=a.mq26;a.q27=a.mq27;a.q28=a.mq28;a.q29=a.mq29;a.q30=a.mq30;a.monitor=a.mq1;a.warp=0;a.zoom=1;a.gravity=0*div(.05,a.fps);a.dampening=1;a.pi2=Math.asin(1);a.nn=3;a.check=2;a.index=0;a.index2=0;a.w=div(a.aspecty-a.aspectx,2);for(var c=0;c<a.count;c++){a.gmegabuf[Math.floor(a.index*\na.attributes+1)]+=a.gmegabuf[Math.floor(a.index*a.attributes+3)];a.gmegabuf[Math.floor(a.index*a.attributes)]+=a.gmegabuf[Math.floor(a.index*a.attributes+2)];a.gmegabuf[Math.floor(a.index*a.attributes+2)]=.00001<Math.abs(below(a.gmegabuf[Math.floor(a.index*a.attributes)],0-a.w+a.gmegabuf[Math.floor(a.index*a.attributes+4)]))?Math.abs(a.gmegabuf[Math.floor(a.index*a.attributes+2)])*a.dampening:a.gmegabuf[Math.floor(a.index*a.attributes+2)];a.gmegabuf[Math.floor(a.index*a.attributes+2)]=.00001<Math.abs(above(a.gmegabuf[Math.floor(a.index*\na.attributes)],1+a.w-a.gmegabuf[Math.floor(a.index*a.attributes+4)]))?-Math.abs(a.gmegabuf[Math.floor(a.index*a.attributes+2)])*a.dampening:a.gmegabuf[Math.floor(a.index*a.attributes+2)];a.gmegabuf[Math.floor(a.index*a.attributes+3)]-=a.gravity;a.gmegabuf[Math.floor(a.index*a.attributes+3)]=.00001<Math.abs(below(a.gmegabuf[Math.floor(a.index*a.attributes+1)],a.gmegabuf[Math.floor(a.index*a.attributes+4)]))?Math.abs(a.gmegabuf[Math.floor(a.index*a.attributes+3)])*a.dampening:a.gmegabuf[Math.floor(a.index*\na.attributes+3)];a.gmegabuf[Math.floor(a.index*a.attributes+3)]=.00001<Math.abs(above(a.gmegabuf[Math.floor(a.index*a.attributes+1)],1-a.gmegabuf[Math.floor(a.index*a.attributes+4)]))?-Math.abs(a.gmegabuf[Math.floor(a.index*a.attributes+3)])*a.dampening:a.gmegabuf[Math.floor(a.index*a.attributes+3)];a.i=0;for(var b=a.j=0;b<a.count;b++)a.d=sqrt(sqr(a.gmegabuf[Math.floor(a.index*a.attributes)]-a.gmegabuf[Math.floor(a.i*a.attributes)])+sqr(a.gmegabuf[Math.floor(a.index*a.attributes+1)]-a.gmegabuf[Math.floor(a.i*\na.attributes+1)])),a.d=.00001<Math.abs(equal(a.d,0))?10:a.d,a.d-=.5*(a.gmegabuf[Math.floor(a.index*a.attributes+4)]+a.gmegabuf[Math.floor(a.i*a.attributes+4)]),a.megabuf[Math.floor(a.j)]=a.i,a.megabuf[Math.floor(a.j+1)]=a.d,a.j+=2,a.i+=1;for(b=a.i=0;b<a.nn;b++){a.j=a.i;a.smallestfind=10;a.findindex=-1;for(var d=0;d<a.count-a.j;d++)a.distance=a.megabuf[Math.floor(2*a.j+1)],a.smaller=above(a.smallestfind,a.distance),a.smallestfind=.00001<Math.abs(a.smaller)?a.distance:a.smallestfind,a.findindex=.00001<\nMath.abs(a.smaller)?2*a.j:a.findindex,a.j+=1;a.j=a.megabuf[Math.floor(2*a.i)];a.d=a.megabuf[Math.floor(2*a.i+1)];a.megabuf[Math.floor(2*a.i)]=a.megabuf[Math.floor(a.findindex)];a.megabuf[Math.floor(2*a.i+1)]=a.megabuf[Math.floor(a.findindex+1)];a.megabuf[Math.floor(a.findindex)]=a.j;a.megabuf[Math.floor(a.findindex+1)]=a.d;a.i+=1}for(b=a.i=0;b<a.nn;b++)a.gmegabuf[Math.floor(a.index*a.attributes+10+a.i)]=a.megabuf[Math.floor(2*a.i)],a.i+=1;for(b=a.i=0;b<a.check;b++)a.index2=a.megabuf[Math.floor(a.i)],\na.hit=below(sqrt(sqr(a.gmegabuf[Math.floor(a.index*a.attributes)]-a.gmegabuf[Math.floor(a.index2*a.attributes)])+sqr(a.gmegabuf[Math.floor(a.index*a.attributes+1)]-a.gmegabuf[Math.floor(a.index2*a.attributes+1)])),a.gmegabuf[Math.floor(a.index*a.attributes+4)]+a.gmegabuf[Math.floor(a.index2*a.attributes+4)])*above(sqrt(sqr(a.gmegabuf[Math.floor(a.index*a.attributes)]-a.gmegabuf[Math.floor(a.index2*a.attributes)])+sqr(a.gmegabuf[Math.floor(a.index*a.attributes+1)]-a.gmegabuf[Math.floor(a.index2*a.attributes+\n1)])),sqrt(sqr(a.gmegabuf[Math.floor(a.index*a.attributes)]-a.gmegabuf[Math.floor(a.index2*a.attributes)]+a.gmegabuf[Math.floor(a.index*a.attributes+2)]-a.gmegabuf[Math.floor(a.index2*a.attributes+2)])+sqr(a.gmegabuf[Math.floor(a.index*a.attributes+1)]-a.gmegabuf[Math.floor(a.index2*a.attributes+1)]+a.gmegabuf[Math.floor(a.index*a.attributes+3)]-a.gmegabuf[Math.floor(a.index2*a.attributes+3)]))),a.ref_ang=Math.atan2(a.gmegabuf[Math.floor(a.index2*a.attributes)]-a.gmegabuf[Math.floor(a.index*a.attributes)],\na.gmegabuf[Math.floor(a.index2*a.attributes+1)]-a.gmegabuf[Math.floor(a.index*a.attributes+1)])+a.pi2,a.v1=sqrt(sqr(a.gmegabuf[Math.floor(a.index*a.attributes+2)])+sqr(a.gmegabuf[Math.floor(a.index*a.attributes+3)])),a.v2=sqrt(sqr(a.gmegabuf[Math.floor(a.index2*a.attributes+2)])+sqr(a.gmegabuf[Math.floor(a.index2*a.attributes+3)])),a.w1=Math.atan2(a.gmegabuf[Math.floor(a.index*a.attributes+2)],a.gmegabuf[Math.floor(a.index*a.attributes+3)]),a.w2=Math.atan2(a.gmegabuf[Math.floor(a.index2*a.attributes+\n2)],a.gmegabuf[Math.floor(a.index2*a.attributes+3)]),a.m1=a.gmegabuf[Math.floor(a.index*a.attributes+8)],a.m2=a.gmegabuf[Math.floor(a.index2*a.attributes+8)],a.vv1=div((a.m1-a.m2)*a.v1+2*a.m2*a.v2,a.m1+a.m2),a.vv2=div((a.m2-a.m1)*a.v2+2*a.m1*a.v1,a.m1+a.m2),a.gmegabuf[Math.floor(a.index*a.attributes+2)]=.00001<Math.abs(a.hit)?Math.sin(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang)+Math.sin(a.ref_ang+a.pi2)*a.vv1*Math.cos(a.w2-a.ref_ang-a.pi2):a.gmegabuf[Math.floor(a.index*a.attributes+2)],a.gmegabuf[Math.floor(a.index*\na.attributes+3)]=.00001<Math.abs(a.hit)?Math.cos(a.ref_ang)*a.v1*Math.cos(a.w1-a.ref_ang)+Math.cos(a.ref_ang+a.pi2)*a.vv1*Math.cos(a.w2-a.ref_ang-a.pi2):a.gmegabuf[Math.floor(a.index*a.attributes+3)],a.gmegabuf[Math.floor(a.index2*a.attributes+2)]=.00001<Math.abs(a.hit)?Math.sin(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang)+Math.sin(a.ref_ang+a.pi2)*a.vv2*Math.cos(a.w1-a.ref_ang-a.pi2):a.gmegabuf[Math.floor(a.index2*a.attributes+2)],a.gmegabuf[Math.floor(a.index2*a.attributes+3)]=.00001<Math.abs(a.hit)?\nMath.cos(a.ref_ang)*a.v2*Math.cos(a.w2-a.ref_ang)+Math.cos(a.ref_ang+a.pi2)*a.vv2*Math.cos(a.w1-a.ref_ang-a.pi2):a.gmegabuf[Math.floor(a.index2*a.attributes+3)],a.i+=2;a.index+=1}a.q1=a.aspectx;a.q2=a.aspecty;","pixel_eqs_str":"","init_eqs_eel":"// clear buffer\ni = 0; loop(1024*1024, gmegabuf(i) = 0; i = i+1);\n\ncount = 50;\nattributes = 16;\n\nminradius = 0.005;\nmaxradius = 0.045;\nv = 0.005;\n\n// randomize initial coordinates\nindex = 0;\nloop(count, \n     gmegabuf(index*attributes) = rand(1000)/1000;\n     gmegabuf(index*attributes+1) = rand(1000)/1000;\n     gmegabuf(index*attributes+2) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+3) = v*(rand(1000)/1000-0.5);\n     gmegabuf(index*attributes+4) = minradius + (maxradius-minradius)*(index+1)/count;\n     gmegabuf(index*attributes+5) = rand(1000)/1000;\n     gmegabuf(index*attributes+6) = rand(1000)/1000;\n     gmegabuf(index*attributes+7) = rand(1000)/1000;\n     gmegabuf(index*attributes+8) = sqr(gmegabuf(index*attributes+4)) ;\n     index = index+1;\n    );\n\nq31 = count;\nq32 = attributes;\n\n// 0, x\n// 1, y\n// 2, vx\n// 3, vy\n// 4, radius\n// 5, red\n// 6, green\n// 7, blue\n// 8, mass","frame_eqs_eel":"chng=sin(time*.5);\ncthr=.9999;\nmq21=if(above(chng,cthr),rand(3),mq21);\nmq22=if(above(chng,cthr),rand(3),mq22);\nmq23=if(above(chng,cthr),rand(3),mq23);\nmq24=if(above(chng,cthr),rand(2),mq24);\nmq25=if(above(chng,cthr),rand(2),mq25);\nmq26=if(above(chng,cthr),rand(2),mq26);\nmq27=if(above(chng,cthr),rand(1),mq27);\nmq28=if(above(chng,cthr),rand(1),mq28);\nmq29=if(above(chng,cthr),rand(1)*.3,mq29);\nmq30=if(above(chng,cthr),rand(1)*.3,mq30);\nmonitor=chng;\nq21=mq21;q22=mq22;q23=mq23;q24=mq24;q25=mq25;q26=mq26;\nq27=mq27;q28=mq28;q29=mq29;q30=mq30;\n\nmonitor=mq1;\nwarp = 0;\nzoom = 1;\n\ngravity = 0.05/fps*0;\ndampening = 1;\npi2 = asin(1);\n\n\nnn = 3; // number of nearest neighbors to search, reduce if not needed!\n        // collision detection is based on nearest neighbors now, so keep it at least at 1.\n\ncheck = 2; // how many neighbors will be checked for a possible collision. may not be above nn.\n           // raise to avoid odd behavior in clusters of touching balls.\n\nindex = 0; index2 = 0;  w = (aspecty-aspectx)/2;\nloop(count, \n     // simple physics: adding velocity vectors, applying gravity + bouncing off borders\n     gmegabuf(index*attributes+1) = gmegabuf(index*attributes+1) + gmegabuf(index*attributes+3);\n     gmegabuf(index*attributes) = gmegabuf(index*attributes) + gmegabuf(index*attributes+2);\n     gmegabuf(index*attributes+2) = if( below( gmegabuf(index*attributes), 0-w+gmegabuf(index*attributes+4)),\n                                        abs(gmegabuf(index*attributes+2))*dampening,\n                                        gmegabuf(index*attributes+2) ); \n     gmegabuf(index*attributes+2) = if( above( gmegabuf(index*attributes), 1+w-gmegabuf(index*attributes+4)),\n                                        -abs(gmegabuf(index*attributes+2))*dampening,\n                                        gmegabuf(index*attributes+2) ); \n     gmegabuf(index*attributes+3) = gmegabuf(index*attributes+3) - gravity;\n     gmegabuf(index*attributes+3) = if( below( gmegabuf(index*attributes+1), gmegabuf(index*attributes+4)),\n                                        abs(gmegabuf(index*attributes+3))*dampening,\n                                        gmegabuf(index*attributes+3); );\n     gmegabuf(index*attributes+3) = if( above( gmegabuf(index*attributes+1), 1-gmegabuf(index*attributes+4)),\n                                        -abs(gmegabuf(index*attributes+3))*dampening,\n                                        gmegabuf(index*attributes+3); );\n     i = 0; j = 0; // collecting pairs of index and distance to the current object in a local buffer\n     loop( count,\n           d = sqrt( sqr(gmegabuf(index*attributes)-gmegabuf(i*attributes)) + sqr(gmegabuf(index*attributes+1)-gmegabuf(i*attributes+1)));\n           d = if( equal(d,0), 10, d); // leave out comparison with itself (where d == 0, set d to a high value)\n           d = d - (gmegabuf(index*attributes+4)+gmegabuf(i*attributes+4))*0.5; // subtract radius (surface to surface distance)\n           megabuf(j)   = i; // store index/distance pairs\n           megabuf(j+1) = d; \n           j = j+2;\n           i = i+1; );\n     i = 0; // sort that buffer, but only as many cycles as needed for the _nn_ nearest neighbors\n     loop( nn,\n           j = i; smallestfind = 10; findindex = -1;\n           loop( count-j,\n                 distance =megabuf(j*2+1);\n                 smaller = above( smallestfind, distance);\n                 smallestfind = if(smaller, distance, smallestfind);\n                 findindex = if( smaller, j*2, findindex);\n                 j = j + 1; );\n           j = megabuf(i*2); d = megabuf(i*2+1);\n           megabuf(i*2)   = megabuf(findindex);\n           megabuf(i*2+1) = megabuf(findindex+1);\n           megabuf(findindex)   = j;\n           megabuf(findindex+1) = d;\n           i = i+1;\n         );\n     i = 0; // storing the indexes of the nearest neighbors in the attributes beginning from 10\n     loop( nn,\n           gmegabuf(index*attributes + 10 + i) = megabuf(i*2);\n           i = i +1;\n         );\n     i = 0; // collision detection and impulse transmission below\n     loop( check,\n           index2 = megabuf(i);\n           hit = below( sqrt( sqr( gmegabuf(index*attributes) - gmegabuf(index2*attributes)) +\n                              sqr( gmegabuf(index*attributes+1) - gmegabuf(index2*attributes+1))),\n                        gmegabuf(index*attributes + 4) + gmegabuf(index2*attributes + 4)\n                      )\n                 *\n                 above( sqrt( sqr( gmegabuf(index*attributes)   - gmegabuf(index2*attributes))+\n                        sqr( gmegabuf(index*attributes+1) - gmegabuf(index2*attributes+1))),\n                        sqrt( sqr( gmegabuf(index*attributes+0) - gmegabuf(index2*attributes+0)+ \n                                   gmegabuf(index*attributes+2) - gmegabuf(index2*attributes+2))+\n                              sqr( gmegabuf(index*attributes+1) - gmegabuf(index2*attributes+1)+\n                                   gmegabuf(index*attributes+3) - gmegabuf(index2*attributes+3)) ) );\n           ref_ang = atan2( gmegabuf(index2*attributes)-gmegabuf(index*attributes), // calculating the angle of the common tangent\n                            gmegabuf(index2*attributes + 1)-gmegabuf(index*attributes + 1)) + pi2;\n           v1 = sqrt(sqr( gmegabuf(index*attributes + 2)) + sqr( gmegabuf(index*attributes + 3))); // velocity of object1\n           v2 = sqrt(sqr( gmegabuf(index2*attributes + 2)) + sqr( gmegabuf(index2*attributes + 3)));  // velocity of object2\n           w1 = atan2( gmegabuf(index*attributes + 2), gmegabuf(index*attributes + 3));   // object1 motion angle\n           w2 = atan2( gmegabuf(index2*attributes + 2), gmegabuf(index2*attributes + 3)); // object2 motion angle\n           m1 = gmegabuf(index*attributes + 8); m2 = gmegabuf(index2*attributes + 8);\n           vv1 = ((m1-m2)*v1 + 2*m2*v2)/(m1+m2); vv2 = ((m2-m1)*v2 + 2*m1*v1)/(m1+m2);\n           gmegabuf( index*attributes + 2) = if( hit,sin(ref_ang)*v1*cos(w1-ref_ang) + sin(ref_ang+pi2)*vv1*cos(w2-ref_ang-pi2),\n                                                  gmegabuf( index*attributes + 2) );\n           gmegabuf( index*attributes + 3) = if( hit, cos(ref_ang)*v1*cos(w1-ref_ang) + cos(ref_ang+pi2)*vv1*cos(w2-ref_ang-pi2),\n                                                 gmegabuf( index*attributes + 3) );\n           gmegabuf( index2*attributes + 2) = if( hit, sin(ref_ang)*v2*cos(w2-ref_ang) + sin(ref_ang+pi2)*vv2*cos(w1-ref_ang-pi2),\n                                                  gmegabuf( index2*attributes + 2) );\n           gmegabuf( index2*attributes + 3) = if( hit, cos(ref_ang)*v2*cos(w2-ref_ang) + cos(ref_ang+pi2)*vv2*cos(w1-ref_ang-pi2),\n                                                  gmegabuf( index2*attributes + 3) );\n           i=i+2;\n         );\n     index = index+1;\n    );\nq1 = aspectx;\nq2 = aspecty;","pixel_eqs_eel":"","warp":" shader_body { \n  vec2 uv_y_1;\n  vec3 ret_2;\n  vec2 tmpvar_3;\n  tmpvar_3 = (texsize.zw * 12.0);\n  vec3 tmpvar_4;\n  tmpvar_4 = (((texture (sampler_blur1, \n    (uv + (vec2(1.0, 0.0) * tmpvar_3))\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (uv - (vec2(1.0, 0.0) * tmpvar_3))\n  ).xyz * scale1) + bias1));\n  vec3 tmpvar_5;\n  tmpvar_5 = (((texture (sampler_blur1, \n    (uv + (vec2(0.0, 1.0) * tmpvar_3))\n  ).xyz * scale1) + bias1) - ((texture (sampler_blur1, \n    (uv - (vec2(0.0, 1.0) * tmpvar_3))\n  ).xyz * scale1) + bias1));\n  vec2 tmpvar_6;\n  tmpvar_6.x = tmpvar_4.y;\n  tmpvar_6.y = tmpvar_5.y;\n  uv_y_1 = (uv - (tmpvar_6 * texsize.zw));\n  vec2 tmpvar_7;\n  vec2 tmpvar_8;\n  tmpvar_8 = (uv_orig * texsize.xy);\n  tmpvar_7 = (((tmpvar_8 * texsize_noise_lq.zw) * 0.8) + rand_frame.xy);\n  vec2 tmpvar_9;\n  tmpvar_9.x = tmpvar_4.x;\n  tmpvar_9.y = tmpvar_5.x;\n  vec2 tmpvar_10;\n  vec2 tmpvar_11;\n  tmpvar_11 = (uv_orig - uv);\n  tmpvar_10 = (((uv_orig - \n    (tmpvar_11 * 0.4)\n  ) + (\n    (tmpvar_9 * texsize.zw)\n   * 2.0)) + ((\n    (texture (sampler_noise_lq, tmpvar_7).xy - 0.5)\n   * texsize.zw) * 4.0));\n  ret_2.x = (((texture (sampler_main, tmpvar_10).x - \n    ((texture (sampler_main, tmpvar_10).x - ((texture (sampler_blur3, tmpvar_10).xyz * scale3) + bias3).x) * 0.02)\n  ) - 0.008) + ((texture (sampler_noise_lq, tmpvar_7).x - 0.5) * 0.1));\n  ret_2.y = texture (sampler_main, uv_y_1).y;\n  ret_2.y = (ret_2.y + ((\n    (ret_2.y - ((texture (sampler_blur1, uv).xyz * scale1) + bias1).y)\n   * 0.2) - 0.004));\n  ret_2.z = (texture (sampler_main, ((uv_orig - \n    (tmpvar_11 * 2.0)\n  ) + (\n    ((texture (sampler_noise_lq, ((tmpvar_8 * texsize_noise_lq.zw) + rand_frame.xy)).xyz - 0.5).xy * texsize.zw)\n   * 3.0))).z - 0.012);\n  ret_2 = (ret_2 - ((roam_sin.xyz * roam_cos.wzy) * 0.2));\n  vec4 tmpvar_12;\n  tmpvar_12 = texture (sampler_noisevol_hq, (((vec3(0.05, 0.05, 0.0) * uv_y_1.xyy) * (\n    (q27 * texsize.xyy)\n   * texsize_noisevol_hq.zww)) + ((time * vec3(0.0, 0.0, 1.0)) * q29)));\n  if (((ret_2.x > (q21 * roam_cos.y)) && (ret_2.x <= (q24 * roam_sin.x)))) {\n    ret_2.y = (ret_2.y - (tmpvar_12.x * 0.5));\n  };\n  if (((ret_2.y > (q22 * roam_sin.x)) && (ret_2.y <= (q25 * roam_cos.x)))) {\n    ret_2.z = (ret_2.z - (tmpvar_12.y * 0.5));\n  };\n  if (((ret_2.z > (q23 * roam_cos.x)) && (ret_2.z <= (q26 * roam_sin.y)))) {\n    ret_2.x = (ret_2.x - (tmpvar_12.z * 0.5));\n  };\n  vec4 tmpvar_13;\n  tmpvar_13.w = 1.0;\n  tmpvar_13.xyz = ret_2;\n  ret = tmpvar_13.xyz;\n }","comp":"uniform sampler2D sampler_rand00;\n shader_body { \n  vec3 ret_1;\n  vec4 tmpvar_2;\n  tmpvar_2 = texture (sampler_main, uv);\n  ret_1 = tmpvar_2.xyz;\n  vec4 tmpvar_3;\n  tmpvar_3 = texture (sampler_noisevol_hq, (((vec3(0.05, 0.05, 0.0) * uv.xyy) * (\n    (q28 * texsize.xyy)\n   * texsize_noisevol_hq.zww)) + ((time * vec3(0.0, 0.0, 1.0)) * q30)));\n  if (((tmpvar_2.x > (q26 * roam_cos.y)) && (tmpvar_2.x <= (q23 * roam_sin.x)))) {\n    ret_1.z = (tmpvar_2.z - (tmpvar_3.x * 0.5));\n  };\n  if (((tmpvar_2.y > (q25 * roam_sin.x)) && (tmpvar_2.y <= (q22 * roam_cos.x)))) {\n    ret_1.x = (tmpvar_2.x - (tmpvar_3.y * 0.5));\n  };\n  if (((ret_1.z > (q24 * roam_cos.x)) && (ret_1.z <= (q21 * roam_sin.y)))) {\n    ret_1.y = (tmpvar_2.y - (tmpvar_3.z * 0.5));\n  };\n  ret_1 = (ret_1 * ((texture (sampler_rand00, \n    fract(((1.0 - (\n      ((texture (sampler_blur2, uv).xyz * scale2) + bias2)\n    .yx * 0.6)) + (time * vec2(0.057, 0.036))))\n  ) * \n    ((1.0 + texture (sampler_main, uv).x) + ((texture (sampler_blur1, uv).xyz * scale1) + bias1).y)\n  ) * 0.4).xyz);\n  vec4 tmpvar_4;\n  tmpvar_4.w = 1.0;\n  tmpvar_4.xyz = ret_1;\n  ret = tmpvar_4.xyz;\n }","warp_hlsl":"shader_body\n{\n    float2 d = texsize.zw*12;\n    float2 uv_y = uv;//0.5 + (uv_orig-0.5)*1.00 + float2(0,-0.8)*texsize.zw*0;\n    float3 dx = ( GetBlur1(uv_y + float2(1,0)*d) - GetBlur1(uv_y-float2(1,0)*d) );\n    float3 dy = ( GetBlur1(uv_y + float2(0,1)*d) - GetBlur1(uv_y-float2(0,1)*d) );\n    uv_y = uv_y - float2(dx.y,dy.y)*texsize.zw;\n\n    float2 dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw*0.8 + rand_frame.xy;\n    float2 uv_bg = uv_orig -(uv_orig-uv)*0.4 + float2(dx.x,dy.x)*texsize.zw*2 + (tex2D(sampler_noise_lq, dither_uv).xy-0.5)*texsize.zw*4;\n\nret.x = GetPixel(uv_bg).x - (GetPixel(uv_bg).x - GetBlur3(uv_bg).x)*0.02 - 0.008 + \n(tex2D(sampler_noise_lq, dither_uv).x-0.5)*0.1;\n\n\n   ret.y = tex2D( sampler_main, uv_y ).y;\n   ret.y += (ret.y - GetBlur1(uv).y)*0.2 - 0.004;\n   dither_uv = uv_orig*texsize.xy*texsize_noise_lq.zw + rand_frame.xy;\n\nuv_bg = uv_orig -(uv_orig-uv)*2 + (tex2D(sampler_noise_lq, dither_uv).xyz-0.5)*texsize.zw*3;\nret.z = GetPixel(uv_bg).z - 0.012;\nret-=roam_sin*roam_cos.wzy*.2;\nfloat4 noise9 = tex3D(sampler_noisevol_hq, \n                      ((uv_y.xyy*q27\n                       )*texsize.xyy*texsize_noisevol_hq.zww\n                      ).xyz*\n                      float3(1,1,0)*0.05 + \n                      time*float3(0,0,1)*q29\n                     );\nif(ret.x> q21*roam_cos.y && ret.x<= q24*roam_sin.x)ret.y -= (noise9).x*.5; \nif(ret.y> q22*roam_sin.x && ret.y<= q25*roam_cos.x)ret.z -= (noise9).y*.5; \nif(ret.z> q23*roam_cos.x && ret.z<= q26*roam_sin.y)ret.x -= (noise9).z*.5; \n}","comp_hlsl":"sampler sampler_rand00;\nshader_body\n{\nret=GetPixel(uv);\nfloat4 noise9 = tex3D(sampler_noisevol_hq, \n                      ((uv.xyy*q28\n                       )*texsize.xyy*texsize_noisevol_hq.zww\n                      ).xyz*\n                      float3(1,1,0)*0.05 + \n                      time*float3(0,0,1)*q30 \n                     );\nif(ret.x> q26*roam_cos.y && ret.x<= q23*roam_sin.x)ret.z -= (noise9).x*.5; \nif(ret.y> q25*roam_sin.x && ret.y<= q22*roam_cos.x)ret.x -= (noise9).y*.5; \nif(ret.z> q24*roam_cos.x && ret.z<= q21*roam_sin.y)ret.y -= (noise9).z*.5; \n\nret *= tex2D(sampler_rand00, frac(1-GetBlur2(uv).yx*0.6 + time*float2(0.057,.036)))\n*(1+GetPixel(uv).x + GetBlur1(uv).y)*0.4;\n\n}"}