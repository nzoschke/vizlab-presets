{"version":2,"baseVals":{"rating":5,"gammaadj":1.98,"decay":0.5,"echo_zoom":1,"echo_alpha":0.5,"echo_orient":3,"wave_mode":6,"wave_thick":1,"wrap":0,"darken":1,"wave_a":0,"wave_scale":0,"wave_smoothing":0.5,"modwavealphastart":0.5,"modwavealphaend":1,"warpanimspeed":1.459,"warpscale":2.007,"zoom":0.9999,"warp":0.01,"sx":0.9999,"wave_r":0.5,"wave_g":0.5,"wave_b":0.5,"ob_size":0,"ob_a":1,"ib_size":0,"ib_r":0,"ib_g":0,"ib_b":0,"mv_x":51.2,"mv_y":33.6,"mv_l":5,"mv_r":0.4,"mv_g":0.3,"mv_b":0.5,"mv_a":0,"b1ed":0},"shapes":[{"baseVals":{"thickoutline":1,"x":0.7,"rad":0.04067,"tex_zoom":1.83492,"r":0,"g":0.99,"border_r":0.2,"border_g":0.14,"border_b":0,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"sides":16,"num_inst":800,"x":0.8,"rad":0.55692,"tex_ang":1.50796,"tex_zoom":4.72143,"g":1,"b":1,"a":0.5,"r2":1,"b2":1,"border_g":0.7,"border_b":0.4,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"thickoutline":1,"textured":1,"num_inst":4,"rad":0.57386,"tex_ang":1.5079,"tex_zoom":1.13805,"r":0.8,"g":1,"b":1,"a":0,"r2":0.8,"b2":1,"border_r":0.8,"border_g":0.4,"border_b":0,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""},{"baseVals":{"rad":3.95513,"tex_zoom":1.54929,"r":0,"g2":0,"border_g":0.6,"border_b":0.1,"border_a":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":""}],"waves":[{"baseVals":{"usedots":1,"scaling":60.80387,"smoothing":0.7,"a":0.05,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"spectrum":1,"usedots":1,"scaling":67.1652,"smoothing":0.7,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"usedots":1,"b":0,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""},{"baseVals":{"usedots":1,"r":0.7,"g":0.7,"a":0.6,"enabled":0},"init_eqs_str":"","frame_eqs_str":"","point_eqs_str":"","init_eqs_eel":"","frame_eqs_eel":"","point_eqs_eel":""}],"init_eqs_str":"a.st=0;a.ranx=0;a.q15=0;a.q6=0;a.posx=0;a.st_=0;a.q11=0;a.q10=0;a.posy=0;a.q4=0;a.rany=0;a.dir=0;a.q16=0;a.q2=0;a.q3=0;a.t0=0;a.dec=0;a.view=0;a.q7=0;a.test=0;a.q8=0;for(var b=a.n=0;1E5>b;b++)a.megabuf[Math.floor(a.n)]=0,a.gmegabuf[Math.floor(a.n)]=0,a.n+=1;a.posx=rand(10);a.posy=rand(10);a.ranx=rand(1);a.rany=rand(1);a.ranh=rand(10);a.t0=a.time;a.st=.5;a.st_=.5;","frame_eqs_str":"a.st=Math.max(0,a.st-div(.2,a.fps));a.dec=1-div(.5,a.fps);a.st_=a.st_*a.dec+(1-a.dec)*a.st;a.dir=.7*Math.sin(.0162*a.time+6*a.rany);a.q2=a.dir+.5;a.q3=Math.sin(a.dir);a.q4=Math.cos(a.dir);a.q7=.002;a.posx=.0003*a.time;a.posy=.004*a.time;a.q10=a.posx;a.q11=a.posy;a.q15=a.ranx;a.q16=a.rany;a.test=.047*(a.t0-a.time)-div(3.14,2);a.view=.7+.17*Math.min(1,Math.max(-1,2*Math.sin(a.test)));a.q8=4+3*Math.sin(a.test)+16*(a.view-.55);a.q6=a.view*(1-a.st_)+2*a.st_;a.monitor=a.view;","pixel_eqs_str":"","init_eqs_eel":"n = 0;\nloop (100000,megabuf(n)=0;gmegabuf(n)=0;n += 1;);\n\nposx = rand(10); posy = rand(10);\nranx = rand (1); rany = rand(1);\nranh = rand(10);\nt0 = time;\nst = 0.5; st_=0.5;","frame_eqs_eel":"st = max (0, st-0.2/fps);\ndec = 1-0.5/fps;\nst_ = st_* (dec) + (1-dec)*st;\n\n//dir\ndir = 0.7*sin(time*.0162+rany*6);\nq2 = dir+0.5; \nq3 = sin(dir);\nq4 = cos(dir);\n\n//scaling plane\nq7 = 0.002;\n\n//movement\nposx = time*0.0003;\nposy = time*0.004;\nq10 = posx;\nq11 = posy;\n\n//start ran for warp mod \nq15 = ranx;\nq16 = rany;\n\ntest = (t0-time)*0.047-3.14/2;\nview = 0.7 + min(1, max (-1, 2*sin(test)))*0.17;\n\n//Alti\nq8 = 4 + 3* sin(test) + (view-0.55)*16;\n\n//hory (Kippung)\nq6 = view * (1-st_) + st_*2;\n\n//q6  = 0.55;\nmonitor = view;","pixel_eqs_eel":"","warp":"float hory;\nfloat xyscale;\nfloat alti;\nvec2 modran;\nvec3 mov;\nvec2 xlat_mutabledz;\nfloat xlat_mutablei;\nfloat xlat_mutablelav_gnd;\nfloat xlat_mutablep;\nfloat xlat_mutableripple;\nvec3 xlat_mutablersl;\nvec3 xlat_mutablersl3;\nvec2 xlat_mutableuv1;\nvec3 xlat_mutablexlat_varmod;\n shader_body { \n  hory = q6;\n  xyscale = q7;\n  alti = q8;\n  vec2 tmpvar_1;\n  tmpvar_1.x = q3;\n  tmpvar_1.y = q4;\n  vec2 tmpvar_2;\n  tmpvar_2.x = q15;\n  tmpvar_2.y = q16;\n  modran = tmpvar_2;\n  vec3 tmpvar_3;\n  tmpvar_3.z = 0.0;\n  tmpvar_3.x = q10;\n  tmpvar_3.y = q11;\n  mov = tmpvar_3;\n  vec3 ret_5;\n  xlat_mutableuv1 = (uv - 0.5);\n  xlat_mutablelav_gnd = -(min (texture (sampler_fc_main, uv).z, texture (sampler_fc_main, (uv + \n    (texsize.zw * vec2(1.5, 0.0))\n  .yx)).z));\n  vec2 rs_6;\n  float z_7;\n  z_7 = ((1.0/((xlat_mutableuv1.y + q6))) * (q8 - (xlat_mutablelav_gnd * 16.0)));\n  rs_6.x = ((xlat_mutableuv1.x * 2.0) * z_7);\n  rs_6.y = z_7;\n  vec3 tmpvar_8;\n  tmpvar_8.xy = (rs_6 * q7);\n  tmpvar_8.z = z_7;\n  xlat_mutablersl = (tmpvar_8 + tmpvar_3);\n  vec4 tmpvar_9;\n  tmpvar_9 = texture (sampler_noise_mq, ((xlat_mutablersl.xy * 0.043) + tmpvar_2));\n  xlat_mutablexlat_varmod = tmpvar_9.xyz;\n  xlat_mutablei = 0.0;\n  xlat_mutablep = 0.0;\n  for (int n_4 = 1; float(n_4) <= 4.0; n_4++) {\n    vec3 uvi_10;\n    float s_11;\n    vec2 tmp_12;\n    uvi_10 = (xlat_mutablersl * 0.16);\n    uvi_10.xy = (uvi_10.xy + (modran * 3.0));\n    tmp_12 = clamp ((1.0 - (texture (sampler_noise_lq, uvi_10.xy) * \n      (0.8 + (xlat_mutablexlat_varmod.y / 2.0))\n    )), 0.0, 1.0).xy;\n    s_11 = (3.0 + ((tmp_12 * 0.002) * xlat_mutablexlat_varmod.z)).x;\n    tmp_12 = (tmp_12 * clamp ((1.0 - \n      ((texture (sampler_noise_lq, (uvi_10 * s_11).xy) * (0.8 + (xlat_mutablexlat_varmod.y / 2.0))) / s_11)\n    ), 0.0, 1.0).xy);\n    s_11 = (s_11 * (3.0 + (\n      (tmp_12 * 0.002)\n     * xlat_mutablexlat_varmod.z)).x);\n    tmp_12 = (tmp_12 * clamp ((1.0 - \n      ((texture (sampler_noise_lq, (uvi_10 * s_11).xy) * (0.8 + (xlat_mutablexlat_varmod.y / 2.0))) / s_11)\n    ), 0.0, 1.0).xy);\n    s_11 = (s_11 * 3.0);\n    tmp_12 = (tmp_12 * clamp ((1.0 - \n      ((texture (sampler_noise_lq, (uvi_10 * s_11).xy) * (0.8 + (xlat_mutablexlat_varmod.y / 2.0))) / s_11)\n    ), 0.0, 1.0).xy);\n    s_11 = (s_11 * 3.0);\n    tmp_12 = (tmp_12 * clamp ((1.0 - \n      ((texture (sampler_noise_lq, (uvi_10 * s_11).xy) * (0.8 + (xlat_mutablexlat_varmod.y / 2.0))) / s_11)\n    ), 0.0, 1.0).xy);\n    s_11 = (s_11 * 3.0);\n    tmp_12 = (tmp_12 - (clamp (\n      ((16.0 - (2.0 * uvi_10.z)) - (20000.0 * abs((tmp_12.x - 0.4))))\n    , 0.0, 1.0) * 0.009));\n    xlat_mutablep = ((xlat_mutablelav_gnd + (1.0 - \n      pow (tmp_12, vec2((0.8 + xlat_mutablexlat_varmod.x)))\n    )) / 4.0).x;\n    xlat_mutablei = (xlat_mutablei + xlat_mutablep);\n    xlat_mutablelav_gnd = (xlat_mutablelav_gnd - ((xlat_mutablep * 0.1) + (xlat_mutablei * 0.2)));\n    vec2 rs_13;\n    float z_14;\n    z_14 = ((1.0/((xlat_mutableuv1.y + hory))) * (alti - (xlat_mutablelav_gnd * 16.0)));\n    rs_13.x = ((xlat_mutableuv1.x * 2.0) * z_14);\n    rs_13.y = z_14;\n    vec3 tmpvar_15;\n    tmpvar_15.xy = (rs_13 * xyscale);\n    tmpvar_15.z = z_14;\n    xlat_mutablersl = (tmpvar_15 + mov);\n  };\n  float tmpvar_16;\n  tmpvar_16 = clamp (-(xlat_mutablelav_gnd), 0.0, 1.0);\n  xlat_mutabledz = (((\n    (-1.5 / xlat_mutablersl.z)\n   * q7) * 1.8) * tmpvar_1);\n  xlat_mutablersl3 = (xlat_mutablersl * 8.0);\n  vec2 uvi_17;\n  uvi_17 = (xlat_mutablersl3.xy - xlat_mutabledz);\n  vec2 tmp_18;\n  tmp_18 = (1.0 - texture (sampler_noise_lq, uvi_17)).xy;\n  tmp_18 = (tmp_18 * (1.0 - texture (sampler_noise_lq, (uvi_17 * 3.0))).xy);\n  vec2 uvi_19;\n  uvi_19 = (xlat_mutablersl3.xy + xlat_mutabledz);\n  vec2 tmp_20;\n  tmp_20 = (1.0 - texture (sampler_noise_lq, uvi_19)).xy;\n  tmp_20 = (tmp_20 * (1.0 - texture (sampler_noise_lq, (uvi_19 * 3.0))).xy);\n  xlat_mutableripple = (((tmp_18 - tmp_20) * (1.0 - tmpvar_16)) + 0.02).x;\n  vec3 tmpvar_21;\n  tmpvar_21.z = 0.0;\n  tmpvar_21.xy = xlat_mutabledz;\n  vec3 uvi_22;\n  uvi_22 = (xlat_mutablersl - tmpvar_21);\n  float s_23;\n  vec2 tmp_24;\n  uvi_22 = (uvi_22 * 0.16);\n  uvi_22.xy = (uvi_22.xy + (tmpvar_2 * 3.0));\n  tmp_24 = clamp ((1.0 - (texture (sampler_noise_lq, uvi_22.xy) * \n    (0.8 + (tmpvar_9.y / 2.0))\n  )), 0.0, 1.0).xy;\n  s_23 = (3.0 + ((tmp_24 * 0.002) * tmpvar_9.z)).x;\n  tmp_24 = (tmp_24 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_22 * s_23).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_23)\n  ), 0.0, 1.0).xy);\n  s_23 = (s_23 * (3.0 + (\n    (tmp_24 * 0.002)\n   * tmpvar_9.z)).x);\n  tmp_24 = (tmp_24 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_22 * s_23).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_23)\n  ), 0.0, 1.0).xy);\n  s_23 = (s_23 * 3.0);\n  tmp_24 = (tmp_24 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_22 * s_23).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_23)\n  ), 0.0, 1.0).xy);\n  s_23 = (s_23 * 3.0);\n  tmp_24 = (tmp_24 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_22 * s_23).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_23)\n  ), 0.0, 1.0).xy);\n  s_23 = (s_23 * 3.0);\n  tmp_24 = (tmp_24 - (clamp (\n    ((16.0 - (2.0 * uvi_22.z)) - (20000.0 * abs((tmp_24.x - 0.4))))\n  , 0.0, 1.0) * 0.009));\n  vec3 tmpvar_25;\n  tmpvar_25.z = 0.0;\n  tmpvar_25.xy = xlat_mutabledz;\n  vec3 uvi_26;\n  uvi_26 = (xlat_mutablersl + tmpvar_25);\n  float s_27;\n  vec2 tmp_28;\n  uvi_26 = (uvi_26 * 0.16);\n  uvi_26.xy = (uvi_26.xy + (tmpvar_2 * 3.0));\n  tmp_28 = clamp ((1.0 - (texture (sampler_noise_lq, uvi_26.xy) * \n    (0.8 + (tmpvar_9.y / 2.0))\n  )), 0.0, 1.0).xy;\n  s_27 = (3.0 + ((tmp_28 * 0.002) * tmpvar_9.z)).x;\n  tmp_28 = (tmp_28 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_26 * s_27).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_27)\n  ), 0.0, 1.0).xy);\n  s_27 = (s_27 * (3.0 + (\n    (tmp_28 * 0.002)\n   * tmpvar_9.z)).x);\n  tmp_28 = (tmp_28 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_26 * s_27).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_27)\n  ), 0.0, 1.0).xy);\n  s_27 = (s_27 * 3.0);\n  tmp_28 = (tmp_28 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_26 * s_27).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_27)\n  ), 0.0, 1.0).xy);\n  s_27 = (s_27 * 3.0);\n  tmp_28 = (tmp_28 * clamp ((1.0 - \n    ((texture (sampler_noise_lq, (uvi_26 * s_27).xy) * (0.8 + (tmpvar_9.y / 2.0))) / s_27)\n  ), 0.0, 1.0).xy);\n  s_27 = (s_27 * 3.0);\n  tmp_28 = (tmp_28 - (clamp (\n    ((16.0 - (2.0 * uvi_26.z)) - (20000.0 * abs((tmp_28.x - 0.4))))\n  , 0.0, 1.0) * 0.009));\n  xlat_mutableripple = (((\n    ((((\n      (1.0/(xlat_mutablersl.z))\n     * xlat_mutableripple) + (1.0 - \n      pow (tmp_24, vec2((0.8 + tmpvar_9.x)))\n    )) - (1.0 - pow (tmp_28, vec2(\n      (0.8 + tmpvar_9.x)\n    )))) * (1.0 - tmpvar_16))\n   / 1.8) / sqrt(\n    (50.0 + xlat_mutablersl.z)\n  )) * 2000.0).x;\n  xlat_mutableripple = (1.0 - exp(-(xlat_mutableripple)));\n  ret_5.x = xlat_mutableripple;\n  ret_5.z = tmpvar_16;\n  ret_5.xz = mix (ret_5, ((texture (sampler_blur1, uv).xyz * scale1) + bias1), vec3(0.1, 0.1, 0.1)).xz;\n  ret_5.y = ((xlat_mutablersl.z * q7) * 4.0);\n  vec4 tmpvar_29;\n  tmpvar_29.w = 1.0;\n  tmpvar_29.xyz = ret_5;\n  ret = tmpvar_29.xyz;\n }","comp":"vec2 xlat_mutablefactorA;\n shader_body { \n  vec2 uv_1;\n  vec3 ret_2;\n  xlat_mutablefactorA = (uv - vec2(0.5, 0.5));\n  vec2 tmpvar_3;\n  tmpvar_3.x = -((xlat_mutablefactorA.y * 1024.0));\n  tmpvar_3.y = (xlat_mutablefactorA.x * 1024.0);\n  vec2 tmpvar_4;\n  tmpvar_4.x = tmpvar_3.x;\n  tmpvar_4.y = -(tmpvar_3.y);\n  uv_1 = (vec2(-64.0, 64.0) * (tmpvar_4 / (\n    (tmpvar_3.x * tmpvar_3.x)\n   + \n    (tmpvar_3.y * tmpvar_3.y)\n  )).yx);\n  uv_1 = (0.5 + ((1.0 - \n    abs(((fract(\n      (mix ((0.5 + (\n        ((0.5 + ((uv - 0.5) * vec2(0.9, 1.1))) - 0.5)\n       * 2.0)), (uv_1 + 0.5), vec2(0.5, 0.5)) * 0.5)\n    ) * 2.0) - 1.0))\n  ) - 0.5));\n  vec2 tmpvar_5;\n  tmpvar_5 = (texsize.zw * 4.0);\n  vec2 tmpvar_6;\n  tmpvar_6.x = (((2.0 * \n    ((texture (sampler_blur1, (uv_1 + (vec2(1.0, 0.0) * tmpvar_5))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_1 - (vec2(1.0, 0.0) * tmpvar_5))).xyz * scale1) + bias1)\n  )) * 0.5).y;\n  tmpvar_6.y = (((2.0 * \n    ((texture (sampler_blur1, (uv_1 + (vec2(0.0, 1.0) * tmpvar_5))).xyz * scale1) + bias1)\n  ) - (2.0 * \n    ((texture (sampler_blur1, (uv_1 - (vec2(0.0, 1.0) * tmpvar_5))).xyz * scale1) + bias1)\n  )) * 0.5).y;\n  vec2 tmpvar_7;\n  tmpvar_7 = (uv_1 - ((tmpvar_6 * texsize.zw) * 128.0));\n  ret_2 = (((\n    ((texture (sampler_blur2, tmpvar_7).xyz * scale2) + bias2)\n  .x * \n    clamp ((1.0 - texture (sampler_main, uv_1).y), 0.0, 1.0)\n  ) * pow (hue_shader.yxz, vec3(8.0, 8.0, 8.0))) * 3.0);\n  ret_2 = (mix (mix (ret_2, \n    (pow (hue_shader.yzx, vec3(8.0, 8.0, 8.0)) * 1.4)\n  , vec3(\n    ((texture (sampler_main, tmpvar_7).x * 0.8) + ((texture (sampler_blur1, tmpvar_7).xyz * scale1) + bias1).x)\n  )), vec3(1.0, 1.0, 1.0), (\n    (pow (hue_shader, vec3(8.0, 8.0, 8.0)) * texture (sampler_main, clamp (uv_1, 0.0, 1.0)).y)\n   * 1.2)) * clamp ((1.0 - texture (sampler_main, uv_1).z), 0.0, 1.0));\n  vec4 tmpvar_8;\n  tmpvar_8.w = 1.0;\n  tmpvar_8.xyz = ret_2;\n  ret = tmpvar_8.xyz;\n }","warp_hlsl":"#define sat saturate\nsampler sampler_pw_noise_lq;\nstatic const float quality = 4;\nfloat3 rsl, rsl3, ret1, sky, mod;\nfloat2 dz, uv0, uv1, uv2, uv3, uv4, uvc, dz1;\nfloat  lav_gnd,lav_gnd2, smask, ripple, l,d,i,p;\nstatic const float hory = q6, xyscale = q7, alti = q8;\nstatic const float2 hor = texsize.zw*float2 (1.5,0), dir = float2 (q3, q4), modran = float2 (q15,q16);\nstatic const float3 mov = float3 (q10,q11,0);\nfloat comb (float2 uvi) {return dot (tex2D(sampler_noise_lq, uvi).yx, float2(1,1));}\n\nfloat2 noise2 (float2 uvi) {float2 tmp = 1; float s = 1;\n  for (int n = 1; n <= 2; n +=1 ) {tmp *= 1-tex2D(sampler_noise_lq,uvi*s); s*= 3;}\n  return tmp;}\n\n\nfloat2 noise3 (float3 uvi, float3 mod) {uvi *= 0.16; float2 tmp = 1; float s = 1; float diff = 0;\n  uvi.xy+= modran*3;\n  for (int n = 1; n <= 2; n +=1 ) {tmp *= sat(1-tex2D(sampler_noise_lq,uvi*s)*(0.8+mod.y/2)/s); s*= 3+tmp*0.002*mod.z;}\n  for (int n = 1; n <= 3; n +=1 ) {tmp *= sat(1-tex2D(sampler_noise_lq,uvi*s)*(0.8+mod.y/2)/s); s*= 3;}\n  diff = sat (16-2*uvi.z-20000* abs (tmp.x-0.4)) ;\n  tmp  -= diff*0.009 ;\n  return 1-pow (tmp,0.8+mod.x);}\n\nfloat2 enoise3 (float2 uvi, float3 mod) {uvi/=6; float2 tmp = 1; float s = 1;\n  for (int n = 1; n <= 6; n +=1 ) {tmp *= 1-tex2D(sampler_noise_lq,uvi*s)/(0.8+mod.y)/s; s*= 2.9;}\n  if ((tmp.x > 0.398) && (tmp.x < 0.402)) {tmp = 0.398;}\n  return 1-pow (tmp,.8+2*mod.x);}\n\nfloat3 rs_lav (float2 uvi, float berg) {  float z; float2 rs;\n  z = 1/(uvi.y+hory)*(alti-berg*16); //z = clamp(z,0,4/xyscale);\n  rs.x = uvi.x * 2*z ; rs.y = z; \n  return float3(rs*xyscale,z); }\n\n\nshader_body {\nuv1=uv-0.5;\nlav_gnd=  -min (tex2D(sampler_fc_main,uv).b, tex2D(sampler_fc_main,uv+hor.yx).b);\n\nrsl = rs_lav(uv1,lav_gnd)+mov; \nmod = tex2D(sampler_noise_mq,rsl.xy*.043+modran);\n\ni=0, p=0;\nfor (int n=1; n <= quality; n++) {\n  p =  ((lav_gnd+noise3 (rsl, mod))/quality);\n  i += p;\n  lav_gnd -= p*0.1+i*0.2; \n  rsl = rs_lav(uv1,lav_gnd)+mov; \n}\nl = saturate(-lav_gnd);\n\nd=1.8;\ndz = -1.5/rsl.z*xyscale*d*dir;\n\nrsl3 = rsl * 8 + l*0;\nripple = ((noise2 (rsl3-dz) - noise2 (rsl3+dz))* (1-l))*1+0.02;\n\nripple = (1/rsl.z*ripple+noise3 (rsl-float3 (dz,0),mod) - noise3 (rsl+float3 (dz,0),mod))*(1-l)/d/sqrt(50+rsl.z)*2000;\n\nripple = 1-exp(-ripple);\n\nret.r = ripple;\nret.b = l;\nret = lerp(ret,GetBlur1(uv),0.1);\nret.g = rsl.z*xyscale*4;\n}","comp_hlsl":"float2 uvo, factorA, factorB, product, numerator, denominator, fraction;\nshader_body\n{\nuvo = 0.5 + (uv-0.5)*float2(0.9,1.1);\nfactorA = uv-float2(1-0.5,0.5);\nfactorB = float2(0,1024);\nproduct = float2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\nnumerator = float2(1,0);\ndenominator = product;\nfraction = float2( numerator.x*denominator.x + numerator.y*denominator.y,   // the fractions real part\n                   numerator.y*denominator.x - numerator.x*denominator.y)/  // the fractions imaginary part\n                   (denominator.x*denominator.x + denominator.y*denominator.y);\nuv = fraction.yx*float2(-1,1)*64;\nuv = lerp(0.5 + (uvo-0.5)*2,uv+0.5,0.5);\nuv = 0.5 + (1.0 - abs( frac( uv * 0.5 ) * 2 - 1.0 )-0.5); // Eo.S. mirror code with cutted borders\n\n    float2 d = texsize.zw*4;\n    float3 dx = ( 2*GetBlur1(uv+float2(1,0)*d)-2*GetBlur1(uv-float2(1,0)*d) )*0.5;\n    float3 dy = ( 2*GetBlur1(uv+float2(0,1)*d)-2*GetBlur1(uv-float2(0,1)*d) )*0.5;\n\nfloat2 uv_x = uv - float2(dx.y,dy.y)*texsize.zw*128;\nret = GetBlur2(uv_x).x*saturate(1-GetPixel(uv).y)*pow(hue_shader.yxz,8)*3;\nret = lerp(ret,pow(hue_shader.yzx,8)*1.4,GetPixel(uv_x).x*0.8 + GetBlur1(uv_x).x);\nret = lerp(ret,1,pow(hue_shader,8)*GetPixel(saturate(uv - float2(dx.z,dy.z)*2*0)).y*1.2);\nret *= saturate(1-GetPixel(uv).z);\n}"}